<!doctype html>
<html lang="ko" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-react/managing-state/preserving-and-resetting-state">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">상태 보존과 재설정 | 문서 보관소</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://autroshot.github.io/doc-archive/docs/react/managing-state/preserving-and-resetting-state"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="상태 보존과 재설정 | 문서 보관소"><meta data-rh="true" name="description" content="상태는 컴포넌트 간에 격리됩니다. 리액트는 UI 트리에서의 위치를 기준으로 어떤 상태가 어떤 컴포넌트에 속하는지 추적합니다. 리렌더링 간에 상태를 보존할 시기와 상태를 재설정할 시기를 제어할 수 있습니다."><meta data-rh="true" property="og:description" content="상태는 컴포넌트 간에 격리됩니다. 리액트는 UI 트리에서의 위치를 기준으로 어떤 상태가 어떤 컴포넌트에 속하는지 추적합니다. 리렌더링 간에 상태를 보존할 시기와 상태를 재설정할 시기를 제어할 수 있습니다."><link data-rh="true" rel="icon" href="/doc-archive/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://autroshot.github.io/doc-archive/docs/react/managing-state/preserving-and-resetting-state"><link data-rh="true" rel="alternate" href="https://autroshot.github.io/doc-archive/docs/react/managing-state/preserving-and-resetting-state" hreflang="ko"><link data-rh="true" rel="alternate" href="https://autroshot.github.io/doc-archive/docs/react/managing-state/preserving-and-resetting-state" hreflang="x-default"><link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-XLF32HX6M9"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-XLF32HX6M9",{anonymize_ip:!0})</script><link rel="stylesheet" href="/doc-archive/assets/css/styles.7bac36f5.css">
<link rel="preload" href="/doc-archive/assets/js/runtime~main.89d74258.js" as="script">
<link rel="preload" href="/doc-archive/assets/js/main.b0b08f92.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="Main" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/doc-archive/"><div class="navbar__logo"><img src="/doc-archive/img/logo.svg" alt="사이트 로고" class="themedImage_ToTc themedImage--light_HNdA"><img src="/doc-archive/img/logo.svg" alt="사이트 로고" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">문서 보관소</b></a><a class="navbar__item navbar__link" href="/doc-archive/docs/javascript/keyboard-keydown-and-keyup">JS</a><a class="navbar__item navbar__link" href="/doc-archive/docs/typescript">TS</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/doc-archive/docs/react">React</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">프레임워크</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/doc-archive/docs/nextjs">Next.js</a></li><li><a class="dropdown__link" href="/doc-archive/docs/electron">Electron</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">테스트</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/doc-archive/docs/jest">Jest</a></li><li><a class="dropdown__link" href="/doc-archive/docs/cypress">Cypress</a></li><li><a class="dropdown__link" href="/doc-archive/docs/playwright">Playwright</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">상태 관리</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/doc-archive/docs/zustand">Zustand</a></li><li><a class="dropdown__link" href="/doc-archive/docs/tanstack-query">TanStack Query</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">기타</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/doc-archive/docs/nextauthjs">NextAuth.js</a></li><li><a class="dropdown__link" href="/doc-archive/docs/vanilla-extract">Vanilla Extract</a></li><li><a class="dropdown__link" href="/doc-archive/docs/tailwind-css">Tailwind CSS</a></li><li><a class="dropdown__link" href="/doc-archive/docs/chakra-ui">Chakra UI</a></li><li><a class="dropdown__link" href="/doc-archive/docs/prisma">Prisma</a></li><li><a class="dropdown__link" href="/doc-archive/docs/docusaurus">Docusaurus</a></li><li><a class="dropdown__link" href="/doc-archive/docs/emmet">Emmet</a></li><li><a class="dropdown__link" href="/doc-archive/docs/yup">Yup</a></li><li><a class="dropdown__link" href="/doc-archive/docs/regular-expression">정규 표현식</a></li></ul></div><a class="navbar__item navbar__link" href="/doc-archive/docs/concepts/domain-name">개념</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/doc-archive/source">출처</a><a href="https://docs-glossary.vercel.app/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">용어집<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a href="https://github.com/autroshot/doc-archive" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="깃허브"></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search searchBarContainer_NW3z"><input placeholder="검색하기" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="맨 위로 스크롤하기" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd sidebarWithHideableNavbar_wUlq"><a tabindex="-1" class="sidebarLogo_isFc" href="/doc-archive/"><img src="/doc-archive/img/logo.svg" alt="사이트 로고" class="themedImage_ToTc themedImage--light_HNdA"><img src="/doc-archive/img/logo.svg" alt="사이트 로고" class="themedImage_ToTc themedImage--dark_i4oU"><b>문서 보관소</b></a><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doc-archive/docs/react">개요</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/doc-archive/docs/react/describing-the-ui/keeping-components-pure">UI 묘사하기</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/doc-archive/docs/react/adding-interactivity/render-and-commit">상호 작용 추가하기</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/doc-archive/docs/react/managing-state/choosing-the-state-structure">상태 관리하기</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doc-archive/docs/react/managing-state/choosing-the-state-structure">상태의 구조 선택하기</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/doc-archive/docs/react/managing-state/preserving-and-resetting-state">상태 보존과 재설정</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doc-archive/docs/react/managing-state/extracting-state-logic-into-a-reducer">상태 논리를 변환기로 추출하기</a></li></ul></li></ul></nav><button type="button" title="사이드바 숨기기" aria-label="사이드바 숨기기" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="홈" class="breadcrumbs__link" href="/doc-archive/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">상태 관리하기</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">상태 보존과 재설정</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">이 페이지에서</button></div><div class="theme-doc-markdown markdown"><h1>상태 보존과 재설정</h1><p>상태는 컴포넌트 간에 격리됩니다. 리액트는 UI 트리에서의 위치를 기준으로 어떤 상태가 어떤 컴포넌트에 속하는지 추적합니다. 리렌더링 간에 상태를 보존할 시기와 상태를 재설정할 시기를 제어할 수 있습니다.</p><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>학습 내용</div><div class="admonitionContent_S0QG"><ul><li>리액트가 컴포넌트 구조를 보는 방법</li><li>리액트가 언제 상태를 보존하거나 재설정하기로 선택하는지</li><li>리액트가 컴포넌트의 상태를 재설정하도록 강제하는 방법</li><li>키와 타입이 상태 보존 여부에 미치는 영향</li></ul></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="ui-트리">UI 트리<a href="#ui-트리" class="hash-link" aria-label="UI 트리에 대한 직접 링크" title="UI 트리에 대한 직접 링크">​</a></h2><p>브라우저는 많은 트리 구조를 사용하여 UI를 모델링합니다. <a href="https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction" target="_blank" rel="noopener noreferrer">DOM</a>은 HTML 요소를 나타내고, <a href="https://developer.mozilla.org/docs/Web/API/CSS_Object_Model" target="_blank" rel="noopener noreferrer">CSSOM</a>은 CSS와 동일합니다. 심지어 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Accessibility_tree" target="_blank" rel="noopener noreferrer">접근성</a>도 있습니다!</p><p>리액트 또한 트리 구조를 사용하여 여러분이 만든 UI를 관리하고 모델링합니다. 리액트는 JSX에서 <strong>UI 트리</strong>를 만듭니다. 그런 다음 리액트 DOM은 해당 UI 트리와 일치하도록 브라우저 DOM 요소를 갱신합니다. (리액트 네이티브는 이 트리를 모바일 플랫폼에 특화된 요소로 변환합니다.)</p><div style="background-size:cover;background-repeat:no-repeat;position:relative;background-image:url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAACCAYAAABhYU3QAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAXUlEQVQImQFSAK3/AOPr8cnm7PG5icvwIf///wDi6u9K3OTqFf///wDq9fuJ8Pf8//39/fkA4uvw7OXs8NxjsNwT0uPuOdrl7D3n7vNNABt8CN7v+Yfi8fr//P39+hV5PiYnrx5jAAAAAElFTkSuQmCC&quot;);margin-top:20px;margin-bottom:20px"><svg style="width:100%;height:auto;max-width:100%;margin-bottom:-4px" width="1080" height="240"></svg><noscript><img style="width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0" src="/doc-archive/assets/ideal-img/preserving-state-dom-tree.c6b336d.1080.png" srcset="/doc-archive/assets/ideal-img/preserving-state-dom-tree.c6b336d.1080.png 1080w" alt="세 개의 부분이 수평으로 배열된 다이어그램입니다. 첫 번째 부분에는 &#x27;컴포넌트 A&#x27;, &#x27;컴포넌트 B&#x27;, &#x27;컴포넌트 C&#x27;라는 레이블이 있는 세 개의 직사각형이 수직으로 쌓여 있습니다. 다음 창으로 향하는 화살표에는 리액트 로고가 있습니다. 중간 부분에는 &#x27;A&#x27;라는 루트와 &#x27;B&#x27;와 &#x27;C&#x27;라는 두 자식이 있는 컴포넌트 트리가 있습니다. 다음 부분으로 향하는 화살표에는 리액트 로고가 있습니다. 세 번째이자 마지막 부분은 8개 노드의 트리를 포함하는 브라우저의 와이어프레임으로, 하위 집합만 강조 표시됩니다(중간 부분의 하위 트리를 가리킴)." width="1080" height="240"></noscript></div><p>리액트는 컴포넌트에서 리액트 DOM이 DOM을 렌더링하는 데 사용하는 UI 트리를 생성합니다.</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="상태는-트리의-위치에-연결된다">상태는 트리의 위치에 연결된다<a href="#상태는-트리의-위치에-연결된다" class="hash-link" aria-label="상태는 트리의 위치에 연결된다에 대한 직접 링크" title="상태는 트리의 위치에 연결된다에 대한 직접 링크">​</a></h2><p>컴포넌트 상태를 만들면, 상태가 컴포넌트 내부에 <strong>살아 있다</strong>고 생각할 수 있습니다. 그러나 실제로는, 상태는 리액트 내부에 보관됩니다. 리액트는 해당 컴포넌트가 UI 트리에 있는 위치에 따라, 보유하고 있는 각 상태 조각을 올바른 컴포넌트와 연결합니다.</p><p>다음 예시에서 <code>&lt;Counter /&gt;</code> JSX 태그는 하나뿐이지만, 두 곳의 다른 위치에서 렌더링됩니다.</p><iframe src="https://codesandbox.io/embed/elated-frog-zcc3dp?codemirror=1&amp;fontsize=14&amp;hidenavigation=1&amp;view=editor&amp;module=%2FApp.js" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="elated-frog-zcc3dp" allow="accelerometer; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>트리의 모습은 다음과 같습니다.</p><div style="background-size:cover;background-repeat:no-repeat;position:relative;background-image:url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAHCAYAAAAxrNxjAAAACXBIWXMAAAsTAAALEwEAmpwYAAABFklEQVQYlRXKP0vDQBiA8dcqFAsuIuLkB3LRQToICn4MJz+Ak84Oimi0na0gbrHRKYK2SSoUWjShrV7PXHK53J/klWwPPx4YhnP4+okXSmOAMt4gjFPGBY6+Z5uUMhhFpDYMCcD1Uw/eBlMYRhQQsTaIyMkgJOfxH1sZT+bQ+5zC5YMLcPX4UfdHZPm45awfnN2vAcAiACztnnZWjyx7ww2ixkXHrYOQ+p2mwp/QpC+UjpiQO1yoLSF1WNk8yTylTb8aMU5znFGOXGhMc3WYZHIvyzX+xhmSWKDSBkGrQgleFjovpZIFCmX2c6mbVedZKbVEU5iygJYTMKvro/Xs6zsnwPZr0Gy/BNu3XR9vbM9Ytoctxxf/f9bZAlGNTgAAAAAASUVORK5CYII=&quot;);max-width:24rem;margin-top:20px;margin-bottom:20px"><svg style="width:100%;height:auto;max-width:100%;margin-bottom:-4px" width="640" height="402"></svg><noscript><img style="width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0" src="/doc-archive/assets/ideal-img/preserving-state-tree.de6de56.640.png" srcset="/doc-archive/assets/ideal-img/preserving-state-tree.de6de56.640.png 640w" alt="리액트 컴포넌트의 트리 그림입니다. 루트 노드의 레이블은 &#x27;div&#x27;이며 두 개의 자식을 가집니다. 각 자식은 &#x27;Counter&#x27;이며, 둘 다 값이 0인 &#x27;count&#x27; 상태 방울이 포함되어 있습니다." width="640" height="402"></noscript></div><p><strong>두 카운터가 트리에서 각자의 고유한 위치에 렌더링되기 때문에 이들은 별개의 카운터입니다.</strong> 보통 리액트를 사용하기 위해 이러한 위치에 대해 생각할 필요는 없지만, 작동 방식을 이해하는 데 도움이 될 수 있습니다.</p><p>리액트에서 화면의 각 컴포넌트는 완전히 격리된 상태입니다. 예를 들어 두 개의 <code>Counter</code> 컴포넌트를 나란히 렌더링하면, 각 컴포넌트는 고유하고 독립적인 <code>score</code>와 <code>hover</code> 상태를 갖게 됩니다.</p><p>다음 두 카운터를 모두 클릭하고 서로 영향을 주지 않는 것을 확인해 보세요.</p><iframe src="https://codesandbox.io/embed/inspiring-pike-3jz97w?codemirror=1&amp;fontsize=14&amp;hidenavigation=1&amp;view=editor&amp;module=%2FApp.js" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="inspiring-pike-3jz97w" allow="accelerometer; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>보시다시피 하나의 카운터가 갱신되면 해당 컴포넌트의 상태만 갱신됩니다.</p><div style="background-size:cover;background-repeat:no-repeat;position:relative;background-image:url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAGCAYAAAD68A/GAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA10lEQVQImSXKMU7DQBAF0IGIA1DTcwFAaajgCpyJNhIFZ0kQF0AUpiISwUgQC0t24qzXOzuzTKyPVil+8f9/5FmOuyGevK8b8iFeeFb0LPO3nx0BmLghTjzLEbkQKYjmkR4XxelrWd+/rH7vcs9xAnJslOFlH2S6rNqb5Xpzlc+nojz7qMPtqrXrNGK6HdI5STK0PWPTM5LtuwyTjQ+WApqm2ivvICrPFMUssI0hGEStBQpS3s7+fA0evOx9BenKOUU9wBgNkjIEqfLM3De0/ZTRfUGjX/wDl8PG0uQuMFoAAAAASUVORK5CYII=&quot;);max-width:24rem;margin-top:20px;margin-bottom:20px"><svg style="width:100%;height:auto;max-width:100%;margin-bottom:-4px" width="640" height="360"></svg><noscript><img style="width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0" src="/doc-archive/assets/ideal-img/preserving-state-increment.dd54126.640.png" srcset="/doc-archive/assets/ideal-img/preserving-state-increment.dd54126.640.png 640w" alt="리액트 컴포넌트의 트리 그림입니다. 루트 노드의 레이블은 &#x27;div&#x27;이며 두 개의 자식을 가집니다. 왼쪽 자식은 &#x27;Counter&#x27;이며, 값이 0인 &#x27;count&#x27; 상태 방울이 포함됩니다. 오른쪽 자식은 &#x27;Counter&#x27;이며, 값이 1인 &#x27;count&#x27; 상태 방울이 포함됩니다. 오른쪽 자식의 상태 방울이 노란색으로 강조 표시되어 해당 값이 갱신되었음을 나타냅니다." width="640" height="360"></noscript></div><p>리액트는 동일한 위치에서 동일한 컴포넌트를 렌더링하는 한 상태를 유지합니다. 이를 확인하려면 두 카운터를 모두 증가시킨 다음, <code>Render the second counter</code> 확인란을 선택 취소하여 두 번째 컴포넌트를 제거한 다음, 다시 선택하여 추가합니다.</p><iframe src="https://codesandbox.io/embed/romantic-wildflower-wxsc2o?codemirror=1&amp;fontsize=14&amp;hidenavigation=1&amp;view=editor&amp;module=%2FApp.js" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="romantic-wildflower-wxsc2o" allow="accelerometer; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>두 번째 카운터의 렌더링을 중지하는 순간, 해당 상태가 완전히 사라지는 것을 확인하세요. 이는 리액트가 컴포넌트를 제거하면 해당 컴포넌트의 상태가 파괴되기 때문입니다.</p><div style="background-size:cover;background-repeat:no-repeat;position:relative;background-image:url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAGCAYAAAD68A/GAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA0ElEQVQImR2KPU7DQBBGh6TOGUBIIM7Aj1JQ0SBxOW7BBdKTGtEFhBCFQQobb9bO2mPvzPchU7zi6T0JKc/aTuePqxchuQgptyEdWsIX648gVnQOcia7lAWOaRIROVq9fj48v1X3k//jKphaSIfL2PbLTRXuvrZxOc1P63cp5HVWvbWiNySvRMdi8dDxN2Wau/3U6YLkKWwoMCWGBACUXovF/cB6r1Q1/67jOckTDMnghRgzMDSUXdONdeoRm56x7W1Tbc9IHsNthNZEyQ4f/Q9J9MK3rKxWhAAAAABJRU5ErkJggg==&quot;);max-width:24rem;margin-top:20px;margin-bottom:20px"><svg style="width:100%;height:auto;max-width:100%;margin-bottom:-4px" width="640" height="384"></svg><noscript><img style="width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0" src="/doc-archive/assets/ideal-img/preserving-state-remove-component.106522b.640.png" srcset="/doc-archive/assets/ideal-img/preserving-state-remove-component.106522b.640.png 640w" alt="리액트 컴포넌트의 트리 그림입니다. 루트 노드의 레이블은 &#x27;div&#x27;이며 두 개의 자식을 가집니다. 왼쪽 자식은 &#x27;Counter&#x27;이며, 값이 0인 &#x27;count&#x27; 상태 방울이 포함됩니다. 오른쪽 자식이 사라지고 그 자리에 노란색 &#x27;펑&#x27; 이미지가 표시되어, 트리에서 컴포넌트가 삭제되었음을 강조 표시합니다." width="640" height="384"></noscript></div><p><code>Render the second counter</code>을 선택하면, 두 번째 <code>Counter</code>와 해당 컴포넌트의 상태가 초기화되고(<code>score = 0</code>) DOM에 추가됩니다.</p><div style="background-size:cover;background-repeat:no-repeat;position:relative;background-image:url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAFCAYAAAB8ZH1oAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAwklEQVQImU2JvUrDUBxH/9BX8BHqKg6lS/EdBPEF3NKtz+DuU7TUTScF59JJRYJ10QhNoA3k5hq93x/JT4iLwzlnOASAAAzocNaXC/XJhb1D80rIb6n8+9TrPw+P6bjcZWdgTxNUq2EL0JSIqFH2SFo/r4VeSOOWmwYHqJ8T950zwYu3KIp1u70fkfYhMTaANQraRvxUHydgL1dCe+y/HIz1aN+vL0haf6506KQIwZgIxuvjrk4vpdCQMlpnTBezm9NfP6ifQYqjbUYAAAAASUVORK5CYII=&quot;);max-width:31rem;margin-top:20px;margin-bottom:20px"><svg style="width:100%;height:auto;max-width:100%;margin-bottom:-4px" width="640" height="330"></svg><noscript><img style="width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0" src="/doc-archive/assets/ideal-img/preserving-state-add-component.3433de0.640.png" srcset="/doc-archive/assets/ideal-img/preserving-state-add-component.3433de0.640.png 640w" alt="리액트 컴포넌트의 트리 그림입니다. 루트 노드의 레이블은 &#x27;div&#x27;이며 두 개의 자식을 가집니다. 왼쪽 자식은 &#x27;Counter&#x27;이며, 값이 0인 &#x27;count&#x27; 상태 방울이 포함됩니다. 오른쪽 자식은 &#x27;Counter&#x27;이며, 값이 0인 &#x27;count&#x27; 상태 방울이 포함됩니다. 오른쪽 자식 노드 전체가 노란색으로 강조 표시되어 방금 트리에 추가되었음을 나타냅니다." width="640" height="330"></noscript></div><p><strong>리액트는 컴포넌트가 UI 트리의 해당 위치에서 렌더링되는 동안 컴포넌트의 상태를 유지합니다.</strong> 해당 컴포넌트가 제거되거나 다른 컴포넌트가 동일한 위치에서 렌더링되면 리액트는 해당 상태를 삭제합니다.</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="동일한-위치에-있는-동일한-컴포넌트는-상태를-보존한다">동일한 위치에 있는 동일한 컴포넌트는 상태를 보존한다<a href="#동일한-위치에-있는-동일한-컴포넌트는-상태를-보존한다" class="hash-link" aria-label="동일한 위치에 있는 동일한 컴포넌트는 상태를 보존한다에 대한 직접 링크" title="동일한 위치에 있는 동일한 컴포넌트는 상태를 보존한다에 대한 직접 링크">​</a></h2><p>다음 예시에는 두 개의 다른 <code>&lt;Counter /&gt;</code> 태그가 있습니다.</p><iframe src="https://codesandbox.io/embed/bold-einstein-8swdmv?codemirror=1&amp;fontsize=14&amp;hidenavigation=1&amp;view=editor&amp;module=%2FApp.js" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="bold-einstein-8swdmv" allow="accelerometer; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>확인란을 선택하거나 선택을 취소해도 카운터 상태가 재설정되지 않습니다. <code>isFancy</code>가 <code>true</code>이든 <code>false</code>이든, 루트 <code>App</code> 컴포넌트에서 반환된 <code>div</code>의 첫 번째 자식으로 항상 <code>&lt;Counter /&gt;</code>가 있습니다.</p><p><code>Counter</code>는 동일한 위치에 있기 때문에 <code>App</code> 상태를 갱신해도 <code>Counter</code>가 재설정되지 않습니다.</p><div style="background-size:cover;background-repeat:no-repeat;position:relative;background-image:url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAICAYAAADA+m62AAAACXBIWXMAAAsTAAALEwEAmpwYAAABPUlEQVQYlS2QO0sDQRRGL5outb9Ae8G/IDY2NmphKYEgFqKxshGCAQstFIJBC+1iE0QIxCo+ELK4BhLMYjQGUuSdnUV2Z2bnkc2VBYvTfJzi8IFUmnGhfKE0+lJlERE+vn4iQo0NX2rkQgmlxz5wrvDXFeh6En2hCqFoIUYUIw3udNAjHdReH6Fne8kBYbkBodmu7a7ly10I5d5ouEvIsODY/WLftk/ArBJwqJdmmm402y7sXBejy8e5aKNlA+VknzFyUW0hwFaivhlPWI/xPetue+97ATJz0wAzU5fnLyvJozfrMFluZM6eDuC5RJbMipN/rzhXxdfR7OltHW7uTTCM5nyt1nv4tDpmyWgvQjAZZ5gvUCqFEwzWw76QADHGpQqfwAAnKaBMphnXyJhCyuUq4xL+iVGmkHMd7qk/lDP5NKIT79gAAAAASUVORK5CYII=&quot;);max-width:37.5rem;margin-top:20px;margin-bottom:20px"><svg style="width:100%;height:auto;max-width:100%;margin-bottom:-4px" width="640" height="492"></svg><noscript><img style="width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0" src="/doc-archive/assets/ideal-img/preserving-state-same-component.4ff0503.640.png" srcset="/doc-archive/assets/ideal-img/preserving-state-same-component.4ff0503.640.png 640w" alt="두 부분 사이를 전환하는 화살표로 구분된 두 부분이 있는 그림입니다. 각 부분에는 &#x27;isFancy&#x27;라는 상태 방울이 포함된 &#x27;App&#x27;이라는 부모가 있는 컴포넌트 레이아웃이 포함되어 있습니다. 이 컴포넌트에는 &#x27;div&#x27;라는 하나의 자식이 있으며, 이는 유일한 자식에게 전달되는 &#x27;isFancy&#x27;(보라색으로 강조 표시됨)가 포함된 프롭 방울로 연결됩니다. 마지막 자식은 &#x27;Counter&#x27;이며, 두 그림 모두에 값이 3인 &#x27;count&#x27; 상태 방울이 포함됩니다. 그림의 왼쪽 부분에서는 아무것도 강조 표시되지 않으며 &#x27;isFancy&#x27; 부모의 상태 값이 &#x27;false&#x27;입니다. 그림의 오른쪽 부분에서 &#x27;isFancy&#x27; 부모의 상태 값이 &#x27;true&#x27;로 변경되고 노란색으로 강조 표시됩니다. 하단의 프롭 방울의 &#x27;isFancy&#x27; 값도 &#x27;true&#x27;로 변경됩니다." width="640" height="492"></noscript></div><p>동일한 위치에 있는 동일한 컴포넌트이므로, 리액트 관점에서는 동일한 카운터입니다.</p><div class="theme-admonition theme-admonition-caution alert alert--warning admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>함정</div><div class="admonitionContent_S0QG"><p><strong>리액트에서 중요한 것은 JSX 마크업에서의 위치가 아니라 UI 트리에서의 위치</strong>라는 것을 기억하세요! 다음 컴포넌트에는 <code>if</code> 안팎에 다른 <code>&lt;Counter /&gt;</code> JSX 태그를 가진 두 개의 <code>return</code> 절이 있습니다.</p><iframe src="https://codesandbox.io/embed/nostalgic-alex-18c6we?codemirror=1&amp;fontsize=14&amp;hidenavigation=1&amp;view=editor&amp;module=%2FApp.js" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="nostalgic-alex-18c6we" allow="accelerometer; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>확인란을 선택하면 상태가 재설정될 것으로 예상할 수 있지만 그렇지 않습니다! 이는 <strong>두 <code>&lt;Counter /&gt;</code> 태그가 모두 같은 위치에서 렌더링되기 때문입니다</strong>. 리액트는 함수에서 조건문이 어디에 있는지 모릅니다. 반환하는 트리만 봅니다.</p><p>두 경우 모두 <code>App</code> 컴포넌트는 <code>&lt;Counter /&gt;</code>가 첫 번째 자식인 <code>&lt;div&gt;</code>를 반환합니다. 리액트에게 두 카운터는 루트의 첫 번째 자식의 첫 번째 자식이라는 동일한 <strong>주소</strong>를 가집니다. 이것이 리액트가 논리를 구성하는 방법에 관계없이 이전 렌더링과 다음 렌더링 간에 컴포넌트를 일치시키는 방법입니다.</p></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="동일한-위치의-다른-컴포넌트는-상태를-재설정한다">동일한 위치의 다른 컴포넌트는 상태를 재설정한다<a href="#동일한-위치의-다른-컴포넌트는-상태를-재설정한다" class="hash-link" aria-label="동일한 위치의 다른 컴포넌트는 상태를 재설정한다에 대한 직접 링크" title="동일한 위치의 다른 컴포넌트는 상태를 재설정한다에 대한 직접 링크">​</a></h2><p>다음 예시에서 확인란을 선택하면 <code>&lt;Counter&gt;</code>가 <code>&lt;p&gt;</code>로 바뀝니다.</p><iframe src="https://codesandbox.io/embed/sharp-pine-6gbws5?codemirror=1&amp;fontsize=14&amp;hidenavigation=1&amp;view=editor&amp;module=%2FApp.js" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="sharp-pine-6gbws5" allow="accelerometer; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>여기서는 동일한 위치에서 <strong>다른</strong> 컴포넌트 타입으로 전환됩니다. 처음에는 <code>&lt;div&gt;</code>의 첫 번째 자식에 <code>Counter</code>가 포함되었습니다. 그러나 <code>p</code>로 교체했을 때, 리액트는 UI 트리에서 <code>Counter</code>를 제거하고 해당 상태를 파괴했습니다.</p><p><code>Counter</code>가 <code>p</code>로 변경되면, <code>Counter</code>가 삭제되고 <code>p</code>가 추가됩니다.</p><div style="background-size:cover;background-repeat:no-repeat;position:relative;background-image:url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAECAYAAAC3OK7NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAqUlEQVQImRXKvQqCUAAG0I8g6AmcamwIanVor0dobwkE9xoae4G2HiJ6jdagMQpE0szr9fp77Ue/6MwHN0/2nEBZZAOScJ7J/OrLAVnjERfmXSRW4LtAUupplBUzT6R9c7HrsNZ2mmVjwGjR2Rv6chiVJJDm1VelmqX+rEi33bxzNpXcZrGPt3+cvILTMvpHoQo7UuUmjHNTihB1pYa1ll02AmcSIQmugR+Pn3SrxeoqjQAAAABJRU5ErkJggg==&quot;);max-width:47rem;margin-top:20px;margin-bottom:20px"><svg style="width:100%;height:auto;max-width:100%;margin-bottom:-4px" width="828" height="319"></svg><noscript><img style="width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0" src="/doc-archive/assets/ideal-img/preserving-state-diff-1.60385b8.828.png" srcset="/doc-archive/assets/ideal-img/preserving-state-diff-1.60385b8.828.png 828w" alt="세 개의 부분이 있는 그림입니다. 각 부분 사이를 전환하는 화살표가 있습니다. 첫 번째 부분에는 &#x27;div&#x27;라는 리액트 컴포넌트와 &#x27;Counter&#x27;라는 단일 자식 컴포넌트가 포함되어 있습니다. &#x27;Counter&#x27; 컴포넌트에는 값이 3인 &#x27;count&#x27; 상태 방울이 포함됩니다. 가운데 부분에는 동일한 &#x27;div&#x27; 부모가 있지만, 이제 자식 컴포넌트가 삭제되어 노란색 &#x27;펑&#x27; 이미지로 표시됩니다. 세 번째 부분에는 다시 동일한 &#x27;div&#x27; 부모가 있습니다. 이제 밑에는 &#x27;p&#x27;라는 새로운 자식 컴포넌트가 있으며 노란색으로 강조 표시됩니다." width="828" height="319"></noscript></div><p>다시 전환하면 <code>p</code>가 삭제되고 <code>Counter</code>가 추가됩니다.</p><div style="background-size:cover;background-repeat:no-repeat;position:relative;background-image:url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAECAYAAAC3OK7NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAr0lEQVQImQGkAFv/AOTr8CXj6/BwdY68AP///wDh6vFf3+nvLf39+ADm7/gw5e3yae/p3AAA2eTsEN/q7zr///8AhKHADf/9923y9PQ/MGOZCP7isyz12qs5/uW/EgDk6/ES5+7zQe/w7QD///QV/vrz//758o//ylsP9/Pu/PT19//97deDAOXr8QDn7vMAwcrNAM/+/wD+9+0k/fv6FfzXmRH47+TK9/Hr5/vr0mSya3TnNwOVqQAAAABJRU5ErkJggg==&quot;);max-width:47rem;margin-top:20px;margin-bottom:20px"><svg style="width:100%;height:auto;max-width:100%;margin-bottom:-4px" width="828" height="319"></svg><noscript><img style="width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0" src="/doc-archive/assets/ideal-img/preserving-state-diff-2.ef2b245.828.png" srcset="/doc-archive/assets/ideal-img/preserving-state-diff-2.ef2b245.828.png 828w" alt="세 개의 부분이 있는 그림입니다. 각 부분 사이를 전환하는 화살표가 있습니다. 첫 번째 부분에는 &#x27;p&#x27;라는 리액트 컴포넌트가 포함됩니다. 가운데 부분에는 동일한 &#x27;div&#x27; 부모가 있지만, 이제 자식 컴포넌트가 삭제되어 노란색 &#x27;펑&#x27; 이미지로 표시됩니다. 세 번째 부분에는 다시 동일한 &#x27;div&#x27; 부모가 있습니다. 이제 밑에는 &#x27;Counter&#x27;라는 새로운 자식이 노란색으로 강조 표시됩니다. 자식 컴포넌트에는 값이 0인 &#x27;count&#x27; 상태 방울이 포함됩니다." width="828" height="319"></noscript></div><p>또한 <strong>동일한 위치에 다른 컴포넌트를 렌더링하면 전체 하위 트리의 상태가 재설정됩니다.</strong> 이를 확인하려면 다음 카운터를 증가시키고 확인란을 선택해 보세요.</p><iframe src="https://codesandbox.io/embed/dawn-grass-meowu5?codemirror=1&amp;fontsize=14&amp;hidenavigation=1&amp;view=editor&amp;module=%2FApp.js" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="dawn-grass-meowu5" allow="accelerometer; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>확인란을 클릭하면 카운터 상태가 재설정됩니다. <code>Counter</code>를 렌더링하더라도, <code>div</code>의 첫 번째 자식은 <code>div</code>에서 <code>section</code>으로 변경됩니다. 하위 <code>div</code>가 DOM에서 제거되면, 그 아래의 전체 트리(<code>Counter</code>와 해당 상태 포함)도 모두 파괴됩니다.</p><p><code>section</code>이 <code>div</code>로 변경되면, <code>section</code>이 삭제되고 새로운 <code>div</code>가 추가됩니다.</p><div style="background-size:cover;background-repeat:no-repeat;position:relative;background-image:url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAECAYAAAC3OK7NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAr0lEQVQImQGkAFv/AP///wDl7PJz4envJOju8QDm7fJE5OvwR+js7ADl5uAo6evndADW/wAAtsXfA+Pr8IPc5u03////AP/79KX++fPA////APLduS7669J8yv//AAD4+vtG7PH1sfL1+HPv7OQA/vrza/769Xr/pQUF+fDfnfbw5tb87NNgAPT2+nHv8vf/8vX5t+ra8QD+/vwA//HZAP/OcRD38efW8/L0//vs1oiC4HqHi0kjTwAAAABJRU5ErkJggg==&quot;);max-width:49.5rem;margin-top:20px;margin-bottom:20px"><svg style="width:100%;height:auto;max-width:100%;margin-bottom:-4px" width="828" height="365"></svg><noscript><img style="width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0" src="/doc-archive/assets/ideal-img/preserving-state-diff-same-1.5afbdf9.828.png" srcset="/doc-archive/assets/ideal-img/preserving-state-diff-same-1.5afbdf9.828.png 828w" alt="세 개의 부분이 있는 그림입니다. 각 부분 사이를 전환하는 화살표가 있습니다. 첫 번째 부분에는 &#x27;div&#x27;라는 리액트 컴포넌트가 있습니다. 그 아래에는 &#x27;section&#x27;이라는 단일 자식이 있습니다. 그 아래에는 값이 3인 &#x27;count&#x27; 상태 방울이 포함된 &#x27;Counter&#x27;라는 단일 자식이 있습니다. 가운데 부분에는 동일한 &#x27;div&#x27; 부모가 있지만, 이제 자식 컴포넌트들이 삭제되어 노란색 &#x27;펑&#x27; 이미지로 표시됩니다. 세 번째 부분에는 다시 동일한 &#x27;div&#x27; 부모가 있습니다. 이제 그 아래에는 노란색으로 강조 표시되며 &#x27;div&#x27;라는 새로운 자식이 있습니다. 그 아래에는 모두 노란색으로 강조 표시되며, 값이 0인 &#x27;count&#x27; 상태 방울이 포함된 &#x27;Counter&#x27;라는 새로운 자식이 있습니다." width="828" height="365"></noscript></div><p>다시 전환하면 <code>div</code>가 삭제되고 새로운 <code>section</code>이 추가됩니다.</p><div style="background-size:cover;background-repeat:no-repeat;position:relative;background-image:url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAECAYAAAC3OK7NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAr0lEQVQImQGkAFv/AHypuADj6/Fv3eftIObt8ADl7fJH4+vwROft7gDo598s6uzoev/gdgIA7PL1AOLq8FW3zN0T////AP/79Kz9+fO4////APPky0v069ue/sx8DwD4+vtG7/P2sPT2+XPz8OkA/vrzcf779XX/fQAD+e/en/bw5df87NJgAPT2+XHv8vf/8vT4t+HT7gD//vsA//HYAP/PchD38ejW8/L0//vs1ojrJ3lvRV6KSgAAAABJRU5ErkJggg==&quot;);max-width:49.5rem;margin-top:20px;margin-bottom:20px"><svg style="width:100%;height:auto;max-width:100%;margin-bottom:-4px" width="828" height="365"></svg><noscript><img style="width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0" src="/doc-archive/assets/ideal-img/preserving-state-diff-same-2.27a388b.828.png" srcset="/doc-archive/assets/ideal-img/preserving-state-diff-same-2.27a388b.828.png 828w" alt="세 개의 부분이 있는 그림입니다. 각 부분 사이를 전환하는 화살표가 있습니다. 첫 번째 부분에는 &#x27;div&#x27;라는 리액트 컴포넌트가 있습니다. 그 아래에는 &#x27;div&#x27;라는 단일 자식이 있습니다. 그 아래에는 값이 0인 &#x27;count&#x27; 상태 방울이 포함된 &#x27;Counter&#x27;라는 단일 자식이 있습니다. 가운데 부분에는 동일한 &#x27;div&#x27; 부모가 있지만, 이제 자식 컴포넌트들이 삭제되어 노란색 &#x27;펑&#x27; 이미지로 표시됩니다. 세 번째 부분에는 다시 동일한 &#x27;div&#x27; 부모가 있습니다. 이제 그 아래에는 &#x27;section&#x27;이라는 새로운 자식이 있으며 노란색으로 강조 표시됩니다. 그 아래에는 모두 노란색으로 강조 표시되며, 값이 0인 &#x27;count&#x27; 상태 방울이 포함된 &#x27;Counter&#x27;라는 새로운 자식이 있습니다." width="828" height="365"></noscript></div><p>경험적으로, <strong>리렌더링 사이에서 상태를 보존하려면 트리 구조가 서로 &#x27;일치&#x27;해야 합니다</strong>. 구조가 다르면 리액트가 트리에서 컴포넌트를 제거할 때 상태를 파괴합니다.</p><div class="theme-admonition theme-admonition-caution alert alert--warning admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>함정</div><div class="admonitionContent_S0QG"><p>이것이 컴포넌트 함수 정의를 중첩해서는 안 되는 이유입니다.</p><p>다음 예시에서 <code>MyTextField</code> 컴포넌트 함수는 <code>MyComponent</code> <strong>내부</strong>에 정의되어 있습니다.</p><iframe src="https://codesandbox.io/embed/lucid-napier-0p1vil?codemirror=1&amp;fontsize=14&amp;hidenavigation=1&amp;view=editor&amp;module=%2FApp.js" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="lucid-napier-0p1vil" allow="accelerometer; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>버튼을 클릭할 때마다 입력의 상태가 사라집니다! 이는 <code>MyComponent</code>의 렌더링마다 <strong>다른</strong> <code>MyTextField</code> 함수가 생성되기 때문입니다. 동일한 위치에서 <strong>다른</strong> 컴포넌트를 렌더링하므로 리액트는 그 아래의 모든 상태를 재설정합니다. 이로 인해 버그와 성능 문제가 발생합니다. 이 문제를 피하려면 <strong>항상 컴포넌트 함수를 최상위 수준에서 선언하고 컴포넌트 함수 정의를 중첩하지 마세요</strong>.</p></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="동일한-위치에서-상태-재설정하기">동일한 위치에서 상태 재설정하기<a href="#동일한-위치에서-상태-재설정하기" class="hash-link" aria-label="동일한 위치에서 상태 재설정하기에 대한 직접 링크" title="동일한 위치에서 상태 재설정하기에 대한 직접 링크">​</a></h2><p>기본적으로 리액트는 컴포넌트가 동일한 위치에 있는 동안 상태를 보존합니다. 보통은 이런 동작을 원하므로 이는 기본 동작으로 적합합니다. 그러나 때로는 컴포넌트의 상태를 재설정하는 것을 원할 수 있습니다.</p><p>두 명의 플레이어가 각 턴 동안 자신의 점수를 추적할 수 있는 다음 앱을 살펴보세요.</p><iframe src="https://codesandbox.io/embed/zen-sunset-fi5b4y?codemirror=1&amp;fontsize=14&amp;hidenavigation=1&amp;view=editor&amp;module=%2FApp.js" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="zen-sunset-fi5b4y" allow="accelerometer; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>현재는 플레이어를 변경해도 점수가 유지됩니다. 두 개의 <code>Counter</code>는 동일한 위치에 나타나므로 리액트는 둘을 <code>person</code> 프롭이 바뀐 <strong>동일한</strong> <code>Counter</code>로 봅니다.</p><p>그러나 개념적으로 이 앱에서는 두 개가 별도의 카운터여야 합니다. 이들은 UI에서 같은 위치에 나타날 수 있지만, 하나는 테일러에 대한 카운터이고 다른 하나는 사라에 대한 카운터입니다.</p><p>둘을 전환할 때 상태를 재설정하는 방법은 두 가지가 있습니다.</p><ol><li>컴포넌트를 다른 위치에서 렌더링합니다.</li><li>각 컴포넌트에 <code>key</code>를 사용하여 명시적인 ID를 부여합니다.</li></ol><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="옵션-1-컴포넌트를-다른-위치에서-렌더링하기">옵션 1: 컴포넌트를 다른 위치에서 렌더링하기<a href="#옵션-1-컴포넌트를-다른-위치에서-렌더링하기" class="hash-link" aria-label="옵션 1: 컴포넌트를 다른 위치에서 렌더링하기에 대한 직접 링크" title="옵션 1: 컴포넌트를 다른 위치에서 렌더링하기에 대한 직접 링크">​</a></h3><p>두 <code>Counter</code>를 독립적으로 사용하려면 두 개의 다른 위치에서 렌더링할 수 있습니다.</p><iframe src="https://codesandbox.io/embed/gallant-nobel-pzdeny?codemirror=1&amp;fontsize=14&amp;hidenavigation=1&amp;view=editor&amp;module=%2FApp.js" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="gallant-nobel-pzdeny" allow="accelerometer; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><ul><li>처음에는 <code>isPlayerA</code>가 <code>true</code>입니다. 따라서 첫 번째 위치에는 <code>Counter</code> 상태가 포함되고 두 번째 위치는 비어 있습니다.</li><li><code>Next player</code> 버튼을 클릭하면 첫 번째 위치는 지워지지만, 이제 두 번째 위치에는 <code>Counter</code>가 포함됩니다.</li></ul><p>초기 상태</p><div style="background-size:cover;background-repeat:no-repeat;position:relative;background-image:url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAICAYAAADA+m62AAAACXBIWXMAAAsTAAALEwEAmpwYAAABKElEQVQYlT3MzUoCURjG8Vd3Jdgygu4i6ALqOtq1aF+L7iCiC6hNi5AsghaBLYIKCQXJj8KoFEnRynH8mNGZOR+ec2aeEMJn94cfD3lMUG84oW/bWeBStX0hMfQYY1KBSXUKgADEiQtJAQ/IY15CSu04E4m+wxBwhaky6TkM7FoM+CFXIeH6ojhyxe/YE42xPx24njj6hzGKrDyFvD8LSh2uJcvZg5WXQnr1rNhZungqLT58tumx1iHSzZtk1K/sRHZhD8PSLnq5dauRpe3MgFLZMt29tej+o00Uvp9sminHwBMIuATG9avZuwXEW9VMrNZ1qGG5M3i8IbmIJn4Ixg30qJ4yAEmAdGGf5gu/rpe1XTlXdvVS2a+3ppvbMt08md5zXGt/Dv8A8tTnUFqvjN8AAAAASUVORK5CYII=&quot;);max-width:24rem;margin-top:20px;margin-bottom:20px"><svg style="width:100%;height:auto;max-width:100%;margin-bottom:-4px" width="640" height="476"></svg><noscript><img style="width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0" src="/doc-archive/assets/ideal-img/preserving-state-diff-position-1.7a666ae.640.png" srcset="/doc-archive/assets/ideal-img/preserving-state-diff-position-1.7a666ae.640.png 640w" alt="리액트 컴포넌트의 트리가 있는 그림입니다. 부모는 값이 &#x27;true&#x27;인 &#x27;isPlayerA&#x27; 상태 방울을 가진 &#x27;Scoreboard&#x27;입니다. 왼쪽으로 정렬된 유일한 자식은 값이 0인 &#x27;count&#x27; 상태 방울을 가진 &#x27;Counter&#x27;입니다. 왼쪽 자식은 모두 노란색으로 강조 표시되어 추가되었음을 나타냅니다." width="640" height="476"></noscript></div><p><code>next</code>를 클릭</p><div style="background-size:cover;background-repeat:no-repeat;position:relative;background-image:url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAICAYAAADA+m62AAAACXBIWXMAAAsTAAALEwEAmpwYAAABMklEQVQYlR3PPUvDQBwH4H99AVcXXRxc6iC6Cn4I1y4ODlZwcnP1E7j4EaToooLgpOCiIi4i2NqifbG2kLYmlya5uyR3udxP6v4sDwEoACCZZueJzuDzOAlEkqrMIBTpbiQVRTKdJmBYADwySXiZRB58d5D77tCqwIGW7n4mh5QKbwLbBeR14qF7xv0RxHjEuf/LQzYAl7wcyZj4eDBDsAlZgB7bfPHLk2vdn+pGr19db/ZbxcpFZS4Z1QjOLRHrPpMBitxrL+UAKVYntE6X4dyXMHwoWVbdMr27edIvR1NWyzdrUlgVHk5i1n09icUYLvOh4wC2c7VDOe8vWBUwqyVy4Rz8Q/Z+LKRGKKCT1CDvXG8TgFmb61WrwrI1aiVnNTLO055hDSfzmx+GNT7N983mHytxAOc6vDL/AAAAAElFTkSuQmCC&quot;);max-width:24rem;margin-top:20px;margin-bottom:20px"><svg style="width:100%;height:auto;max-width:100%;margin-bottom:-4px" width="640" height="476"></svg><noscript><img style="width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0" src="/doc-archive/assets/ideal-img/preserving-state-diff-position-2.999a72f.640.png" srcset="/doc-archive/assets/ideal-img/preserving-state-diff-position-2.999a72f.640.png 640w" alt="리액트 컴포넌트의 트리가 있는 그림입니다. 부모는 값이 &#x27;false&#x27;인 &#x27;isPlayerA&#x27; 상태 방울을 가진 &#x27;Scoreboard&#x27;입니다. 상태 방울이 노란색으로 강조 표시되어 변경되었음을 나타냅니다. 왼쪽 자식은 삭제되었음을 나타내는 노란색 &#x27;펑&#x27; 이미지로 대체되고, 오른쪽에는 추가되었음을 나타내는 노란색으로 강조 표시된 새 자식이 있습니다. 새로운 자식은 &#x27;Counter&#x27;이며, 값이 0인 &#x27;count&#x27; 상태 방울이 포함됩니다." width="640" height="476"></noscript></div><p>다시 <code>next</code> 를 클릭</p><div style="background-size:cover;background-repeat:no-repeat;position:relative;background-image:url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAICAYAAADA+m62AAAACXBIWXMAAAsTAAALEwEAmpwYAAABM0lEQVQYlR2PL0/DQBxAfxQDQQAGQxAEgUIg8RMz6JFMYPgafAMMcgIMyRSCBIdYQibZBmPAQjZYs0DXrrtee+39yd3tfmT4l5f3gObSo4WChImS0tZlXGrCuJTaIFfmChEBET3gnHlK5iBEUTacII1DpLPQiTRCzX5v0PYAdceDjIyX438jK+VpVGRkSkUazRgJkaXTGmof0PgeYNAAFb0CACw9f3R3/NHT/mDYPuxO0r16K1xX1AcdvwHY8cOmI71jDJsVnDRO8Lu+K5LhomtFyuKAjZtrQecawH3dnmpBMU4SFAVFF7cvFwNO0aqzCp0uXpzOt2E+uqtKaTArUHOu0ZHuxQKci/jcGY5OJZH9eVwFO7o/sqT/aejg3ZB+MA+aZ3baAoe45VRadoZXstoG/AHyJ/t02tEcbwAAAABJRU5ErkJggg==&quot;);max-width:24rem;margin-top:20px;margin-bottom:20px"><svg style="width:100%;height:auto;max-width:100%;margin-bottom:-4px" width="640" height="476"></svg><noscript><img style="width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0" src="/doc-archive/assets/ideal-img/preserving-state-diff-position-3.8387753.640.png" srcset="/doc-archive/assets/ideal-img/preserving-state-diff-position-3.8387753.640.png 640w" alt="리액트 컴포넌트의 트리가 있는 그림입니다. 부모는 값이 &#x27;true&#x27;인 &#x27;isPlayerA&#x27; 상태 방울을 가진 &#x27;Scoreboard&#x27;입니다. 상태 방울이 노란색으로 강조 표시되어 변경되었음을 나타냅니다. 왼쪽에는 새 자식이 있으며 노란색으로 강조 표시되어 추가되었음을 나타냅니다. 새로운 자식은 &#x27;Counter&#x27;이며, 값이 0인 &#x27;count&#x27; 상태 방울이 포함됩니다. 오른쪽 자식은 삭제되었음을 나타내는 노란색 &#x27;펑&#x27; 이미지로 대체됩니다." width="640" height="476"></noscript></div><p>각 <code>Counter</code>의 상태는 DOM에서 제거될 때마다 소멸됩니다. 이것이 버튼을 클릭할 때마다 재설정되는 이유입니다.</p><p>이 해법은 같은 위치에 몇 개의 독립적인 컴포넌트만 렌더링되어 있을 때 편리합니다. 이 예시에서는 컴포넌트가 두 개만 있으므로 JSX에서 두 개를 개별적으로 렌더링하는 것이 어렵지 않습니다.</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="옵션-2-키를-사용하여-상태-재설정하기">옵션 2: 키를 사용하여 상태 재설정하기<a href="#옵션-2-키를-사용하여-상태-재설정하기" class="hash-link" aria-label="옵션 2: 키를 사용하여 상태 재설정하기에 대한 직접 링크" title="옵션 2: 키를 사용하여 상태 재설정하기에 대한 직접 링크">​</a></h3><p>컴포넌트의 상태를 재설정하는 보다 일반적인 방법도 있습니다.</p><p><a href="https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key" target="_blank" rel="noopener noreferrer">목록 렌더링</a>에서 <code>키</code>를 본 적이 있을 것입니다. 키는 목록만을 위한 것이 아닙니다! 키를 사용하여 리액트가 모든 컴포넌트를 구별하게 만들 수 있습니다. 기본적으로 리액트는 부모 내의 순서(첫 번째 카운터, 두 번째 카운터)로 컴포넌트를 식별합니다. 그러나 키를 사용하면 이것이 단지 첫 번째 카운터 또는 두 번째 카운터가 아니라, 특정 카운터(테일러의 카운터)라는 것을 리액트에게 알릴 수 있습니다. 이렇게 하면 리액트는 테일러의 카운터가 트리 어디에 나타나든 알 수 있습니다!</p><p>다음 예시에서 두 <code>&lt;Counter /&gt;</code>는 JSX에서 동일한 위치에 나타나더라도 상태를 공유하지 않습니다.</p><iframe src="https://codesandbox.io/embed/little-framework-vlg047?codemirror=1&amp;fontsize=14&amp;hidenavigation=1&amp;view=editor&amp;module=%2FApp.js" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="little-framework-vlg047" allow="accelerometer; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>테일러와 사라 사이를 전환해도 상태가 보존되지 않습니다. 이는 <strong>그들에게 다른 <code>key</code>를 줬기 때문입니다</strong>.</p><pre class="shiki dark-plus" style="background-color:#1E1E1E;color:#D4D4D4"><div class="language-id">jsx</div><div class="code-container"><code><div class="line"><span style="color:#D4D4D4">{</span></div><div class="line"><span style="color:#D4D4D4">  </span><span style="color:#9CDCFE">isPlayerA</span><span style="color:#D4D4D4"> ? (</span></div><div class="line"><span style="color:#D4D4D4">    </span><span style="color:#808080">&lt;</span><span style="color:#4EC9B0">Counter</span><span style="color:#D4D4D4"> </span><span style="color:#9CDCFE">key</span><span style="color:#D4D4D4">=</span><span style="color:#CE9178">&quot;Taylor&quot;</span><span style="color:#D4D4D4"> </span><span style="color:#9CDCFE">person</span><span style="color:#D4D4D4">=</span><span style="color:#CE9178">&quot;Taylor&quot;</span><span style="color:#D4D4D4"> </span><span style="color:#808080">/&gt;</span></div><div class="line"><span style="color:#D4D4D4">  ) : (</span></div><div class="line"><span style="color:#D4D4D4">    </span><span style="color:#808080">&lt;</span><span style="color:#4EC9B0">Counter</span><span style="color:#D4D4D4"> </span><span style="color:#9CDCFE">key</span><span style="color:#D4D4D4">=</span><span style="color:#CE9178">&quot;Sarah&quot;</span><span style="color:#D4D4D4"> </span><span style="color:#9CDCFE">person</span><span style="color:#D4D4D4">=</span><span style="color:#CE9178">&quot;Sarah&quot;</span><span style="color:#D4D4D4"> </span><span style="color:#808080">/&gt;</span></div><div class="line"><span style="color:#D4D4D4">  );</span></div><div class="line"><span style="color:#D4D4D4">}</span></div></code></div><button type="button" aria-label="클립보드에 코드 복사" class="copy-button">복사</button></pre><pre class="shiki dark-plus" style="background-color:#1E1E1E;color:#D4D4D4"><div class="language-id">jsx</div><div class="code-container"><code><div class="line"><span style="color:#D4D4D4">{</span></div><div class="line"><span style="color:#D4D4D4">  </span><span style="color:#9CDCFE">isPlayerA</span><span style="color:#D4D4D4"> ? (</span></div><div class="line"><span style="color:#D4D4D4">    </span><span style="color:#808080">&lt;</span><span style="color:#4EC9B0">Counter</span><span style="color:#D4D4D4"> </span><span style="color:#9CDCFE">key</span><span style="color:#D4D4D4">=</span><span style="color:#CE9178">&quot;Taylor&quot;</span><span style="color:#D4D4D4"> </span><span style="color:#9CDCFE">person</span><span style="color:#D4D4D4">=</span><span style="color:#CE9178">&quot;Taylor&quot;</span><span style="color:#D4D4D4"> </span><span style="color:#808080">/&gt;</span></div><div class="line"><span style="color:#D4D4D4">  ) : (</span></div><div class="line"><span style="color:#D4D4D4">    </span><span style="color:#808080">&lt;</span><span style="color:#4EC9B0">Counter</span><span style="color:#D4D4D4"> </span><span style="color:#9CDCFE">key</span><span style="color:#D4D4D4">=</span><span style="color:#CE9178">&quot;Sarah&quot;</span><span style="color:#D4D4D4"> </span><span style="color:#9CDCFE">person</span><span style="color:#D4D4D4">=</span><span style="color:#CE9178">&quot;Sarah&quot;</span><span style="color:#D4D4D4"> </span><span style="color:#808080">/&gt;</span></div><div class="line"><span style="color:#D4D4D4">  );</span></div><div class="line"><span style="color:#D4D4D4">}</span></div></code></div><button type="button" aria-label="클립보드에 코드 복사" class="copy-button">복사</button></pre><p><code>key</code>를 지정하면 리액트는 부모 내의 순서 대신 <code>key</code> 자체를 위치의 일부로 사용합니다. 따라서 JSX에서 동일한 위치에 렌더링하더라도 리액트는 두 카운터를 다른 카운터로 보고 상태를 공유하지 않습니다. 카운터가 화면에 나타날 때마다 상태가 생성됩니다. 카운터가 제거될 때마다 상태가 파괴됩니다. 두 카운터를 전환하면 상태가 계속해서 재설정됩니다.</p><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>참고</div><div class="admonitionContent_S0QG"><p>키는 전역적으로 고유하지 않습니다. 키는 <strong>부모 내에서</strong>의 위치만 지정합니다.</p></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="키를-사용하여-양식-재설정하기">키를 사용하여 양식 재설정하기<a href="#키를-사용하여-양식-재설정하기" class="hash-link" aria-label="키를 사용하여 양식 재설정하기에 대한 직접 링크" title="키를 사용하여 양식 재설정하기에 대한 직접 링크">​</a></h3><p>키로 상태를 재설정하는 것은 양식을 다룰 때 특히 유용합니다.</p><p>다음 채팅 앱에서 <code>&lt;Chat&gt;</code> 컴포넌트는 텍스트 입력 상태를 갖습니다.</p><iframe src="https://codesandbox.io/embed/silent-hill-e2gbfe?codemirror=1&amp;fontsize=14&amp;hidenavigation=1&amp;view=editor&amp;module=%2FApp.js" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="silent-hill-e2gbfe" allow="accelerometer; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>입력에 무언가를 입력한 다음 <code>Alice</code> 또는 <code>Bob</code>을 눌러 다른 수신자를 선택하세요. <code>&lt;Chat&gt;</code>이 트리에서 같은 위치에 렌더링되므로 입력 상태가 보존되는 것을 볼 수 있습니다.</p><p><strong>많은 앱에서는 이것이 바람직한 동작일 수 있지만 이 채팅 앱에서는 그렇지 않습니다!</strong> 사용자가 실수로 클릭하여 이미 입력한 메시지를 잘못된 사람에게 보내는 것을 원하지 않기 때문입니다. 이를 해결하려면 <code>key</code>를 추가하세요.</p><pre class="shiki dark-plus" style="background-color:#1E1E1E;color:#D4D4D4"><div class="language-id">jsx</div><div class="code-container"><code><div class="line"><span style="color:#808080">&lt;</span><span style="color:#4EC9B0">Chat</span><span style="color:#D4D4D4"> </span><span style="color:#9CDCFE">key</span><span style="color:#D4D4D4">=</span><span style="color:#569CD6">{</span><span style="color:#9CDCFE">to</span><span style="color:#D4D4D4">.</span><span style="color:#9CDCFE">id</span><span style="color:#569CD6">}</span><span style="color:#D4D4D4"> </span><span style="color:#9CDCFE">contact</span><span style="color:#D4D4D4">=</span><span style="color:#569CD6">{</span><span style="color:#9CDCFE">to</span><span style="color:#569CD6">}</span><span style="color:#D4D4D4"> </span><span style="color:#808080">/&gt;</span></div></code></div><button type="button" aria-label="클립보드에 코드 복사" class="copy-button">복사</button></pre><pre class="shiki dark-plus" style="background-color:#1E1E1E;color:#D4D4D4"><div class="language-id">jsx</div><div class="code-container"><code><div class="line"><span style="color:#808080">&lt;</span><span style="color:#4EC9B0">Chat</span><span style="color:#D4D4D4"> </span><span style="color:#9CDCFE">key</span><span style="color:#D4D4D4">=</span><span style="color:#569CD6">{</span><span style="color:#9CDCFE">to</span><span style="color:#D4D4D4">.</span><span style="color:#9CDCFE">id</span><span style="color:#569CD6">}</span><span style="color:#D4D4D4"> </span><span style="color:#9CDCFE">contact</span><span style="color:#D4D4D4">=</span><span style="color:#569CD6">{</span><span style="color:#9CDCFE">to</span><span style="color:#569CD6">}</span><span style="color:#D4D4D4"> </span><span style="color:#808080">/&gt;</span></div></code></div><button type="button" aria-label="클립보드에 코드 복사" class="copy-button">복사</button></pre><p>이렇게 하면 다른 수신자를 선택할 때, 자식 트리의 모든 상태를 포함하여 <code>Chat</code> 컴포넌트가 처음부터 다시 생성됩니다. 리액트는 DOM 요소를 재사용하는 대신 재생성합니다.</p><p>이제 수신자를 전환하면 항상 텍스트 필드가 지워집니다.</p><iframe src="https://codesandbox.io/embed/upbeat-joliot-s2dg76?codemirror=1&amp;fontsize=14&amp;hidenavigation=1&amp;view=editor&amp;module=%2FApp.js" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" title="upbeat-joliot-s2dg76" allow="accelerometer; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>심화</div><div class="admonitionContent_S0QG"><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="제거된-컴포넌트의-상태-보존하기">제거된 컴포넌트의 상태 보존하기<a href="#제거된-컴포넌트의-상태-보존하기" class="hash-link" aria-label="제거된 컴포넌트의 상태 보존하기에 대한 직접 링크" title="제거된 컴포넌트의 상태 보존하기에 대한 직접 링크">​</a></h4><p>실제 채팅 앱에서는 사용자가 이전 수신자를 다시 선택할 때, 입력 상태를 복구하고 싶을 것입니다. 더 이상 표시되지 않는 컴포넌트의 상태를 <strong>살아 있게</strong> 보존하는 방법이 몇 가지 있습니다.</p><ul><li>현재 채팅만 렌더링하는 대신 <strong>모든</strong> 채팅을 렌더링하고, 다른 모든 채팅은 CSS로 숨길 수 있습니다. 채팅은 트리에서 제거되지 않으므로 지역 상태가 보존됩니다. 이 해법은 간단한 UI에 적합합니다. 그러나 숨겨진 트리가 크고 DOM 노드를 많이 포함하는 경우에는 매우 느려질 수 있습니다.</li><li><a href="https://react.dev/learn/sharing-state-between-components" target="_blank" rel="noopener noreferrer">상태 올리기</a>를 이용하여 상위 컴포넌트에서 각 수신자에 대해 보류 중인 메시지를 보존할 수 있습니다. 이렇게 하면 자식 컴포넌트가 제거되어도 괜찮습니다. 중요한 정보를 유지하는 것이 부모 컴포넌트이기 때문입니다. 이것이 가장 일반적인 해법입니다.</li><li>리액트 상태 외에 다른 소스를 사용할 수도 있습니다. 예를 들어 사용자가 실수로 페이지를 닫은 경우에도 메시지 초안이 유지되기를 원할 수 있습니다. 이를 구현하려면 <code>Chat</code> 컴포넌트가 <a href="https://developer.mozilla.org/ko/docs/Web/API/Window/localStorage" target="_blank" rel="noopener noreferrer"><code>localStorage</code></a>에서 읽어서 상태를 초기화하고 이곳에 초안을 저장하게 할 수 있습니다.</li></ul><p>어떤 전략을 선택하든지 앨리스와의 채팅은 밥과의 채팅과 개념적으로 구별되므로, 현재 수신자를 기반으로 <code>&lt;Chat&gt;</code> 트리에 <code>key</code>를 부여하는 것이 타당합니다.</p></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="요약">요약<a href="#요약" class="hash-link" aria-label="요약에 대한 직접 링크" title="요약에 대한 직접 링크">​</a></h2><ul><li>리액트는 동일한 컴포넌트가 동일한 위치에 렌더링되는 한 상태를 유지합니다.</li><li>상태는 JSX 태그에 보관되지 않습니다. 상태는 JSX를 배치한 트리 위치와 관련이 있습니다.</li><li>하위 트리에 다른 키를 제공하여 하위 트리의 상태를 강제로 재설정할 수 있습니다.</li><li>컴포넌트 정의를 중첩하지 마세요. 그렇지 않으면 실수로 상태가 재설정됩니다.</li></ul></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="문서 페이지"><a class="pagination-nav__link pagination-nav__link--prev" href="/doc-archive/docs/react/managing-state/choosing-the-state-structure"><div class="pagination-nav__sublabel">이전</div><div class="pagination-nav__label">상태의 구조 선택하기</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/doc-archive/docs/react/managing-state/extracting-state-logic-into-a-reducer"><div class="pagination-nav__sublabel">다음</div><div class="pagination-nav__label">상태 논리를 변환기로 추출하기</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#ui-트리" class="table-of-contents__link toc-highlight">UI 트리</a></li><li><a href="#상태는-트리의-위치에-연결된다" class="table-of-contents__link toc-highlight">상태는 트리의 위치에 연결된다</a></li><li><a href="#동일한-위치에-있는-동일한-컴포넌트는-상태를-보존한다" class="table-of-contents__link toc-highlight">동일한 위치에 있는 동일한 컴포넌트는 상태를 보존한다</a></li><li><a href="#동일한-위치의-다른-컴포넌트는-상태를-재설정한다" class="table-of-contents__link toc-highlight">동일한 위치의 다른 컴포넌트는 상태를 재설정한다</a></li><li><a href="#동일한-위치에서-상태-재설정하기" class="table-of-contents__link toc-highlight">동일한 위치에서 상태 재설정하기</a><ul><li><a href="#옵션-1-컴포넌트를-다른-위치에서-렌더링하기" class="table-of-contents__link toc-highlight">옵션 1: 컴포넌트를 다른 위치에서 렌더링하기</a></li><li><a href="#옵션-2-키를-사용하여-상태-재설정하기" class="table-of-contents__link toc-highlight">옵션 2: 키를 사용하여 상태 재설정하기</a></li><li><a href="#키를-사용하여-양식-재설정하기" class="table-of-contents__link toc-highlight">키를 사용하여 양식 재설정하기</a></li></ul></li><li><a href="#요약" class="table-of-contents__link toc-highlight">요약</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/javascript/keyboard-keydown-and-keyup">JavaScript</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/typescript">TypeScript</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/react">React</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/nextjs">Next.js</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/electron">Electron</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/jest">Jest</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/cypress">Cypress</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/playwright">Playwright</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/zustand">Zustand</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/tanstack-query">TanStack Query</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/nextauthjs">NextAuth.js</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/vanilla-extract">Vanilla Extract</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/tailwind-css">Tailwind CSS</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/chakra-ui">Chakra UI</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/prisma">Prisma</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/docusaurus">Docusaurus</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/emmet">Emmet</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/yup">Yup</a></li><li class="footer__item"><a class="footer__link-item" href="/doc-archive/docs/regular-expression">정규 표현식</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc-archive/source">출처</a></li><li class="footer__item"><a href="https://docs-glossary.vercel.app/" target="_blank" rel="noopener noreferrer" class="footer__link-item">용어집<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/autroshot/doc-archive" target="_blank" rel="noopener noreferrer" class="footer__link-item">깃허브<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Built with Docusaurus.</div></div></div></footer></div>
<script src="/doc-archive/assets/js/runtime~main.89d74258.js"></script>
<script src="/doc-archive/assets/js/main.b0b08f92.js"></script>
</body>
</html>