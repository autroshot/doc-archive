[{"title":"소개","type":0,"sectionRef":"#","url":"/docs-repository/docs/cypress","content":"","keywords":""},{"title":"특징​","type":1,"pageTitle":"소개","url":"/docs-repository/docs/cypress#특징","content":"시간 여행 - 사이프러스는 테스트가 실행되는 동안 스냅샷을 만듭니다. 명령 로그의 명령에 마우스를 올려놓으면 각 단계에서 어떤 일이 발생했는지 확인할 수 있습니다.강력한 디버깅 - 이제 테스트가 실패하는 이유를 추측할 필요가 없습니다. 개발자 도구와 같은 친숙한 도구에서 직접 디버그할 수 있습니다. 읽을 수 있는 오류와 스택 추적은 디버깅을 번개처럼 빠르게 만듭니다.자동 대기 - 테스트에 대기(wait)나 수면(sleep)을 추가할 필요가 없습니다. 사이프러스는 테스트를 계속 진행하기 전에 자동으로 명령과 단언(assertion)을 기다립니다. 비동기 지옥에서 해방됩니다.스파이, 스텁, 시계 - 함수, 서버 응답, 타이머의 작동을 검증하고 제어합니다. 단위 테스트와 동일한 기능을 바로 사용할 수 있습니다.네트워크 트래픽 제어 - 서버를 사용하지 않고도 쉽게 에지 케이스를 제어, 스텁, 테스트할 수 있습니다. 원하는 대로 네트워크 트래픽을 스텁할 수 있습니다.일관된 결과 - 사이프러스는 셀레늄이나 웹드라이버를 사용하지 않습니다. 플레이크가 없는 빠르고 일관되며 신뢰할 수 있는 테스트를 만날 수 있습니다.스크린숏과 비디오 - 실패 시 자동으로 캡처된 스크린숏이나 CLI에서 실행할 때 전체 테스트 제품군의 비디오를 볼 수 있습니다.브라우저 간 테스트 - 파이어폭스와 및 크롬 제품군 브라우저(엣지와 일렉트론 포함) 내에서 테스트를 실행할 수 있고 지속적 통합 파이프라인에 최적화되었습니다. "},{"title":"설정","type":0,"sectionRef":"#","url":"/docs-repository/docs/cypress/레퍼런스/설정","content":"","keywords":""},{"title":"설정 파일​","type":1,"pageTitle":"설정","url":"/docs-repository/docs/cypress/레퍼런스/설정#설정-파일","content":"사이프러스를 처음 실행하면 사이프러스 설정 파일을 생성하는 마법사가 실행됩니다. 이 파일은 자바스크립트 앱의 cypress.config.js 또는 타입스크립트 앱의 cypress.config.ts입니다. 이 파일은 사이프러스와 관련된 모든 설정을 저장하는 데 사용됩니다. "},{"title":"전역​","type":1,"pageTitle":"설정","url":"/docs-repository/docs/cypress/레퍼런스/설정#전역","content":"옵션\t기본값\t설명watchForFileChanges\ttrue\t사이프러스가 테스트 파일의 변화를 감시하고 테스트를 다시 시작할지 여부 "},{"title":"문제 해결","type":0,"sectionRef":"#","url":"/docs-repository/docs/cypress/문제-해결","content":"문제 해결 크롬 개발자 도구 콘솔에서 리액트 개발자 도구를 다운로드하라는 메시지를 안 보려면 다음 필터를 추가합니다. -/React.DevTools/ 복사 -/React.DevTools/ 복사","keywords":""},{"title":"모범 사례","type":0,"sectionRef":"#","url":"/docs-repository/docs/cypress/레퍼런스/모범-사례","content":"","keywords":""},{"title":"테스트 구성, 로그인, 상태 제어​","type":1,"pageTitle":"모범 사례","url":"/docs-repository/docs/cypress/레퍼런스/모범-사례#테스트-구성-로그인-상태-제어","content":"❌ 안티 패턴 - 페이지를 공유합니다. UI를 사용하여 로그인하고 지름길을 사용하지 않습니다. ✔️ 모범 사례 - 개별적으로 스펙을 테스트하고, 프로그래밍 방식으로 앱에 로그인하고, 앱 상태를 제어합니다. 로그인 레시피에서 몇 가지 예시를 확인하세요. "},{"title":"요소 선택하기​","type":1,"pageTitle":"모범 사례","url":"/docs-repository/docs/cypress/레퍼런스/모범-사례#요소-선택하기","content":"❌ 안티 패턴 - 변경될 수 있는 불안정한 선택자를 사용합니다. ✔️ 모범 사례 - data-* 속성을 사용하여 선택자에 컨텍스트를 제공하고 CSS나 JS의 변경으로부터 독립시킵니다. 작성하는 모든 테스트에는 요소에 대한 선택자가 포함됩니다. 골칫거리를 줄이려면 변화에 탄력적인 선택자를 작성해야 합니다. 종종 다음과 같은 이유로 사용자가 요소를 타겟팅하는 데 문제가 발생합니다. 앱이 변경되는 동적 클래스나 ID를 사용함개발 중 CSS 스타일이나 JS 작동의 변경으로 선택자가 작동하지 않음 운 좋게도 이 두 가지 문제를 모두 피할 수 있는 방법이 있습니다. CSS 속성을 기반으로 요소를 타겟팅하지 않음 (id, class, tag)textContent가 변경될 수 있는 요소를 타겟팅하지 않음요소를 더 쉽게 타겟팅할 수 있도록 data-* 속성을 추가 "},{"title":"작동 원리​","type":1,"pageTitle":"모범 사례","url":"/docs-repository/docs/cypress/레퍼런스/모범-사례#작동-원리","content":"다음의 버튼과 상호작용하고 싶다고 가정해 보겠습니다. html &lt;button id=&quot;main&quot; class=&quot;btn btn-large&quot; name=&quot;submission&quot; role=&quot;button&quot; data-cy=&quot;submit&quot; &gt; Submit &lt;/button&gt; 복사 html &lt;button id=&quot;main&quot; class=&quot;btn btn-large&quot; name=&quot;submission&quot; role=&quot;button&quot; data-cy=&quot;submit&quot; &gt; Submit &lt;/button&gt; 복사 타겟팅할 수 있는 방법은 다음과 같습니다. 선택자\t추천\t설명cy.get('button').click()\t❌ 비추천\t최악. 너무 일반적이고 컨텍스트가 없음 cy.get('.btn.btn-large').click()\t❌ 비추천\t나쁨. 스타일링과 결합됨. 변경될 가능성이 높음 cy.get('#main').click()\t⚠ 가끔\t더 나음. 그러나 여전히 스타일링이나 JS 이벤트 리스너와 연결됨 cy.get('[name=&quot;submission&quot;]').click()\t⚠ 가끔\tHTML 시맨틱이 있는 name 속성과 연결됨 cy.contains('Submit').click()\t✔️ 상황에 따라\t훨씬 나음. 그러나 여전히 변경될 수 있는 텍스트 콘텐츠와 연결됨 cy.get('[data-cy=&quot;submit&quot;]').click()\t✔️ 언제나\t최고. 모든 변경에서 독립됨 위의 요소를 tag, class, id로 타겟팅하는 것은 매우 불안정하고 변경되기 쉽습니다. 요소를 교체하거나, CSS를 리팩터링하고 ID를 갱신하거나, 요소의 스타일에 영향을 주는 클래스를 추가/제거할 수 있기 때문입니다. 대신 요소에 data-cy 속성을 추가하면 테스트 전용 선택자가 생깁니다. data-cy 속성은 CSS 스타일이나 JS 작동 변경의 영향을 받지 않습니다. 즉, 요소의 작동이나 스타일과 연결되지 않습니다. 또한 이 요소가 테스트 코드에서 사용된다는 것을 모든 사람에게 분명히 할 수 있습니다. "},{"title":"텍스트 콘텐츠​","type":1,"pageTitle":"모범 사례","url":"/docs-repository/docs/cypress/레퍼런스/모범-사례#텍스트-콘텐츠","content":"위의 규칙을 읽고 나면 다음과 같은 궁금증이 생길 수 있습니다. 항상 데이터 속성을 사용해야 한다면 cy.contains()는 언제 사용할까요? 경험에 따르면 다음의 질문에 답해보는 것입니다. 요소의 내용이 변경되면 테스트가 실패하기를 원하나요? 예 - cy.contains()를 사용아니오 - 데이터 속성을 사용 위의 버튼 예시를 다시 살펴보겠습니다. html &lt;button id=&quot;main&quot; class=&quot;btn btn-large&quot; data-cy=&quot;submit&quot;&gt;Submit&lt;/button&gt; 복사 html &lt;button id=&quot;main&quot; class=&quot;btn btn-large&quot; data-cy=&quot;submit&quot;&gt;Submit&lt;/button&gt; 복사 문제는 테스트에서 Submit의 텍스트 콘텐츠가 얼마나 중요한가입니다. 텍스트가 Submit에서 Save로 바뀌면 테스트가 실패하기를 원하나요? Submit이라는 단어가 중요하며 변경되면 안 되면 cy.contains()를 이용해 요소를 타겟팅합니다. 텍스트가 변경되도 된다면 cy.get()과 데이터 속성을 사용합니다. 텍스트를 Save로 변경해도 테스트가 실패하지 않습니다. "},{"title":"after나 afterEach 훅 사용하기​","type":1,"pageTitle":"모범 사례","url":"/docs-repository/docs/cypress/레퍼런스/모범-사례#after나-aftereach-훅-사용하기","content":"❌ 안티 패턴 - 상태를 정리하기 위해 after나 afterEach 훅을 사용합니다. ✔️ 모범 사례 - 테스트 실행 before에 상태를 정리합니다. 많은 개발자가 테스트에서 생성된 상태를 정리하기 위해 after나 afterEach 훅에 코드를 추가하곤 합니다. 예시: js describe('logged in user', () =&gt; { beforeEach(() =&gt; { cy.login() }) afterEach(() =&gt; { cy.logout() }) it('tests', ...) it('more', ...) it('things', ...) }) 복사 js describe('logged in user', () =&gt; { beforeEach(() =&gt; { cy.login() }) afterEach(() =&gt; { cy.logout() }) it('tests', ...) it('more', ...) it('things', ...) }) 복사 "},{"title":"남아 있는 상태는 좋은 친구​","type":1,"pageTitle":"모범 사례","url":"/docs-repository/docs/cypress/레퍼런스/모범-사례#남아-있는-상태는-좋은-친구","content":"사이프러스의 가장 좋은 부분 중 하나는 디버깅 가능성입니다. 다른 테스트 도구와 달리 테스트가 끝나면 테스트가 완료된 정확한 지점에 작업 앱이 남습니다. 테스트가 완료된 상태에서 앱을 사용할 수 있는 좋은 기회입니다. 이를 통해 단계별로 앱을 구동하는 부분 테스트를 작성하여 테스트와 앱 코드를 동시에 작성할 수 있습니다. 이 유스 케이스를 지원하기 위해 사이프러스를 만들어졌습니다. 실제로 사이프러스는 테스트가 종료될 때 자체 내부 상태를 정리하지 않습니다. 테스트가 끝날 때 상태가 남아 있기를 원합니다. 스텁, 스파이, 심지어 경로와 같은 것은 테스트가 끝날 때 제거되지 않습니다. 이는 앱이 사이프러스 명령을 실행하는 동안이나 테스트가 끝나고 수동으로 작업할 때 앱이 동일하게 작동함을 의미합니다. 각 테스트 후에 앱의 상태를 제거하면 해당 상태에서 앱을 사용할 수 있는 능력을 잃게 됩니다. 마지막에 로그아웃하면 테스트가 끝날 때 항상 동일한 로그인 페이지가 남습니다. 앱을 디버그하거나 부분 테스트를 작성하려면 항상 사용자 정의 cy.logout() 명령을 주석으로 남겨야 합니다. "},{"title":"장점은 없고 단점뿐​","type":1,"pageTitle":"모범 사례","url":"/docs-repository/docs/cypress/레퍼런스/모범-사례#장점은-없고-단점뿐","content":"일단 어떤 이유로든 앱이 실행되기 위해 after나 afterEach 코드가 절실히 필요하다고 가정해 보겠습니다. 해당 코드가 실행되지 않으면 모든 것이 손실되는 상황입니다. 하지만 이 경우에도 after나 afterEach가 필요하지 않습니다. 다른 예로 데이터베이스를 재설정해야 하는 패턴을 살펴보겠습니다. 각 테스트 후에 데이터베이스에 레코드가 없는 상태로 만들어서 다음 테스트가 실행될 때 깨끗한 상태로 실행되게 하고 싶습니다. 다음과 같은 테스트 코드를 작성할 것입니다. js afterEach(() =&gt; { cy.resetDb(); }); 복사 js afterEach(() =&gt; { cy.resetDb(); }); 복사 문제는 이 코드가 실행된다는 보장이 없다는 것입니다. 다음 테스트 전에 실행해야 하기 때문에 이 명령을 작성했다고 가정하면, 이 명령을 작성하기에 가장 나쁜 위치는 after나 afterEach 훅입니다. 테스트 중간에 사이프러스를 새로고침하면 데이터베이스에 부분적인 상태가 생성되고 사용자 정의 cy.resetDb() 함수가 호출되지 않기 때문입니다. 사이프러스를 새로고침할 때 상태 재설정이 되지 않았기 때문에 다음 테스트는 즉시 실패하게 됩니다. "},{"title":"각 테스트 전에 상태를 재설정​","type":1,"pageTitle":"모범 사례","url":"/docs-repository/docs/cypress/레퍼런스/모범-사례#각-테스트-전에-상태를-재설정","content":"여기서 가장 간단한 해결책은 재설정 코드를 테스트 실행 전으로 옮기는 것입니다. before나 beforeEach 훅에 넣은 코드는 항상 테스트 전에 실행됩니다. 기존 코드 중간에 사이프러스를 새로고침한 경우에도 동일합니다. 이곳은 또한 모카의 루트 수준 훅을 사용하기에 좋은 위치입니다. 지원 파일은 테스트 파일이 평가되기 전에 로드되기 때문에 이 설정을 넣기에 좋은 위치는 지원 파일입니다. 루트에 추가한 훅은 항상 모든 스위트에서 실행됩니다. cypress/support/e2e.js 또는 cypress/support/component.js js beforeEach(() =&gt; { // 이 코드는 모든 파일의 모든 테스트 전에 실행됩니다. cy.resetDb(); }); 복사 cypress/support/e2e.js 또는 cypress/support/component.js js beforeEach(() =&gt; { // 이 코드는 모든 파일의 모든 테스트 전에 실행됩니다. cy.resetDb(); }); 복사 "},{"title":"상태 재설정이 필요한가요?​","type":1,"pageTitle":"모범 사례","url":"/docs-repository/docs/cypress/레퍼런스/모범-사례#상태-재설정이-필요한가요","content":"사이프러스는 이미 각 테스트 전에 상태를 지워 자동으로 테스트 격리를 적용합니다. 사이프러스에서 이미 정리한 상태를 정리하려는 것이 아닌지 확인할 필요가 있습니다. 정리하려는 상태가 서버에 있는 경우에는 반드시 해당 상태를 정리해야 합니다. 그러나 상태가 현재 테스트 중인 앱과 관련된 경우에는 정리하지 않아도 됩니다. 상태를 정리해야 하는 유일한 경우는 한 테스트가 실행하는 작업이 다른 테스트 다운스트림에 영향을 미치는 경우입니다. 이러한 경우에만 상태 정리가 필요합니다. "},{"title":"시작하기","type":0,"sectionRef":"#","url":"/docs-repository/docs/cypress/시작하기","content":"시작하기 설치: shell npm install cypress --save-dev 복사 shell npm install cypress --save-dev 복사 사이프러스 실행: shell npx cypress open -b 복사 shell npx cypress open -b 복사 테스트 파일 최상단에 다음 코드가 있어야 합니다. tsx /// &lt;reference types=&quot;cypress&quot; /&gt; 복사 tsx /// &lt;reference types=&quot;cypress&quot; /&gt; 복사 프로덕션이 아닌 로컬 개발 서버에서 테스트를 해야 합니다. cypress.config 파일에서 baseUrl을 설정할 수 있습니다. tsx import { defineConfig } from 'cypress'; export default defineConfig({ e2e: { baseUrl: 'http://localhost:8080', }, }); 복사 tsx import { defineConfig } from 'cypress'; export default defineConfig({ e2e: { baseUrl: 'http://localhost:8080', }, }); 복사","keywords":""},{"title":"단언","type":0,"sectionRef":"#","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/단언","content":"","keywords":""},{"title":"영어로 단언하기​","type":1,"pageTitle":"단언","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/단언#영어로-단언하기","content":"단언을 영어로 설명하는 방법을 살펴보겠습니다. After clicking on this &lt;button&gt;, I expect its class to eventually be active. 사이프러스에서 이를 표현하면 다음과 같습니다. js cy.get('button').click().should('have.class', 'active'); 복사 js cy.get('button').click().should('have.class', 'active'); 복사 위의 테스트는 .active 클래스가 버튼에 비동기적으로, 혹은 불확실한 시간이 지난 후에 적용되어도 성공할 것입니다. javascript $('button').on('click', (e) =&gt; { setTimeout(() =&gt; { $(e.target).addClass('active'); }, 2000); }); 복사 javascript $('button').on('click', (e) =&gt; { setTimeout(() =&gt; { $(e.target).addClass('active'); }, 2000); }); 복사 다음은 다른 예시입니다. After making an HTTP request to my server, I expect the response body to equal {name: 'Jane'} 이를 단언으로 표현하면 다음과 같습니다. js cy.request('/users/1').its('body').should('deep.eq', { name: 'Jane' }); 복사 js cy.request('/users/1').its('body').should('deep.eq', { name: 'Jane' }); 복사 "},{"title":"사용 시기​","type":1,"pageTitle":"단언","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/단언#사용-시기","content":"사이프러스가 제공하는 수많은 단언에도 불구하고 때로는 테스트에 단언이 없어도 됩니다. 예시: js cy.visit('/home'); cy.get('.main-menu').contains('New Project').click(); cy.get('.title').type('My Awesome Project'); cy.get('form').submit(); 복사 js cy.visit('/home'); cy.get('.main-menu').contains('New Project').click(); cy.get('.title').type('My Awesome Project'); cy.get('form').submit(); 복사 명시적 단언이 하나도 없음에도 이 테스트에는 실패할 수 있는 방법은 수십 가지가 됩니다. 핵심 개념 사이프러스를 사용하면 유용한 테스트를 위해 단언을 사용하지 않아도 됩니다. 단언이 없더라도 몇 줄의 사이프러스로 수천 줄의 코드가 클라이언트와 서버에서 제대로 작동하는지 확인할 수 있습니다. 이는 많은 명령에 높은 수준의 보증을 제공하는 기본 단언이 내장되어 있기 때문입니다. "},{"title":"기본 단언​","type":1,"pageTitle":"단언","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/단언#기본-단언","content":"많은 명령에는 기본적으로 단언이나 요구 사항이 내장되어 있습니다. cy.visit() - 페이지가 상태 코드 200과 text/html 콘텐츠를 보낼 것을 예상cy.request() - 원격 서버가 존재하고 응답을 제공할 것으로 예상cy.contains() - 콘텐츠가 있는 요소가 결국 DOM에 존재할 것으로 예상cy.get() - 요소가 결국 DOM에 존재할 것으로 예상.find() - 요소가 결국 DOM에 존재할 것으로 예상.type() - 요소가 결국 타이핑이 가능한 상태가 될 것으로 예상.click() - 요소가 결국 액션이 가능한 상태가 될 것으로 예상.its() - 결국 현재 주어에 대한 프로퍼티를 찾을 것으로 예상 cy.request() 같은 특정 명령에는 재시도 없이 즉시 실패하도록 하는 요구 사항이 있습니다. DOM 기반 명령은 실패하기 전에 자동으로 재시도하고 해당 요소가 존재하기를 기다립니다. 액션 명령은 실패하기 전에 해당 요소가 액션이 가능한 상태에 도달할 때까지 자동으로 기다립니다. 핵심 개념 모든 DOM 기반 명령은 해당 요소가 DOM에 존재하기를 자동으로 기다립니다. DOM 기반 명령 다음에는 .should('exist')를 작성할 필요가 없습니다. 대부분의 명령에서는 기본 단언을 우회하기 위한 {force: true} 옵션을 제공합니다. "},{"title":"예시 #1: 존재와 액션 가능성​","type":1,"pageTitle":"단언","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/단언#예시-1-존재와-액션-가능성","content":"js cy // 계속하기 전에 이 버튼이 DOM에 존재해야 한다는 // 기본 단언이 포함되어 있습니다. .get('button') // 클릭을 실행하기 전에 이 단추는 액션이 가능해야 합니다. // 'disabled', 'covered', 'hidden'이 아니어야 합니다. .click(); 복사 js cy // 계속하기 전에 이 버튼이 DOM에 존재해야 한다는 // 기본 단언이 포함되어 있습니다. .get('button') // 클릭을 실행하기 전에 이 단추는 액션이 가능해야 합니다. // 'disabled', 'covered', 'hidden'이 아니어야 합니다. .click(); 복사 사이프러스는 자동으로 요소가 기본 단언을 통과할 때까지 기다립니다. 명시적 단언과 마찬가지로 이러한 모든 단언은 동일한 타임아웃 값을 공유합니다. "},{"title":"예시 #2: 기본 단언 반전시키기​","type":1,"pageTitle":"단언","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/단언#예시-2-기본-단언-반전시키기","content":"요소가 존재하지 않을 때까지 기다리고 싶을 때가 종종 있습니다. 다음과 같은 단언을 추가하면 요소가 존재하기를 기다리는 규칙이 반전됩니다. js // 이제 사이프러스는 버튼이 클릭 후에 // DOM에 존재하지 않을 때까지 기다립니다. cy.get('button.close').click().should('not.exist'); // 그리고 #modal이 DOM에 존재하지 않을 때까지 기다립니다. cy.get('#modal').should('not.exist'); 복사 js // 이제 사이프러스는 버튼이 클릭 후에 // DOM에 존재하지 않을 때까지 기다립니다. cy.get('button.close').click().should('not.exist'); // 그리고 #modal이 DOM에 존재하지 않을 때까지 기다립니다. cy.get('#modal').should('not.exist'); 복사 핵심 개념 DOM 명령에 .should('not.exist')를 추가하면 사이프러스는 기본 단언을 뒤집고 요소가 존재하지 않을 때까지 자동으로 기다립니다. "},{"title":"예시 #3: 기타 기본 단언​","type":1,"pageTitle":"단언","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/단언#예시-3-기타-기본-단언","content":"기타 명령에는 DOM과 관련되지 않은 기본 단언이 있습니다. 예를 들어 .its()는 해당 프로퍼티가 객체에 존재할 때까지 기다립니다. js // 빈 객체를 생성합니다. const obj = {}; // 1초 후에 foo 프로퍼티를 설정합니다. setTimeout(() =&gt; { obj.foo = 'bar'; }, 1000); // '.its()'는 객체에 foo 프로퍼티가 존재할 때까지 기다립니다. cy.wrap(obj).its('foo'); 복사 js // 빈 객체를 생성합니다. const obj = {}; // 1초 후에 foo 프로퍼티를 설정합니다. setTimeout(() =&gt; { obj.foo = 'bar'; }, 1000); // '.its()'는 객체에 foo 프로퍼티가 존재할 때까지 기다립니다. cy.wrap(obj).its('foo'); 복사 "},{"title":"단언 목록​","type":1,"pageTitle":"단언","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/단언#단언-목록","content":"사이프러스는 내장 단언을 위해 차이, 차이 제이쿼리, 시논 차이을 제공합니다. 단언 참조 목록에서 전체 목록을 확인하세요. 차이 플러그인 같은 자신만의 단언도 사이프러스에서 사용 가능합니다. "},{"title":"단언 작성하기​","type":1,"pageTitle":"단언","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/단언#단언-작성하기","content":"사이프러스에서 단언을 작성하는 방법은 두 가지입니다. 암시적 주어 - .should()나 .and()를 사용명시적 주어 - expect를 사용 "},{"title":"암시적 주어​","type":1,"pageTitle":"단언","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/단언#암시적-주어","content":"사이프러스에서 단언을 만드는 기본적인 방법은 .should()나 .and() 명령을 사용하는 것입니다. 이는 일반적인 사이프러스 명령으로, 명령 체인에서 현재 생성된 주어에 적용됩니다. js // 이곳의 암시적 주어는 첫 번째 &lt;tr&gt;입니다. // 이 단언은 &lt;tr&gt;이 '.active' 클래스를 가져야 한다고 말합니다. cy.get('tbody tr:first').should('have.class', 'active'); 복사 js // 이곳의 암시적 주어는 첫 번째 &lt;tr&gt;입니다. // 이 단언은 &lt;tr&gt;이 '.active' 클래스를 가져야 한다고 말합니다. cy.get('tbody tr:first').should('have.class', 'active'); 복사 복수의 단언을 .and()와 함께 사용해 체이닝할 수 있습니다. .and()는 .should()와 동일한 기능을 하며 가독성을 높이는 역할을 합니다. js cy.get('#header a') .should('have.class', 'active') .and('have.attr', 'href', '/users'); 복사 js cy.get('#header a') .should('have.class', 'active') .and('have.attr', 'href', '/users'); 복사 .should('have.class')가 주어를 바꾸지 않으므로 .and('have.attr')는 동일한 요소에 대해 실행됩니다. 이것은 하나의 주어에 대해 여러 가지를 빠르게 단언할 때 편리합니다. 이 단언을 명시적 형식으로 작성하면 다음과 같습니다. js cy.get('tbody tr:first').should(($tr) =&gt; { expect($tr).to.have.class('active'); expect($tr).to.have.attr('href', '/users'); }); 복사 js cy.get('tbody tr:first').should(($tr) =&gt; { expect($tr).to.have.class('active'); expect($tr).to.have.attr('href', '/users'); }); 복사 이 경우에는 암시적 형식이 훨씬 짧은 것을 알 수 있습니다. "},{"title":"명시적 주어​","type":1,"pageTitle":"단언","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/단언#명시적-주어","content":"expect를 사용하면 특정 주어를 전달하고 이에 대한 단언을 할 수 있습니다. 단위 테스트에서 많이 보는 단언입니다. js // 이곳의 명시적 주어는 'boolean: true'입니다. expect(true).to.be.true; 복사 js // 이곳의 명시적 주어는 'boolean: true'입니다. expect(true).to.be.true; 복사 명시적 주어는 다음의 경우에 유용합니다. 단언을 만들기 이전에 사용자 정의 논리를 수행동일한 주어에 대해 복수의 단언을 작성 .should() 명령을 사용하면 생성된 주어를 첫 번째 인수로 사용하는 콜백 함수를 건네줄 수 있습니다. 이는 사이프러스가 콜백 함수 내부의 모든 것이 통과할 때까지 자동으로 기다리며 재시도한다는 점만 제외하면 .then()과 유사하게 작동합니다. "},{"title":"복잡한 단언​","type":1,"pageTitle":"단언","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/단언#복잡한-단언","content":"다음 예시는 여러 요소에 대해 단언을 작성하는 유스 케이스입니다. .should() 콜백 함수를 사용하면 부모의 여러 자식 요소에 대해 쿼리하고 무언가를 단언할 수 있습니다. 이렇게 하면 일반적인 사이프러스 DOM 명령을 사용하여 개별적으로 쿼리할 필요 없이, 하위 항목의 상태가 예상과 일치하도록 사이프러스를 차단하고 보호할 수 있습니다. js cy.get('p').should(($p) =&gt; { // 주어를 조작해 DOM 요소에서 모든 p의 텍스트 배열로 변환합니다. let texts = $p.map((i, el) =&gt; { return Cypress.$(el).text(); }); // 제이쿼리 맵은 제이쿼리 객체를 반환하며 // '.get()'은 이 객체를 배열로 변환합니다. texts = texts.get(); // 배열의 길이는 3이고 expect(texts).to.have.length(3); // 특정 콘텐츠를 가져야 합니다. expect(texts).to.deep.eq([ 'Some text from first p', 'More text from second p', 'And even more text from third p', ]); }); 복사 js cy.get('p').should(($p) =&gt; { // 주어를 조작해 DOM 요소에서 모든 p의 텍스트 배열로 변환합니다. let texts = $p.map((i, el) =&gt; { return Cypress.$(el).text(); }); // 제이쿼리 맵은 제이쿼리 객체를 반환하며 // '.get()'은 이 객체를 배열로 변환합니다. texts = texts.get(); // 배열의 길이는 3이고 expect(texts).to.have.length(3); // 특정 콘텐츠를 가져야 합니다. expect(texts).to.deep.eq([ 'Some text from first p', 'More text from second p', 'And even more text from third p', ]); }); 복사 위험 .should()와 콜백 함수를 사용할 때는 전체 함수가 부작용 없이 여러 번 실행될 수 있는지 확인해야 합니다. 사이프러스는 재시도 논리를 해당 함수에 적용합니다. 만약 실패하면 타임아웃이 끝날 때까지 단언을 재실행합니다. 이는 코드가 재시도에 안전해야 한다는 것을 의미합니다. 이에 대한 기술적 용어는 코드의 멱등성입니다. "},{"title":"명령 체인","type":0,"sectionRef":"#","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/명령-체인","content":"","keywords":""},{"title":"요소와 상호 작용하기​","type":1,"pageTitle":"명령 체인","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/명령-체인#요소와-상호-작용하기","content":"사이프러스에서 cy.get() 또는 cy.contains() 명령과 .click() 또는 .type() 명령을 사용해 페이지의 요소를 클릭하거나 입력할 수 있습니다. 이는 체이닝의 좋은 예입니다. 예시: js cy.get('textarea.post-body').type('This is an excellent post.'); 복사 js cy.get('textarea.post-body').type('This is an excellent post.'); 복사 cy.get()에 .type()을 체이닝해서 cy.get() 명령에서 생성된 주어(DOM 요소)에 타이핑할 것을 지시하고 있다. 다음은 사이프러스에서 제공하는 앱과의 상호 작용을 위한 작동 명령입니다. .blur() - 포커스된 DOM 요소가 포커스를 잃게 만듬.focus() - DOM 요소가 포커스를 얻음.clear() - input이나 textarea의 값을 지움.check() - 체크박스나 라디오를 체크.uncheck() - 체크박스의 체크를 해제.select() - &lt;select&gt;의 &lt;option&gt;을 선택.dblclick() - DOM 요소를 더블 클릭.rightclick() - DOM 요소를 오른쪽 클릭 이런 명령은 작동을 수행하기 전에 요소의 몇 가지 상태를 확인합니다. 예를 들어 .click() 명령에서 사이프러스는 (실제 사용자가 하는 것처럼) 요소가 상호 작용이 가능한지 확인합니다. 다음과 같이 요소가 작동 가능 상태에 도달할 때까지 자동으로 기다립니다. hidden이 아님covered가 아님 (상위 요소에게 덮여 있지 않음)disabled가 아님애니메이션 중이 아님 또한 테스트에서 앱과 상호 작용할 때 플레이크(flake)를 방지하는 데 도움이 됩니다. 일반적으로 force 옵션을 사용하여 이 작동을 재정의할 수 있습니다. 핵심 개념 사이프러스는 요소와 상호 작용할 때 간단하지만 강력한 알고리즘을 제공합니다. "},{"title":"요소에 단언하기​","type":1,"pageTitle":"명령 체인","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/명령-체인#요소에-단언하기","content":"단언(assertion)을 사용하면 요소의 표시 여부나 특정 속성, CSS 클래스, 상태에 있는지 확인할 수 있습니다. 단언은 앱이 어떤 상태에 있길 원하는지를 설명하는 명령입니다. 사이프러스는 요소가 해당 상태에 도달할 때까지 자동으로 기다리다가 단언을 통과하지 못하면 테스트에 실패합니다. 예시: js cy.get(':checkbox').should('be.disabled'); cy.get('form').should('have.class', 'form-horizontal'); cy.get('input').should('not.have.value', 'US'); 복사 js cy.get(':checkbox').should('be.disabled'); cy.get('form').should('have.class', 'form-horizontal'); cy.get('input').should('not.have.value', 'US'); 복사 사이프러스는 각 단언을 통과할 때까지 자동으로 기다립니다. 요소가 원하는 상태에 도달하는 정확한 순간을 알 필요가 없습니다. "},{"title":"주어 관리하기​","type":1,"pageTitle":"명령 체인","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/명령-체인#주어-관리하기","content":"새로운 사이프러스 체인은 항상 cy.[command]로 시작합니다. command에 따라 이후에 체인으로 올 수 있는 명령이 결정됩니다. cy.clearCookies() 같은 메서드는 null을 생성하므로 체이닝이 불가능합니다. cy.get()이나 cy.contains() 같은 메서드는 DOM 요소를 생성하므로 .click()이나 cy.contains()를 체인으로 연결할 수 있습니다. 일부 명령은 특정한 명령 뒤에서만 체이닝이 가능합니다. cy.clearCookies() - cy의 뒤만 가능하며 다른 주어 뒤에 올 수 없음 .type() - DOM 요소와 같이 특정한 주어를 생성하는 명령의 뒤에 올 수 있음 cy.contains() - 주어를 생성하는 명령이나 cy의 뒤 모두 가능 일부 명령이 생성하는 것은 다음과 같습니다. cy.clearCookie() - null을 생성하며 이 명령 뒤에서는 체이닝이 불가능 .click() - 이전 주어와 동일한 주어 .wait() - 해당 명령에 적합한 새로운 주어 예시: js cy.clearCookies(); // null이 생성되어 체이닝이 불가능합니다. cy.get('.main-container') // 일치하는 DOM 요소의 배열을 생성합니다. .contains('Headlines') // 해당 콘텐츠를 가진 첫 번째 DOM 요소를 생성합니다. .click(); // 이전 명령과 동일한 DOM 요소를 생성합니다. 복사 js cy.clearCookies(); // null이 생성되어 체이닝이 불가능합니다. cy.get('.main-container') // 일치하는 DOM 요소의 배열을 생성합니다. .contains('Headlines') // 해당 콘텐츠를 가진 첫 번째 DOM 요소를 생성합니다. .click(); // 이전 명령과 동일한 DOM 요소를 생성합니다. 복사 핵심 개념 사이프러스 명령은 주어를 반환하지(return) 않고 생성합니다(yield). 사이프러스 명령은 비동기적이며 나중에 실행할 수 있도록 대기열에 추가됩니다. 테스트에서 주어는 하나의 명령에서 다음 명령으로 넘어가며, 모든 것이 잘 작동하는지 확인하기 위해 각 명령 사이에서 수많은 사이프러스 코드가 실행됩니다. 참고 요소를 참조하고 싶을 때는 별칭이라는 기능을 이용할 수 있습니다. 별칭을 이용해 요소 참조를 저장했다가 나중에 사용할 수 있습니다. "},{"title":".then()을 사용해 주어 다루기​","type":1,"pageTitle":"명령 체인","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/명령-체인#then을-사용해-주어-다루기","content":"주어를 직접 다루고 싶다면 명령 체인에 .then()을 추가하면 됩니다. 이전 명령이 이행되면, 생성된 주어를 첫 번째 인수로 갖는 콜백 함수가 호출됩니다. .then() 이후에도 명령 체이닝을 계속하고 싶다면, 해당 명령에서 생성하고 싶은 주어를 반환하면 됩니다. null이나 undefined 이외의 값을 반환해야 합니다. 예시: js cy // id가 some-link인 요소를 찾습니다. .get('#some-link') .then(($myElement) =&gt; { // ...주어를 다루는 코드... // href 프로퍼티를 얻습니다. const href = $myElement.prop('href'); // '#'와 그 이후의 글자를 모두 삭제합니다. return href.replace(/(#.*)/, ''); }) .then((href) =&gt; { // 이제 href가 새로운 주어이며 원하는 작업을 수행할 수 있습니다. }); 복사 js cy // id가 some-link인 요소를 찾습니다. .get('#some-link') .then(($myElement) =&gt; { // ...주어를 다루는 코드... // href 프로퍼티를 얻습니다. const href = $myElement.prop('href'); // '#'와 그 이후의 글자를 모두 삭제합니다. return href.replace(/(#.*)/, ''); }) .then((href) =&gt; { // 이제 href가 새로운 주어이며 원하는 작업을 수행할 수 있습니다. }); 복사 "},{"title":"별칭을 사용해 이전 주어 참조하기​","type":1,"pageTitle":"명령 체인","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/명령-체인#별칭을-사용해-이전-주어-참조하기","content":"사이프러스에는 과거의 주어를 빠르게 참조할 수 있는 별칭이라는 기능이 있습니다. 예시: js cy.get('.my-selector') .as('myElement') // 별칭을 설정합니다. .click(); /* 많은 작업 */ cy.get('@myElement') // 이전과 동일한 DOM을 쿼리합니다. .click(); 복사 js cy.get('.my-selector') .as('myElement') // 별칭을 설정합니다. .click(); /* 많은 작업 */ cy.get('@myElement') // 이전과 동일한 DOM을 쿼리합니다. .click(); 복사 요소가 아직 DOM에 있을 때 이 기능을 사용하면 DOM 쿼리를 재사용해서 테스트가 더 빨라집니다. DOM에서 일치하는 요소를 찾지 못하면 쿼리를 자동으로 재시도합니다. 이 기능은 재렌더링을 많이 하는 프론트엔드 프레임워크를 다룰 때 특히 유용합니다. "},{"title":"비동기적인 명령​","type":1,"pageTitle":"명령 체인","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/명령-체인#비동기적인-명령","content":"사이프러스 명령은 호출되는 순간에는 아무 일도 하지 않고 나중에 실행되도록 대기열에 추가합니다. js it('hides the thing when it is clicked', () =&gt; { cy.visit('/my/resource/path'); // 아직 아무 일도 일어나지 않습니다. cy.get('.hides-when-clicked') // 아직 아무 일도 일어나지 않습니다. .should('be.visible') // 아직 아무 일도 일어나지 않습니다. .click() // 아직 아무 일도 일어나지 않습니다. .should('not.be.visible'); // 아직 아무 일도 일어나지 않습니다. }); // 테스트 함수가 실행을 마쳤습니다... // 모든 명령이 대기열에 들어갔고 이제 사이프러스는 // 순서대로 명령을 실행하기 시작합니다! 복사 js it('hides the thing when it is clicked', () =&gt; { cy.visit('/my/resource/path'); // 아직 아무 일도 일어나지 않습니다. cy.get('.hides-when-clicked') // 아직 아무 일도 일어나지 않습니다. .should('be.visible') // 아직 아무 일도 일어나지 않습니다. .click() // 아직 아무 일도 일어나지 않습니다. .should('not.be.visible'); // 아직 아무 일도 일어나지 않습니다. }); // 테스트 함수가 실행을 마쳤습니다... // 모든 명령이 대기열에 들어갔고 이제 사이프러스는 // 순서대로 명령을 실행하기 시작합니다! 복사 "},{"title":"비동기 코드와 동기 코드 섞기​","type":1,"pageTitle":"명령 체인","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/명령-체인#비동기-코드와-동기-코드-섞기","content":"동기 코드는 자신의 위에 있는 사이프러스 명령이 실행될 때까지 기다리지 않고 즉시 실행됩니다. ❌ 잘못된 사용법 다음 예시에서는 cy.visit()이 실행되기 전에 el이 즉시 평가되므로 항상 빈 배열로 평가됩니다. js it('does not work as we expect', () =&gt; { cy.visit('/my/resource/path'); // 아직 아무 일도 일어나지 않습니다. cy.get('.awesome-selector') // 아직 아무 일도 일어나지 않습니다. .click(); // 아직 아무 일도 일어나지 않습니다. // Cypress.$는 동기적이므로 즉시 평가됩니다. let el = Cypress.$('.new-el'); // 즉시 []로 평가됩니다. if (el.length) { // 즉시 0으로 평가됩니다. cy.get('.another-selector'); } else { // 코드가 실행될 때는 el.length가 0이므로 // 이 코드가 항상 실행됩니다. cy.get('.optional-selector'); } }); 복사 js it('does not work as we expect', () =&gt; { cy.visit('/my/resource/path'); // 아직 아무 일도 일어나지 않습니다. cy.get('.awesome-selector') // 아직 아무 일도 일어나지 않습니다. .click(); // 아직 아무 일도 일어나지 않습니다. // Cypress.$는 동기적이므로 즉시 평가됩니다. let el = Cypress.$('.new-el'); // 즉시 []로 평가됩니다. if (el.length) { // 즉시 0으로 평가됩니다. cy.get('.another-selector'); } else { // 코드가 실행될 때는 el.length가 0이므로 // 이 코드가 항상 실행됩니다. cy.get('.optional-selector'); } }); 복사 ✔️ 올바른 사용법 js it('does not work as we expect', () =&gt; { cy.visit('/my/resource/path'); // 아직 아무 일도 일어나지 않습니다. cy.get('.awesome-selector') // 아직 아무 일도 일어나지 않습니다. .click() // 아직 아무 일도 일어나지 않습니다. .then(() =&gt; { // '.then()' 내부에 코드를 배치하는 것은 // 해당 코드가 사이프러스의 '실행' 명령 이후에 // 실행되다는 것을 의미합니다. let el = 사이프러스.$('.new-el'); // '.then()' 이후에 평가됩니다. if (el.length) { cy.get('.another-selector'); } else { cy.get('.optional-selector'); } }); }); 복사 js it('does not work as we expect', () =&gt; { cy.visit('/my/resource/path'); // 아직 아무 일도 일어나지 않습니다. cy.get('.awesome-selector') // 아직 아무 일도 일어나지 않습니다. .click() // 아직 아무 일도 일어나지 않습니다. .then(() =&gt; { // '.then()' 내부에 코드를 배치하는 것은 // 해당 코드가 사이프러스의 '실행' 명령 이후에 // 실행되다는 것을 의미합니다. let el = 사이프러스.$('.new-el'); // '.then()' 이후에 평가됩니다. if (el.length) { cy.get('.another-selector'); } else { cy.get('.optional-selector'); } }); }); 복사 ❌ 잘못된 사용법 다음 예시에서는 cy.visit()이 실행되기 전에 username 값이 즉시 평가되므로 항상 undefined로 평가됩니다. js it('test', () =&gt; { let username = undefined; // 즉시 undefined로 평가됩니다. cy.visit('https://app.com'); // 아직 아무 일도 일어나지 않습니다. cy.get('.user-name') // 아직 아무 일도 일어나지 않습니다. .then(($el) =&gt; { // 아직 아무 일도 일어나지 않습니다. // 이 코드는 '.then()'이 실행된 이후에 평가됩니다. username = $el.text(); }); // 이 코드는 위의 '.then()' 이전에 평가됩니다. // 따라서 username은 여전히 undefined입니다. if (username) { // 즉시 'undefined'로 평가됩니다. cy.contains(username).click(); } else { // username이 항상 undefined로 평가되므로 // 항상 이 코드가 실행됩니다. cy.contains('My Profile').click(); } }); 복사 js it('test', () =&gt; { let username = undefined; // 즉시 undefined로 평가됩니다. cy.visit('https://app.com'); // 아직 아무 일도 일어나지 않습니다. cy.get('.user-name') // 아직 아무 일도 일어나지 않습니다. .then(($el) =&gt; { // 아직 아무 일도 일어나지 않습니다. // 이 코드는 '.then()'이 실행된 이후에 평가됩니다. username = $el.text(); }); // 이 코드는 위의 '.then()' 이전에 평가됩니다. // 따라서 username은 여전히 undefined입니다. if (username) { // 즉시 'undefined'로 평가됩니다. cy.contains(username).click(); } else { // username이 항상 undefined로 평가되므로 // 항상 이 코드가 실행됩니다. cy.contains('My Profile').click(); } }); 복사 ✔️ 올바른 사용법 js it('test', () =&gt; { let username = undefined; // 즉시 undefined로 평가됩니다. cy.visit('https://app.com'); // 아직 아무 일도 일어나지 않습니다. cy.get('.user-name') // 아직 아무 일도 일어나지 않습니다. .then(($el) =&gt; { // 아직 아무 일도 일어나지 않습니다. // 이 코드는 '.then()'이 실행된 이후에 평가됩니다. username = $el.text(); // 이 코드는 '.then()'이 실행된 이후에 평가됩니다. // '$el.text()'에서 얻은 올바른 값이 username에 들어 있습니다. if (username) { cy.contains(username).click(); } else { cy.get('My Profile').click(); } }); }); 복사 js it('test', () =&gt; { let username = undefined; // 즉시 undefined로 평가됩니다. cy.visit('https://app.com'); // 아직 아무 일도 일어나지 않습니다. cy.get('.user-name') // 아직 아무 일도 일어나지 않습니다. .then(($el) =&gt; { // 아직 아무 일도 일어나지 않습니다. // 이 코드는 '.then()'이 실행된 이후에 평가됩니다. username = $el.text(); // 이 코드는 '.then()'이 실행된 이후에 평가됩니다. // '$el.text()'에서 얻은 올바른 값이 username에 들어 있습니다. if (username) { cy.contains(username).click(); } else { cy.get('My Profile').click(); } }); }); 복사 핵심 개념 각 사이프러스 명령은 나중에 실행될 명령 대기열에 추가만 되고 즉시 반환됩니다. 명령의 반환값을 이용해 어떤 작업을 수행하는 것은 불가능합니다. 명령은 대기열에 추가되고 장막 뒤에서 관리됩니다. "},{"title":"반복문 피하기​","type":1,"pageTitle":"명령 체인","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/명령-체인#반복문-피하기","content":"while과 같은 자바스크립트 반복문을 사용하면 예기치 않은 결과가 발생할 수 있습니다. 앱이 로드 시 임의의 숫자를 표시한다고 가정해 보겠습니다. 숫자 7을 찾으면 테스트가 중지되기를 원합니다. 다른 숫자가 표시되면 테스트에서 페이지를 다시 로드하고 확인합니다. ❌ 잘못된 테스트 다음 테스트는 작동하지 않으며 브라우저에서 충돌이 생길 가능성이 높습니다. js let found7 = false; while (!found7) { // 이 코드는 무한히 많은 'cy.get...' 명령을 예약하며, // 명령 중 하나가 실행되어 found7이 true가 되기 전에 충돌을 일으킵니다. cy.get('#result') .should('not.be.empty') .invoke('text') .then(parseInt) .then((number) =&gt; { if (number === 7) { found7 = true; cy.log('lucky **7**'); } else { cy.reload(); } }); } 복사 js let found7 = false; while (!found7) { // 이 코드는 무한히 많은 'cy.get...' 명령을 예약하며, // 명령 중 하나가 실행되어 found7이 true가 되기 전에 충돌을 일으킵니다. cy.get('#result') .should('not.be.empty') .invoke('text') .then(parseInt) .then((number) =&gt; { if (number === 7) { found7 = true; cy.log('lucky **7**'); } else { cy.reload(); } }); } 복사 while 반복문은 사이프러스가 첫 번째 cy.get(...) 명령의 실행을 시작하도록 허용하지 않습니다. ✔️ 올바른 테스트 반복 재개 여부를 판단하기 전에 명령을 실행할 기회를 테스트에게 줘야 합니다. 따라서 올바른 테스트는 재귀를 사용합니다. js const checkAndReload = () =&gt; { // 요소의 텍스트를 얻어서 숫자로 변환합니다. cy.get('#result') .should('not.be.empty') .invoke('text') .then(parseInt) .then((number) =&gt; { // 원하는 숫자가 나오면 명령을 추가하는 것을 멈춥니다. if (number === 7) { cy.log('lucky **7**'); return; } // 그러지 않으면 새로고침 후에 함수를 호출해서 // 사이프러스 명령을 추가합니다. cy.wait(500, { log: false }); cy.reload(); checkAndReload(); }); }; cy.visit('public/index.html'); checkAndReload(); 복사 js const checkAndReload = () =&gt; { // 요소의 텍스트를 얻어서 숫자로 변환합니다. cy.get('#result') .should('not.be.empty') .invoke('text') .then(parseInt) .then((number) =&gt; { // 원하는 숫자가 나오면 명령을 추가하는 것을 멈춥니다. if (number === 7) { cy.log('lucky **7**'); return; } // 그러지 않으면 새로고침 후에 함수를 호출해서 // 사이프러스 명령을 추가합니다. cy.wait(500, { log: false }); cy.reload(); checkAndReload(); }); }; cy.visit('public/index.html'); checkAndReload(); 복사 "},{"title":"순차적으로 실행되는 명령​","type":1,"pageTitle":"명령 체인","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/명령-체인#순차적으로-실행되는-명령","content":"사이프러스는 앱의 상태가 명령이 예상하는 것과 일치하는지 확인하기 위해 많은 추가 작업을 수행합니다. 일부 명령은 빠르게 이행될 수 있지만, 일부 명령은 이행되는 데 몇 초에서 수십 초가 걸릴 수 있습니다. 핵심 개념 단계가 성공했는지 확인하는 데 필요한 모든 대기나 재시도는 다음 단계가 시작되기 전에 완료되어야 합니다. 타임아웃이 끝나기 전에 성공적으로 완료되지 않으면 테스트가 실패합니다. "},{"title":"사이프러스 명령 대기열​","type":1,"pageTitle":"명령 체인","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/명령-체인#사이프러스-명령-대기열","content":"then() 문법 때문에 사이프러스 API가 얼핏 프라미스와 비슷해 보이지만 사이프러스 명령은 프라미스가 아닙니다. 사이프러스 명령은 나중에 비동기적으로 실행되도록 중앙 대기열로 전달되는 직렬 명령입니다. 거의 모든 명령에는 재시도 기능이 내장됩니다. 재시도 기능이 없다면 단언이 무작위로 실패할 것입니다. 또한 명령에는 프라미스 기반 테스트에 익숙한 개발자가 예기치 않게 발견할 수 있는 몇 가지 디자인 선택 사항이 있습니다. "},{"title":"경주 명령은 불가능​","type":1,"pageTitle":"명령 체인","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/명령-체인#경주-명령은-불가능","content":"많은 사이프러스 명령은 어떤 방식으로든 브라우저의 상태를 변경합니다. cy.request()cy.clearCookies().click() 위의 명령들은 멱등성(idempotent)이 없습니다. 모두 부작용을 일으킵니다. 일관성을 유지하기 위해서는 명령을 제어된 직렬 방식으로 실행해야 합니다. 따라서 경주 명령은 불가능합니다. "},{"title":"에러 핸들러 .catch는 사용 불가​","type":1,"pageTitle":"명령 체인","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/명령-체인#에러-핸들러-catch는-사용-불가","content":"사이프러스에는 실패한 명령에 대한 에러 복구 기능 없습니다. 명령과 단언은 모두 통과하거나, 하나가 실패하면 나머지 명령이 실행되지 않고 테스트가 실패합니다. 참고 조건부 테스트를 수행하는 방법은 이곳에서 확인하세요. "},{"title":"요소 쿼리하기","type":0,"sectionRef":"#","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/요소-쿼리하기","content":"","keywords":""},{"title":"사이프러스와 제이쿼리의 공통점​","type":1,"pageTitle":"요소 쿼리하기","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/요소-쿼리하기#사이프러스와-제이쿼리의-공통점","content":"이전에 제이쿼리(jQuery)를 사용한 적이 있다면 다음과 같은 요소 쿼리가 익숙할 것입니다. js $('.my-selector'); 복사 js $('.my-selector'); 복사 사이프러스에서의 요소 쿼리는 동일합니다. js cy.get('.my-selector'); 복사 js cy.get('.my-selector'); 복사 사이프러스는 제이쿼리를 기본으로 제공하고 많은 DOM 탐색 방법을 지원하므로 이미 익숙한 API를 사용하여 복잡한 HTML 구조에서 쉽게 작업할 수 있습니다. js cy.get('#main-content') .find('.article') .children('img[src^=&quot;/static&quot;]') .first(); 복사 js cy.get('#main-content') .find('.article') .children('img[src^=&quot;/static&quot;]') .first(); 복사 핵심 개념 사이프러스는 제이쿼리의 강력한 선택자 엔진을 활용하여 최신 웹 개발자에게 친숙하고 읽기 쉬운 테스트를 제공합니다. 요소 선택에 대한 모범 사례는 이곳에서 확인하세요. "},{"title":"사이프러스와 제이쿼리의 차이점​","type":1,"pageTitle":"요소 쿼리하기","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/요소-쿼리하기#사이프러스와-제이쿼리의-차이점","content":"제이쿼리에서는 일치하는 DOM 요소를 찾지 못하면 빈 제이쿼리 컬렉션을 반환합니다. 반면 사이프러스에서는 다음 중 하나에 도달할 때까지 쿼리를 자동으로 재시도합니다. "},{"title":"1. 요소가 발견됨​","type":1,"pageTitle":"요소 쿼리하기","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/요소-쿼리하기#1-요소가-발견됨","content":"js cy // cy.get()는 #element을 찾는 쿼리를 반복합니다... .get('#element') // ...일치하는 요소를 찾을 때까지! // 이제 '.then'을 이용해서 요소를 다룰 수 있습니다. .then(($myElement) =&gt; { doSomething($myElement); }); 복사 js cy // cy.get()는 #element을 찾는 쿼리를 반복합니다... .get('#element') // ...일치하는 요소를 찾을 때까지! // 이제 '.then'을 이용해서 요소를 다룰 수 있습니다. .then(($myElement) =&gt; { doSomething($myElement); }); 복사 "},{"title":"2. 설정된 타임아웃에 도달함​","type":1,"pageTitle":"요소 쿼리하기","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/요소-쿼리하기#2-설정된-타임아웃에-도달함","content":"js cy // cy.get()는 #element-does-not-exist을 찾는 쿼리를 반복합니다... // ...타임아웃 전에 요소를 찾지 못합니다. // 사이프러스는 중지되고 테스트에 실패합니다. .get('#element-does-not-exist') // ...이 코드는 실행되지 않습니다... .then(($myElement) =&gt; { doSomething($myElement); }); 복사 js cy // cy.get()는 #element-does-not-exist을 찾는 쿼리를 반복합니다... // ...타임아웃 전에 요소를 찾지 못합니다. // 사이프러스는 중지되고 테스트에 실패합니다. .get('#element-does-not-exist') // ...이 코드는 실행되지 않습니다... .then(($myElement) =&gt; { doSomething($myElement); }); 복사 이런 방식은 사이프러스를 견고하게 만들고 다른 테스트 도구에서 발생하는 다음의 일반적인 문제에 내성을 갖게 합니다. DOM이 아직 로드되지 않음프레임워크의 부트스트랩이 아직 완료되지 않음XHR 요청에 대한 응답이 아직 오지 않음애니메이션이 아직 완료되지 않음 사이프러스는 내장 재시도 및 사용자 정의가 가능한 타임아웃 기능을 통해 이런 문제들을 피할 수 있습니다. 핵심 개념 사이프러스는 실제 웹 앱의 작동 방식에 잘 맞는 강력한 재시도 및 타임아웃 논리로 모든 DOM 쿼리를 래핑합니다. 모든 테스트에 대한 안정성을 높이는 대신 DOM 요소를 찾는 방법이 약간 다릅니다. 참고 사이프러스에서 DOM 요소와 직접 상호 작용하려면, 요소를 첫 번째 인수로 받는 콜백 함수로 .then()을 호출합니다. 재시도 및 타임아웃 기능을 완전히 건너뛰고 기존의 동기 작업을 수행하려면 Cypress.$을 사용합니다. "},{"title":"텍스트 콘텐츠로 쿼리하기​","type":1,"pageTitle":"요소 쿼리하기","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/요소-쿼리하기#텍스트-콘텐츠로-쿼리하기","content":"사용자와 유사하게 요소를 찾는 방법은 콘텐츠, 즉 사용자가 페이지에서 볼 수 있는 것으로 찾는 것입니다. 이를 위한 cy.contains() 명령이 있습니다. 예시: js // 'New Post' 텍스트가 포함된 요소를 문서에서 찾습니다. cy.contains('New Post'); // 'New Post' 텍스트가 포함된 요소를 '.main' 내부에서 찾습니다. cy.get('.main').contains('New Post'); 복사 js // 'New Post' 텍스트가 포함된 요소를 문서에서 찾습니다. cy.contains('New Post'); // 'New Post' 텍스트가 포함된 요소를 '.main' 내부에서 찾습니다. cy.get('.main').contains('New Post'); 복사 이는 앱과 상호 작용하는 사용자의 관점에서 테스트를 작성할 때 유용합니다. 사용자는 그저 '제출'이라고 표시된 버튼을 클릭하고 싶을 것입니다. 사용자는 submit이라는 type 속성이나 my-submit-button라는 CSS 클래스를 전혀 모릅니다. 주의 앱이 i18n을 위해 여러 언어로 번역된 경우, 사용자가 보는 텍스트를 사용하여 DOM 요소를 찾는 것의 부작용을 주의해야 한다. "},{"title":"요소가 없는 경우​","type":1,"pageTitle":"요소 쿼리하기","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/요소-쿼리하기#요소가-없는-경우","content":"사이프러스는 웹 앱의 비동기적 특성을 예상하고 요소를 발견하지 못했을 때 즉시 실패하지 않습니다. 사이프러스는 앱이 수행하던 모든 작업을 완료할 수 있는 시간을 줍니다. 이를 timeout이라고 하며 대부분의 명령은 타임아웃(기본값은 4초) 시간을 별도로 지정할 수 있습니다. js // 해당 요소가 나타날 때까지 10초의 시간을 줍니다. cy.get('.my-slow-selector', { timeout: 10000 }); 복사 js // 해당 요소가 나타날 때까지 10초의 시간을 줍니다. cy.get('.my-slow-selector', { timeout: 10000 }); 복사 환경 설정: defaultCommandTimeout을 통해 타임아웃 시간을 전역으로 설정할 수 있습니다. 핵심 개념 웹 앱의 작동 방식과 동일하게 사이프러스는 비동기적이며 앱이 예상한 상태로 전환될 때까지 기다리기 위해 타임아웃을 사용합니다. 타임아웃 시간은 전역으로 설정하거나 명령별로 설정할 수 있습니다. "},{"title":"테스트 유형","type":0,"sectionRef":"#","url":"/docs-repository/docs/cypress/핵심-개념/테스트-유형","content":"","keywords":""},{"title":"E2E 테스트​","type":1,"pageTitle":"테스트 유형","url":"/docs-repository/docs/cypress/핵심-개념/테스트-유형#e2e-테스트","content":"E2E(end-to-end) 테스트는 웹 브라우저에서 백엔드까지 앱을 테스트하고 타사 API 및 서비스와의 통합을 테스트하는 기술입니다. 이 테스트는 앱이 응집력 있는 전체로 잘 작동하는지 확인하는 데 유용합니다. 사이프러스는 사용자가 실제 브라우저를 사용하고, URL을 방문하고, 콘텐츠를 보고, 링크와 버튼을 클릭하며 앱과 상호 작용하는 것과 동일한 방식으로 E2E 테스트를 실행합니다. 이 방법으로 테스트하면 테스트와 사용자 경험이 동일한지 확인할 수 있습니다. 사이프러스에서 E2E 테스트 작성은 응용 프로그램을 빌드하는 개발자, 전문 테스트 엔지니어, 앱이 출시 준비가 되었는지 확인하는 품질 보증 팀이 수행할 수 있습니다. 테스트는 실제 사용자가 취하는 단계를 시뮬레이션하는 API를 사용하여 코드로 작성됩니다. E2E 테스트는 앱이 프런트 엔드에서 백 엔드까지 의도한 대로 실행되는지 확인할 수 있습니다. 그러나 E2E 테스트는 설정, 실행, 유지 관리가 더 어려울 수 있습니다. 테스트 목적으로 백엔드를 설정하려면 인프라가 필요한 경우가 많습니다. 팀은 이러한 복잡성을 처리할 전략을 세워야 합니다. E2E 테스트의 이점: 앱이 응집력 있는 전체로 잘 작동하는지 확인사용자 경험과 일치하는 테스트개발자 또는 QA 팀이 작성 가능통합 테스트에도 사용 가능 E2E 테스트의 고려 사항: 설정, 실행, 유지 관리의 어려움CI에서의 테스트 인프라 준비특정 시나리오의 테스트에는 많은 설정이 필요 E2E 테스트의 일반적인 시나리오: 인증이나 구매와 같은 중요한 워크플로 검증데이터의 지속성과 데이터가 복수의 화면에 잘 표시됨을 보장배포 전에 스모크 테스트 및 시스템 검사 실행 "},{"title":"컴포넌트 테스트​","type":1,"pageTitle":"테스트 유형","url":"/docs-repository/docs/cypress/핵심-개념/테스트-유형#컴포넌트-테스트","content":"최신 웹 프레임워크에서는 앱을 컴포넌트라는 더 작은 논리 단위로 분할하여 앱을 작성합니다. 컴포넌트는 버튼과 같이 아주 작은 것부터 등록 폼과 같은 복잡한 것까지 다양합니다. E2E 테스트에서는 전체 앱을 불러오기 위해 URL을 방문하는 반면, 컴포넌트 테스트에서는 컴포넌트를 '마운트'하고 자체적으로 테스트합니다. 이렇게 하면 컴포넌트의 기능만 테스트하는 데 집중할 수 있습니다. 큰 응용 프로그램의 일부로 컴포넌트를 테스트할 때의 다른 뉘앙스는 걱정할 필요가 없어집니다. 일반적으로 컴포넌트 테스트는 컴포넌트에서 만드는 개발자가 작성합니다. 테스트용 코드는 컴포넌트 코드와 함께 있으며 테스트는 컴포넌트와 동시에 코딩되는 것이 일반적입니다. 개발자는 빌드하는 동안 필요한 기능을 확인할 수 있습니다. 그러나 컴포넌트 테스트를 모두 통과하더라도 앱이 제대로 작동한다는 보장은 없습니다. 컴포넌트 테스트로는 앱의 모든 계층이 함께 잘 작동하는지 확인할 수 없습니다. 따라서 잘 테스트된 앱에는 E2E와 컴포넌트 테스트가 적절하게 결합되어 있습니다. 컴포넌트 테스트의 이점: 분리된 컴포넌트를 쉽게 테스트빠르고 안정적임테스트에서 특정 시나리오를 쉽게 설정 가능실행을 위해 외부 시스템에 의존할 필요가 없음 컴포넌트 테스트의 고려 사항: 전체 앱의 품질을 보장하지 않음외부 API나 서비스를 호출하지 못함일반적으로 컴포넌트를 만드는 개발자가 작성함 컴포넌트 테스트의 일반적인 시나리오: 날짜 선택 도구가 다양한 시나리오에서 제대로 작동하는지 테스트폼이 입력에 따라 특정 부분을 표시하고 숨김디자인 시스템에서 나오는 컴포넌트 테스트컴포넌트에 연결되지 않은 논리 테스트 (단위 테스트와 유사) "},{"title":"테스트 유형 비교​","type":1,"pageTitle":"테스트 유형","url":"/docs-repository/docs/cypress/핵심-개념/테스트-유형#테스트-유형-비교","content":"\tE2E\t요소테스트 대상\t모든 앱 계층\t개별 컴포넌트 특징\t포괄적이고 느리며 플레이크 가능성이 높음\t전문화, 신속, 신뢰성 용도\t앱이 응집력 있는 전체로 작동하는지 확인\t개별 컴포넌트의 기능 테스트 작성자\t개발자, QA 팀, SDET\t개발자, 디자이너 CI 인프라\t복잡한 설정이 필요한 경우가 많음\t필요 없음 초기화 명령\tcy.visit(url)\tcy.mount(&lt;MyComponent /&gt;) "},{"title":"타임아웃","type":0,"sectionRef":"#","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/타임아웃","content":"","keywords":""},{"title":"타임아웃 적용하기​","type":1,"pageTitle":"타임아웃","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/타임아웃#타임아웃-적용하기","content":"명령의 타임아웃을 수정할 수 있습니다. 이 타임아웃은 기본 단언과, 추가한 특정 단언 모두에 영향을 줍니다. 단언은 이전 명령의 조건을 설명하는 데 사용되므로 timeout의 수정은 단언이 아니라 이전 명령에 적용됩니다. "},{"title":"예시 #1: 기본 단언​","type":1,"pageTitle":"타임아웃","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/타임아웃#예시-1-기본-단언","content":"js // '.get()'에는 해당 요소가 존재한다는 기본 단언이 있으므로 // 타임아웃되고 실패할 수 있습니다. cy.get('.mobile-nav'); 복사 js // '.get()'에는 해당 요소가 존재한다는 기본 단언이 있으므로 // 타임아웃되고 실패할 수 있습니다. cy.get('.mobile-nav'); 복사 사이프러스 내부에서는 다음과 같이 작동합니다. .mobile-nav 요소에 대한 쿼리✨ 그리고 요소가 DOM에 존재할 때까지 최대 4초를 기다림 ✨ "},{"title":"예시 #2: 추가 단언​","type":1,"pageTitle":"타임아웃","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/타임아웃#예시-2-추가-단언","content":"js // 테스트에 두 개의 단언을 추가했습니다. cy.get('.mobile-nav').should('be.visible').and('contain', 'Home'); 복사 js // 테스트에 두 개의 단언을 추가했습니다. cy.get('.mobile-nav').should('be.visible').and('contain', 'Home'); 복사 사이프러스 내부에서는 다음과 같이 작동합니다. .mobile-nav 요소에 대한 쿼리✨ 그리고 요소가 DOM에 존재할 때까지 최대 4초를 기다림 ✨✨ 그리고 요소가 보일 때까지 최대 4초를 기다림 ✨✨ 그리고 요소에 Home이라는 텍스트가 포함될 때까지 최대 4초를 기다림 ✨ 사이프러스가 모든 단언이 통과할 때까지 기다리는 총 시간은 cy.get()의 타임아웃인 4초입니다. 타임아웃은 명령별로 수정할 수 있으며 이는 모든 기본 단언과 해당 명령 이후에 연결된 모든 단언에 영향을 미칩니다. "},{"title":"예시 #3: 타임아웃 수정하기​","type":1,"pageTitle":"타임아웃","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/타임아웃#예시-3-타임아웃-수정하기","content":"js // 기본 단언과 추가 단언 모두에 영향을 주는 // 타임아웃을 수정했습니다. cy.get('.mobile-nav', { timeout: 10000 }) .should('be.visible') .and('contain', 'Home'); 복사 js // 기본 단언과 추가 단언 모두에 영향을 주는 // 타임아웃을 수정했습니다. cy.get('.mobile-nav', { timeout: 10000 }) .should('be.visible') .and('contain', 'Home'); 복사 사이프러스 내부에서는 다음과 같이 작동합니다. .mobile-nav 요소에 대한 쿼리✨ 그리고 요소가 DOM에 존재할 때까지 최대 10초를 기다림 ✨✨ 그리고 요소가 보일 때까지 최대 10초를 기다림 ✨✨ 그리고 요소에 Home이라는 텍스트가 포함될 때까지 최대 10초를 기다림 ✨ 타임아웃은 모든 단언으로 흘러갔고 이제 사이프러스는 모든 단언이 통과할 때까지 총 10초 동안 기다립니다. 위험 단언 내부에서 타임아웃을 변경하지 않아야 합니다. timeout 매개변수는 항상 명령 내부에 있어야 합니다. js // ❌ 작동하지 않는다. cy.get('.selector').should('be.visible', { timeout: 1000 }); // ✔️ 올바른 방법 cy.get('.selector', { timeout: 1000 }).should('be.visible'); 복사 js // ❌ 작동하지 않는다. cy.get('.selector').should('be.visible', { timeout: 1000 }); // ✔️ 올바른 방법 cy.get('.selector', { timeout: 1000 }).should('be.visible'); 복사 단언뿐만 아니라 단언이 첨부된 명령을 재시도한다는 것을 기억해야 합니다. "},{"title":"기본값​","type":1,"pageTitle":"타임아웃","url":"/docs-repository/docs/cypress/핵심-개념/사이프러스-소개/타임아웃#기본값","content":"사이프러스는 명령 유형에 따라 몇 가지 다른 타임아웃 값을 제공합니다. 특정 작업의 예상 소요 시간을 기준으로 기본 타임아웃 값을 설정했습니다. cy.visit() - 원격 페이지를 로드하고 모든 외부 리소스가 로드 단계를 완료할 때까지 이행되지 않습니다. 시간이 오래 걸릴 수 있으므로 기본 타임아웃은 60000ms로 설정됩니다.cy.exec() - 데이터베이스 시딩과 같은 시스템 명령을 실행합니다. 이것은 잠재적으로 오랜 시간이 걸릴 것으로 예상되며 기본 타임아웃은 60000ms로 설정됩니다.cy.wait() - 두 개의 다른 타임아웃을 사용합니다. 라우팅 별칭을 기다릴 때는 5000ms 동안 일치하는 요청을 기다리며, 그러고 나서 추가로 서버의 응답을 30000ms 동안 기다립니다. 앱이 일치하는 요청을 빠르게 만들 것으로 예상하고, 서버의 응답은 잠재적으로 훨씬 더 오래 걸릴 것으로 예상합니다. DOM 기반 명령을 포함한 대부분의 명령은 기본적으로 4000ms 후에 타임아웃됩니다. "},{"title":"디자인 원칙","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/chakra-ui","content":"디자인 원칙 차크라 UI(Chakra UI)는 컴포넌트를 매우 일관성 있게 유지한다는 원칙에 따라 만들어졌습니다. 우리의 목표는 실제 UI 디자인 문제를 해결하는 간단하고 구성 가능한 컴포넌트를 디자인하는 것입니다. 이를 위해 일련의 원칙을 만들었습니다. 스타일 프롭 - 모든 컴포넌트는 css 프롭이나 styled() 사용을 줄이기 위해 스타일 프롭으로 재정의하거나 확장할 수 있습니다. Box에서 새 컴포넌트를 구성합니다.간단함 - 컴포넌트 API를 매우 단순하게 유지하고 컴포넌트를 사용하는 실제 시나리오를 보여주도록 노력합니다.합성 - 최소한의 프롭으로 컴포넌트를 분해하여 복잡성을 낮추고 다른 컴포넌트와 함께 구성합니다. 이렇게 하면 스타일과 기능이 유연하고 확장 가능해집니다.접근성 - 컴포넌트를 만들 때 접근성을 가정 먼저 고려합니다. 여기에는 키보드 내비게이션, 포커스 관리, 색상 대비, 보이스오버, 올바른 aria-* 속성이 포함됩니다.다크 모드 - 컴포넌트를 다크 모드와 호환되게 합니다. useColorMode 훅을 사용해 스타일을 처리합니다. 다크 모드에서 자세한 내용을 확인하세요.프롭의 이름 - 일반적으로 프롭의 이름이 그 역할을 나타냅니다. 불린형 프롭은 does, has, is, should 같은 보조 동사를 사용해 이름을 짓습니다. 예를 들어 Button은 isDisabled, isLoading 등을 사용합니다.","keywords":""},{"title":"넥스트로 시작하기","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/chakra-ui/next-js","content":"","keywords":""},{"title":"설치​","type":1,"pageTitle":"넥스트로 시작하기","url":"/docs-repository/docs/miscellaneous/chakra-ui/next-js#설치","content":"넥스트 프로젝트에서 다음을 실행하여 차크라 UI를 설치합니다. npmYarn bash npm i @chakra-ui/react @emotion/react@^11 @emotion/styled@^11 framer-motion@^6 복사 bash npm i @chakra-ui/react @emotion/react@^11 @emotion/styled@^11 framer-motion@^6 복사 "},{"title":"제공자 설정​","type":1,"pageTitle":"넥스트로 시작하기","url":"/docs-repository/docs/miscellaneous/chakra-ui/next-js#제공자-설정","content":"차크라 UI를 설치한 후, 앱의 루트에 ChakraProvider를 설정해야 합니다. pages/_app.js 또는 pages/_app.tsx(존재하지 않으면 생성함)으로 가서 Component를 ChakraProvider로 감쌉니다. pages/_app.js jsx import { ChakraProvider } from '@chakra-ui/react' function MyApp({ Component, pageProps }) { return ( &lt;ChakraProvider&gt; &lt;Component {...pageProps} /&gt; &lt;/ChakraProvider&gt; ) } export default MyApp 복사 pages/_app.js jsx import { ChakraProvider } from '@chakra-ui/react' function MyApp({ Component, pageProps }) { return ( &lt;ChakraProvider&gt; &lt;Component {...pageProps} /&gt; &lt;/ChakraProvider&gt; ) } export default MyApp 복사 "},{"title":"테마 사용자 정의하기​","type":1,"pageTitle":"넥스트로 시작하기","url":"/docs-repository/docs/miscellaneous/chakra-ui/next-js#테마-사용자-정의하기","content":"디자인 요구 사항에 맞게 기본 테마 객체를 사용자 정의하려면 theme를 확장해야 합니다. 차크라 UI는 기본 테마를 커스텀과 깊게 병합할 수 있는 extendTheme 함수를 제공합니다. pages/_app.js jsx import { ChakraProvider } from '@chakra-ui/react' // 1. extendTheme 함수를 가져옵니다. import { extendTheme } from '@chakra-ui/react' // 2. 커스텀 색상, 글꼴 등을 포함하도록 테마를 확장합니다. const colors = { brand: { 900: '#1a365d', 800: '#153e75', 700: '#2a69ac', }, } const theme = extendTheme({ colors }) // 3. theme 프롭을 ChakraProvider에 건네줍니다. function MyApp({ Component, pageProps }) { return ( &lt;ChakraProvider theme={theme}&gt; &lt;Component {...pageProps} /&gt; &lt;/ChakraProvider&gt; ) } export default MyApp; 복사 pages/_app.js jsx import { ChakraProvider } from '@chakra-ui/react' // 1. extendTheme 함수를 가져옵니다. import { extendTheme } from '@chakra-ui/react' // 2. 커스텀 색상, 글꼴 등을 포함하도록 테마를 확장합니다. const colors = { brand: { 900: '#1a365d', 800: '#153e75', 700: '#2a69ac', }, } const theme = extendTheme({ colors }) // 3. theme 프롭을 ChakraProvider에 건네줍니다. function MyApp({ Component, pageProps }) { return ( &lt;ChakraProvider theme={theme}&gt; &lt;Component {...pageProps} /&gt; &lt;/ChakraProvider&gt; ) } export default MyApp; 복사 참고 컴포넌트를 사용자 정의하거나 고유한 디자인 시스템을 구축하고 싶다면theme-tools 패키지에 유용한 유틸리티가 포함되어 있습니다. "},{"title":"색상 모드 스크립트​","type":1,"pageTitle":"넥스트로 시작하기","url":"/docs-repository/docs/miscellaneous/chakra-ui/next-js#색상-모드-스크립트","content":"로컬 저장소 동기화가 올바르게 작동하도록, 색상 모드 스크립트는 body 태그 내부의 콘텐츠 앞에 추가해야 합니다. 참고 초기 색상 모드를 설정할 때는 이를 테마에 추가하고 ColorModeScript에서 참조하는 것이 좋습니다. 참고 사이트에서 ColorModeScript를 엄격한 Content-Security-Policy로 사용하려면, &lt;script&gt; 태그에 전달될 nonce 프롭을 사용할 수 있습니다. pages/_document.js jsx import { ColorModeScript } from '@chakra-ui/react' import NextDocument, { Html, Head, Main, NextScript } from 'next/document' import theme from './theme' export default class Document extends NextDocument { render() { return ( &lt;Html lang='en'&gt; &lt;Head /&gt; &lt;body&gt; {/* 👇 이곳에 스크립트가 들어갑니다. */} &lt;ColorModeScript initialColorMode={theme.config.initialColorMode} /&gt; &lt;Main /&gt; &lt;NextScript /&gt; &lt;/body&gt; &lt;/Html&gt; ) } } 복사 pages/_document.js jsx import { ColorModeScript } from '@chakra-ui/react' import NextDocument, { Html, Head, Main, NextScript } from 'next/document' import theme from './theme' export default class Document extends NextDocument { render() { return ( &lt;Html lang='en'&gt; &lt;Head /&gt; &lt;body&gt; {/* 👇 이곳에 스크립트가 들어갑니다. */} &lt;ColorModeScript initialColorMode={theme.config.initialColorMode} /&gt; &lt;Main /&gt; &lt;NextScript /&gt; &lt;/body&gt; &lt;/Html&gt; ) } } 복사 타입스크립트 참고 사항 🚨​ 타입스크립트 프로젝트에 차크라 UI를 추가할 때 타입스크립트 버전은 최소 4.1.0이 필요합니다. "},{"title":"ChakraProvider의 프롭​","type":1,"pageTitle":"넥스트로 시작하기","url":"/docs-repository/docs/miscellaneous/chakra-ui/next-js#chakraprovider의-프롭","content":"이름\t타입\t기본값\t설명resetCSS\tboolean\ttrue\t&lt;CSSReset /&gt;을 자동으로 포함 theme\tTheme\t@chakra-ui/theme\t선택적인 커스텀 테마 colorModeManager\tStorageManager\tlocalStorageManager\t사용자 색상 모드의 기본 설정을 유지하는 관리자 portalZIndex\tnumber\tundefined\tPortal에 사용되는 일반적인 z-index "},{"title":"설치","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/chakra-ui/설치","content":"","keywords":""},{"title":"프레임워크 안내서​","type":1,"pageTitle":"설치","url":"/docs-repository/docs/miscellaneous/chakra-ui/설치#프레임워크-안내서","content":"차크라 UI를 원하는 프레임워크에서 사용할 수 있습니다. 다음 프레임워크에 대한 단계별 안내서를 준비했습니다. Next.js 다른 프레임워크는 원문을 확인하세요. "},{"title":"테스트 작성 및 구성하기","type":0,"sectionRef":"#","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기","content":"","keywords":""},{"title":"폴더 구조​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#폴더-구조","content":"새 프로젝트를 추가하면 사이프러스는 제안된 폴더 구조를 자동으로 생성합니다. E2E: /cypress.config.ts /cypress/fixtures/example.json /cypress/support/commands.ts /cypress/support/e2e.ts 컴포넌트: /cypress.config.ts /cypress/fixtures/example.json /cypress/support/commands.ts /cypress/support/component.ts /cypress/support/component-index.html 공통: /cypress.config.ts /cypress/fixtures/example.json /cypress/support/commands.ts /cypress/support/e2e.ts /cypress/support/component.ts /cypress/support/component-index.html 복사 E2E: /cypress.config.ts /cypress/fixtures/example.json /cypress/support/commands.ts /cypress/support/e2e.ts 컴포넌트: /cypress.config.ts /cypress/fixtures/example.json /cypress/support/commands.ts /cypress/support/component.ts /cypress/support/component-index.html 공통: /cypress.config.ts /cypress/fixtures/example.json /cypress/support/commands.ts /cypress/support/e2e.ts /cypress/support/component.ts /cypress/support/component-index.html 복사 "},{"title":"폴더 구조 설정하기​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#폴더-구조-설정하기","content":"테스트, 픽스처(fixture), 지원 파일의 위치를 별도로 설정하는 것이 가능하지만 첫 프로젝트는 위의 구조로 시작하는 것이 좋습니다. 설정 파일에서 폴더 구성을 수정할 수 있습니다. 자세한 내용은 사이프러스 설정에서 확인하세요. .gitignore에 어떤 파일을 추가해야 하나요? 사이프러스는 앱을 테스트하는 동안 촬영한 스크린숏과 비디오를 저장하기 위해 screenshotsFolder와 videosFolder을 생성합니다. 많은 사용자가 이 폴더를 .gitignore에 추가합니다. 또한 사이프러스 설정이나 cypress.env.json에 민감한 환경 변수를 저장하는 경우에는 해당 파일도 추가해야 합니다. "},{"title":"스펙 파일​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#스펙-파일","content":"테스트 파일은 기본적으로 cypress/e2e에 있지만 원한다면 다른 디렉터리로 설정할 수 있습니다. 테스트 파일은 다음의 확장자를 가질 수 있습니다. .js.jsx.ts.tsx.coffee.cjsx 사이프러스는 기본적으로 ES2015도 지원합니다. ES2015 modules 또는 CommonJS modules를 사용할 수 있습니다. 따라서 npm 패키지와 로컬 관련 모듈을 불러올 때 import와 require를 모두 사용할 수 있습니다. "},{"title":"픽스처 파일​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#픽스처-파일","content":"픽스처는 테스트에서 사용할 수 있는 정적 데이터의 외부 조각으로 사용됩니다. 픽스처 파일은 기본적으로 cypress/fixtures에 있지만 원한다면 다른 디렉터리로 설정할 수 있습니다. 일반적으로 cy.fixture() 명령과 함께 사용하며 네트워크 요청을 스텁할 때 많이 사용합니다. "},{"title":"자산 파일​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#자산-파일","content":"테스트 실행 후에 생성될 수 있는 폴더가 있습니다. 테스트 과정에서 생성된 자산이 이 폴더에 포함됩니다. 자산 폴더를 .gitignore 파일에 추가하는 것을 고려할 수 있습니다. 다운로드 파일​ 앱의 파일 다운로드 기능을 테스트하는 동안 다운로드한 모든 파일은 기본적으로 cypress/downloads로 설정된 downloadsFolder에 저장됩니다. /cypress /downloads - records.csv 복사 /cypress /downloads - records.csv 복사 스크린숏 파일​ cy.screenshot() 명령을 사용하거나, 테스트가 실패했을 때 자동으로 찍힌 스크린숏은 기본적으로 cypress/screenshots로 설정된 screenshotsFolder에 저장됩니다. /cypress /screenshots /app.cy.js - Navigates to main menu (failures).png 복사 /cypress /screenshots /app.cy.js - Navigates to main menu (failures).png 복사 비디오 파일​ 테스트에서 녹화된 모든 비디오는 기본적으로 cypress/videos로 설정된 videosFolder에 저장됩니다. 자산 파일 경로​ 생성된 스크린숏과 동영상은 각각 폴더(cypress/screenshots, cypress/videos)에 저장됩니다. 생성된 파일의 경로는 specPattern 옵션에 의해 찾은 모든 스펙 파일 간의 공통 상위 경로가 제거된 경로입니다. 예시 1: 스펙 파일을 찾음 cypress/e2e/path/to/file/one.cy.js 공통 조상 경로 (런타임에 계산됨) cypress/e2e/path/to/file 생성된 스크린숏 파일 cypress/screenshots/one.cy.js/your-screenshot.png 생성된 비디오 파일 cypress/videos/one.cy.js.mp4 예시 2: 스펙 파일을 찾음 cypress/e2e/path/to/file/one.cy.jscypress/e2e/path/to/two.cy.js 공통 조상 경로 (런타임에 계산됨) cypress/e2e/path/to/ 생성된 스크린숏 파일 cypress/screenshots/file/one.cy.js/your-screenshot.pngcypress/screenshots/two.cy.js/your-screenshot.png 생성된 비디오 파일 cypress/videos/file/one.cy.js.mp4cypress/videos/two.cy.js.mp4 "},{"title":"플러그인 파일​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#플러그인-파일","content":"플러그인 파일은 프로젝트 로드 전, 브라우저 실행 전, 테스트 실행 중에 노드(Node.js)에서 실행되는 특별한 파일입니다. 테스트가 브라우저에서 실행되는 동안 플러그인 파일은 백그라운드 노드 프로세스에서 실행됩니다. 플러그인 파일은 cy.task() 명령을 호출하여 파일 시스템과 나머지 운영 체제에 액세스할 수 있는 기능을 테스트에 제공합니다. 전처리기로 스펙 파일을 묶는 방법, 브라우저 런치 API를 통해 브라우저를 찾고 시작하는 방법을 비롯한 기타 멋진 것들을 플러그인 파일에서 정의할 수 있습니다. 자세한 내용과 예제는 플러그인 안내서를 확인하세요. 초기에 가져오는 플러그인 파일을 다른 파일로 설정할 수 있습니다. "},{"title":"지원 파일​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#지원-파일","content":"테스트 파일 앞에 코드를 넣으려면 supportFile 경로를 지정하면 됩니다. 기본적으로 supportFile은 다음 파일을 찾도록 설정되어 있습니다. 컴포넌트: cypress/support/component.jscypress/support/component.jsxcypress/support/component.tscypress/support/component.tsx E2E: cypress/support/e2e.jscypress/support/e2e.jsxcypress/support/e2e.tscypress/support/e2e.tsx 위험 주어진 테스트 유형과 일치하는 supportFile 파일이 여러 개 있으면 사이프러스가 로드될 때 오류가 발생합니다. 사이프러스 앱은 구성된 각 테스트 유형에 대한 예시 지원 파일을 자동으로 생성하며 여기에는 몇 가지 주석 처리된 예시가 포함되어 있습니다. 지원 파일은 모든 스펙 파일보다 먼저 실행됩니다. 별도로 이 파일을 가져올 필요는 없습니다. 기본적으로 사이프러스는 유형별 지원 파일을 자동으로 포함합니다. E2E의 경우 기본값은 cypress/support/e2e.{js,jsx,ts,tsx}이고 컴포넌트 테스트의 경우 cypress/support/component.{js,jsx,ts,tsx}입니다. 지원 파일은 모든 스펙 파일에 적용하고 사용할 수 있는 사용자 정의 명령이나 전역 재정의 같은 재사용 가능한 작동을 넣기에 좋은 위치입니다. 처음 가져오는 지원 파일은 다른 파일로 설정하거나 supportFile 설정을 사용해 완전히 끌 수 있습니다. 지원 파일에서 import나 require로 다른 파일을 가져올 수 있습니다. cypress/support 파일 내부의 before 또는 beforeEach에서 작동을 정의할 수 있습니다. js beforeEach(() =&gt; { cy.log('I run before every test in every spec file!!!!!!'); }); 복사 js beforeEach(() =&gt; { cy.log('I run before every test in every spec file!!!!!!'); }); 복사 실행​ 사이프러스는 스펙 파일에 앞서 지원 파일을 먼저 실행합니다. 예를 들어 사이프러스는 cypress open 또는 cypress run으로 스펙 파일을 실행할 때 다음 순서로 파일을 실행합니다. e2e 예시: support/e2e.js (지원 파일)e2e/spec-a.cy.js (스펙 파일) 컴포넌트 예시: support/component.js (지원 파일)components/Button/Button.cy.js (스펙 파일) "},{"title":"문제 해결하기​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#문제-해결하기","content":"어떤 이유로 사이프러스가 스펙 파일을 찾지 못하면 디버그 로그가 활성화된 상태에서 사이프러스를 열거나 실행하여 논리 문제를 해결할 수 있습니다. shell DEBUG=cypress:server:specs npx cypress open ## 또는 DEBUG=cypress:server:specs npx cypress run 복사 shell DEBUG=cypress:server:specs npx cypress open ## 또는 DEBUG=cypress:server:specs npx cypress run 복사 "},{"title":"테스트 작성하기​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#테스트-작성하기","content":"사이프러스는 모카와 차이를 기반으로 합니다. 차이의 BDD와 TDD 단언 스타일을 모두 지원합니다. 사이프러스에서 작성하는 테스트는 대부분 이 스타일을 따릅니다. "},{"title":"테스트 구조​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#테스트-구조","content":"모카에서 차용한 테스트 인터페이스는 describe(), context(), it(), specify()를 제공합니다. context()는 describe()와 동일하고, specify()는 it()과 동일하므로 원하는 것을 선택하면 됩니다. "},{"title":"훅​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#훅","content":"사이프러스는 모카에서 차용한 훅(hook)도 제공합니다. 훅을 이용해 일련의 테스트나 각 테스트 전에 실행할 조건을 설정할 수 있습니다. 또한 일련의 테스트나 각 테스트 후에 상태를 정리하는 데 도움이 됩니다. js before(() =&gt; { // 루트 레벨 훅 // 모든 테스트 이전에 한 번 실행됩니다. }); beforeEach(() =&gt; { // 루트 레벨 훅 // 각 테스트 블록 이전에 실행됩니다. }); afterEach(() =&gt; { // 각 테스트 블록 이후에 실행됩니다. }); after(() =&gt; { // 모든 테스트가 끝나고 한 번 실행됩니다. }); describe('Hooks', () =&gt; { before(() =&gt; { // 블록의 모든 테스트 이전에 한 번 실행됩니다. }); beforeEach(() =&gt; { // 블록의 각 테스트 이전에 실행됩니다. }); afterEach(() =&gt; { // 블록의 각 테스트 이후에 실행됩니다. }); after(() =&gt; { // 블록의 모든 테스트 이후에 한 번 실행됩니다. }); }); 복사 js before(() =&gt; { // 루트 레벨 훅 // 모든 테스트 이전에 한 번 실행됩니다. }); beforeEach(() =&gt; { // 루트 레벨 훅 // 각 테스트 블록 이전에 실행됩니다. }); afterEach(() =&gt; { // 각 테스트 블록 이후에 실행됩니다. }); after(() =&gt; { // 모든 테스트가 끝나고 한 번 실행됩니다. }); describe('Hooks', () =&gt; { before(() =&gt; { // 블록의 모든 테스트 이전에 한 번 실행됩니다. }); beforeEach(() =&gt; { // 블록의 각 테스트 이전에 실행됩니다. }); afterEach(() =&gt; { // 블록의 각 테스트 이후에 실행됩니다. }); after(() =&gt; { // 블록의 모든 테스트 이후에 한 번 실행됩니다. }); }); 복사 훅과 테스트 실행 순서는 다음과 같습니다. 모든 before() 훅 실행 (한 번)모든 beforeEach() 훅 실행테스트 실행모든 afterEach() 훅 실행모든 after() 훅 실행 (한 번) 위험 after()나 afterEach()를 작성하기 전에 after()나 afterEach()로 상태를 정리하는 안티 패턴을 참고하는 것이 좋습니다. "},{"title":"테스트 제외하기와 포함하기​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#테스트-제외하기와-포함하기","content":"지정된 스위트(복수의 테스트를 묶은 것)나 테스트를 실행하려면 함수에 .only를 추가하면 됩니다. 중첩된 모든 스위트도 실행됩니다. 이를 이용하면 한 번에 하나의 테스트를 실행할 수 있으며 테스트 스위트를 작성할 때 권장되는 방식입니다. js // -- 앱 코드의 시작 -- function fizzbuzz(num) { if (num % 3 === 0 &amp;&amp; num % 5 === 0) { return 'fizzbuzz'; } if (num % 3 === 0) { return 'fizz'; } if (num % 5 === 0) { return 'buzz'; } } // -- 앱 코드의 끝 -- // -- 사이프러스 테스트의 시작 -- describe('Unit Test FizzBuzz', () =&gt; { function numsExpectedToEq(arr, expected) { // 숫자 배열 내부를 반복하며 기대하는 값과 일치하는지 확인합니다. arr.forEach((num) =&gt; { expect(fizzbuzz(num)).to.eq(expected); }); } it.only('returns &quot;fizz&quot; when number is multiple of 3', () =&gt; { numsExpectedToEq([9, 12, 18], 'fizz'); }); it('returns &quot;buzz&quot; when number is multiple of 5', () =&gt; { numsExpectedToEq([10, 20, 25], 'buzz'); }); it('returns &quot;fizzbuzz&quot; when number is multiple of both 3 and 5', () =&gt; { numsExpectedToEq([15, 30, 60], 'fizzbuzz'); }); }); 복사 js // -- 앱 코드의 시작 -- function fizzbuzz(num) { if (num % 3 === 0 &amp;&amp; num % 5 === 0) { return 'fizzbuzz'; } if (num % 3 === 0) { return 'fizz'; } if (num % 5 === 0) { return 'buzz'; } } // -- 앱 코드의 끝 -- // -- 사이프러스 테스트의 시작 -- describe('Unit Test FizzBuzz', () =&gt; { function numsExpectedToEq(arr, expected) { // 숫자 배열 내부를 반복하며 기대하는 값과 일치하는지 확인합니다. arr.forEach((num) =&gt; { expect(fizzbuzz(num)).to.eq(expected); }); } it.only('returns &quot;fizz&quot; when number is multiple of 3', () =&gt; { numsExpectedToEq([9, 12, 18], 'fizz'); }); it('returns &quot;buzz&quot; when number is multiple of 5', () =&gt; { numsExpectedToEq([10, 20, 25], 'buzz'); }); it('returns &quot;fizzbuzz&quot; when number is multiple of both 3 and 5', () =&gt; { numsExpectedToEq([15, 30, 60], 'fizzbuzz'); }); }); 복사 스위트나 테스트를 건너뛰고 싶다면 함수에 .skip()를 추가합니다. 중첩된 모든 스위트도 건너뜁니다. js it.skip('returns &quot;fizz&quot; when number is multiple of 3', () =&gt; { numsExpectedToEq([9, 12, 18], 'fizz'); }); 복사 js it.skip('returns &quot;fizz&quot; when number is multiple of 3', () =&gt; { numsExpectedToEq([9, 12, 18], 'fizz'); }); 복사 "},{"title":"테스트 설정​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#테스트-설정","content":"테스트 설정 값을 스위트나 테스트에 적용할 수 있습니다. 설정 객체를 테스트나 스위트 함수의 두 번째 인수로 전달하면 됩니다. 이 설정은 지정된 스위트나 테스트 중에 적용되며 스위트나 테스트가 완료된 후에는 이전의 기본값으로 돌아갑니다. 문법​ js describe(name, config, fn); context(name, config, fn); it(name, config, fn); specify(name, config, fn); 복사 js describe(name, config, fn); context(name, config, fn); it(name, config, fn); specify(name, config, fn); 복사 허용된 설정값​ 위험 일부 설정값은 읽기 전용이며 테스트 설정을 통해 변경할 수 없습니다. 테스트 설명 옵션에서 자세한 내용을 확인하세요. 스위트 설정​ 특정 브라우저에서 실행할 때만 특정 테스트 스위트를 실행하거나 제외하고 싶다면, 해당 스위트 설정 내에서 browser 설정을 재정의하면 됩니다. browser 옵션은 Cypress.isBrowser()와 동일한 인수를 허용합니다. 다음 예시에서는 크롬 브라우저에서 해당 테스트 스위트를 건너뜁니다. js describe('When NOT in Chrome', { browser: '!chrome' }, () =&gt; { it('Shows warning', () =&gt; { cy.get('[data-testid=&quot;browser-warning&quot;]').should( 'contain', 'For optimal viewing, use Chrome browser' ); }); it('Links to browser compatibility doc', () =&gt; { cy.get('a.browser-compat') .should('have.attr', 'href') .and('include', 'browser-compatibility'); }); }); 복사 js describe('When NOT in Chrome', { browser: '!chrome' }, () =&gt; { it('Shows warning', () =&gt; { cy.get('[data-testid=&quot;browser-warning&quot;]').should( 'contain', 'For optimal viewing, use Chrome browser' ); }); it('Links to browser compatibility doc', () =&gt; { cy.get('a.browser-compat') .should('have.attr', 'href') .and('include', 'browser-compatibility'); }); }); 복사 다음 테스트 스위트는 파이어폭스 브라우저에서만 실행됩니다. 테스트 중 하나에서 뷰포트 해상도를 덮어쓰고 현재 환경 변수를 제공된 환경 변수와 병합합니다. js describe( 'When in Firefox', { browser: 'firefox', viewportWidth: 1024, viewportHeight: 700, env: { DEMO: true, API: 'http://localhost:9000', }, }, () =&gt; { it('Sets the expected viewport and API URL', () =&gt; { expect(cy.config('viewportWidth')).to.equal(1024); expect(cy.config('viewportHeight')).to.equal(700); expect(cy.env('API')).to.equal('http://localhost:9000'); }); it( 'Uses the closest API environment variable', { env: { API: 'http://localhost:3003', }, }, () =&gt; { expect(cy.env('API')).to.equal('http://localhost:3003'); // 다른 환병 변수는 변경되지 않습니다. expect(cy.env('DEMO')).to.be.true; } ); } ); 복사 js describe( 'When in Firefox', { browser: 'firefox', viewportWidth: 1024, viewportHeight: 700, env: { DEMO: true, API: 'http://localhost:9000', }, }, () =&gt; { it('Sets the expected viewport and API URL', () =&gt; { expect(cy.config('viewportWidth')).to.equal(1024); expect(cy.config('viewportHeight')).to.equal(700); expect(cy.env('API')).to.equal('http://localhost:9000'); }); it( 'Uses the closest API environment variable', { env: { API: 'http://localhost:3003', }, }, () =&gt; { expect(cy.env('API')).to.equal('http://localhost:3003'); // 다른 환병 변수는 변경되지 않습니다. expect(cy.env('DEMO')).to.be.true; } ); } ); 복사 단일 테스트 설정​ cypress run이나 cypress open의 재시도 횟수를 설정할 수 있습니다. 자세한 내용은 테스트 재시도를 확인하세요. js it('should redirect unauthenticated user to sign-in page', { retries: { runMode: 3, openMode: 2 } } () =&gt; { // 테스트 코드... }) }) 복사 js it('should redirect unauthenticated user to sign-in page', { retries: { runMode: 3, openMode: 2 } } () =&gt; { // 테스트 코드... }) }) 복사 "},{"title":"동적으로 테스트 생성하기​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#동적으로-테스트-생성하기","content":"자바스크립트를 사용하여 동적으로 테스트를 생성할 수 있습니다. js describe('if your app uses jQuery', () =&gt; { ['mouseover', 'mouseout', 'mouseenter', 'mouseleave'].forEach((event) =&gt; { it('triggers event: ' + event, () =&gt; { // 앱의 제이쿼리를 사용한다면 이벤트 콜백을 실행하는 // 제이쿼리 이벤트를 트리거할 수 있습니다. cy.get('#with-jquery') .invoke('trigger', event) .get('[data-testid=&quot;messages&quot;]') .should('contain', 'the event ' + event + 'was fired'); }); }); }); 복사 js describe('if your app uses jQuery', () =&gt; { ['mouseover', 'mouseout', 'mouseenter', 'mouseleave'].forEach((event) =&gt; { it('triggers event: ' + event, () =&gt; { // 앱의 제이쿼리를 사용한다면 이벤트 콜백을 실행하는 // 제이쿼리 이벤트를 트리거할 수 있습니다. cy.get('#with-jquery') .invoke('trigger', event) .get('[data-testid=&quot;messages&quot;]') .should('contain', 'the event ' + event + 'was fired'); }); }); }); 복사 위의 코드는 4가지 테스트가 포함된 스위트를 생성합니다. &gt; if your app uses jQuery &gt; triggers event: 'mouseover' &gt; triggers event: 'mouseout' &gt; triggers event: 'mouseenter' &gt; triggers event: 'mouseleave' 복사 &gt; if your app uses jQuery &gt; triggers event: 'mouseover' &gt; triggers event: 'mouseout' &gt; triggers event: 'mouseenter' &gt; triggers event: 'mouseleave' 복사 "},{"title":"단언 스타일​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#단언-스타일","content":"사이프러스는 BDD(expect, should)와 TDD(assert) 스타일의 기본 단언을 모두 지원합니다. 기본 단언에서 자세한 내용을 확인하세요. js it('can add numbers', () =&gt; { expect(add(1, 2)).to.eq(3); }); it('can subtract numbers', () =&gt; { assert.equal(subtract(5, 12), -7, 'these numbers are equal'); }); 복사 js it('can add numbers', () =&gt; { expect(add(1, 2)).to.eq(3); }); it('can subtract numbers', () =&gt; { assert.equal(subtract(5, 12), -7, 'these numbers are equal'); }); 복사 .should() 명령과 별칭 .and()를 사용하여 단언을 쉽게 연결할 수 있습니다. 단언에서 자세한 내용을 확인하세요. js cy.wrap(add(1, 2)).should('equal', 3); 복사 js cy.wrap(add(1, 2)).should('equal', 3); 복사 "},{"title":"테스트 실행하기​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#테스트-실행하기","content":"스펙 파일의 이름을 클릭하여 테스트를 실행할 수 있습니다. "},{"title":"테스트 상태​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#테스트-상태","content":"사이프러스 스펙이 모든 테스트를 완료하면 테스트는 다음 네 가지 상태 중 하나가 됩니다. 통과 (passed)실패 (failed)보류 (pending)건너뜀 (skipped) "},{"title":"통과​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#통과","content":"단언에 실패하지 않고 모든 명령을 성공적으로 완료하면 테스트를 통과합니다. 테스트는 여러 번의 재시도 후에 통과할 수도 있습니다. 이 경우 명령 로그에 몇 가지 실패한 시도가 표시되지만 궁극적으로는 전체 테스트가 성공적으로 완료됩니다. "},{"title":"실패​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#실패","content":"문제가 발생하면 테스트는 실패합니다. 테스트가 실패하면 스크린숏과 비디오가 문제를 찾는 데 도움이 될 수 있습니다. "},{"title":"보류​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#보류","content":"여러 가지 방법으로 플레이스홀더 테스트를 작성할 수 있으며 사이프러스는 해당 테스트를 실행하지 않습니다. 사이프러스는 해당 테스트를 보류로 표시합니다. 다음 세 가지 테스트는 모두 보류로 표시됩니다. js describe('TodoMVC', () =&gt; { it('is not written yet'); it.skip('adds 2 todos', function () { cy.visit('/'); cy.get('[data-testid=&quot;new-todo&quot;]') .type('learn testing{enter}') .type('be cool{enter}'); cy.get('[data-testid=&quot;todo-list&quot;] li').should('have.length', 100); }); xit('another test', () =&gt; { expect(false).to.true; }); }); 복사 js describe('TodoMVC', () =&gt; { it('is not written yet'); it.skip('adds 2 todos', function () { cy.visit('/'); cy.get('[data-testid=&quot;new-todo&quot;]') .type('learn testing{enter}') .type('be cool{enter}'); cy.get('[data-testid=&quot;todo-list&quot;] li').should('have.length', 100); }); xit('another test', () =&gt; { expect(false).to.true; }); }); 복사 "},{"title":"건너뜀​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#건너뜀","content":"마지막 테스트 상태는 테스트를 실행하려 했지만 어떤 런타임 오류로 인해 테스트를 건너뛴 것입니다. 예를 들어 어떤 페이지를 방문하는 beforeEach 훅을 공유하는 테스트 그룹을 가정해 보겠습니다. js /// &lt;reference types=&quot;cypress&quot; /&gt; describe('TodoMVC', () =&gt; { beforeEach(() =&gt; { cy.visit('/'); }); it('hides footer initially', () =&gt; { cy.get('[data-testid=&quot;filters&quot;]').should('not.exist'); }); it('adds 2 todos', () =&gt; { cy.get('[data-testid=&quot;new-todo&quot;]') .type('learn testing{enter}') .type('be cool{enter}'); cy.get('[data-testid=&quot;todo-list&quot;] li').should('have.length', 2); }); }); 복사 js /// &lt;reference types=&quot;cypress&quot; /&gt; describe('TodoMVC', () =&gt; { beforeEach(() =&gt; { cy.visit('/'); }); it('hides footer initially', () =&gt; { cy.get('[data-testid=&quot;filters&quot;]').should('not.exist'); }); it('adds 2 todos', () =&gt; { cy.get('[data-testid=&quot;new-todo&quot;]') .type('learn testing{enter}') .type('be cool{enter}'); cy.get('[data-testid=&quot;todo-list&quot;] li').should('have.length', 2); }); }); 복사 beforeEach 훅이 완료되고 모든 테스트가 완료되면 두 테스트는 통과한 것입니다. 그러나 beforeEach 훅 내부의 명령이 실패하면 어떻게 될까요? 예를 들어 존재하지 않는 페이지를 방문한다고 가정해 보겠습니다. js beforeEach(() =&gt; { cy.visit('/does-not-exist'); }); 복사 js beforeEach(() =&gt; { cy.visit('/does-not-exist'); }); 복사 사이프러스가 첫 번째 테스트를 실행하면 beforeEach 훅이 실패합니다. 이제 첫 번째 테스트가 실패로 표시됩니다. beforeEach 훅이 한 번 실패하면 사이프러스는 해당 블록의 나머지 테스트를 건너뜁니다. 동일하게 실패할 것이기 때문입니다. "},{"title":"테스트 감시하기​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#테스트-감시하기","content":"cypress open으로 실행하면 사이프러스는 스펙 파일의 변화를 감시합니다. 테스트 추가나 업데이트 직후, 사이프러스는 테스트를 다시 로드하고 해당 스펙 파일의 모든 테스트를 실행합니다. 기능을 구현하는 동안 테스트를 추가하거나 편집할 수 있습니다. 사이프러스 사용자 인터페이스는 항상 최신 편집 결과를 반영합니다. 참고 많은 테스트가 포함된 단일 스펙 파일을 지속적으로 편집할 때는 .only로 실행할 테스트를 제한하면 편리합니다. 테스트를 더 작은 파일로 분할하는 것도 좋은 방법입니다. "},{"title":"감시되는 것​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#감시되는-것","content":"파일​ 사이프러스 설정cypress.env.json 폴더​ E2E 디렉터리 (기본값은 cypress/e2e/)지원 디렉터리 (기본값은 cypress/support/) 모든 하위 폴더와 내부 파일이 감시됩니다. "},{"title":"감시되지 않는 것​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#감시되지-않는-것","content":"이외의 모든 것이 감시되지 않습니다. 대표적인 것은 다음과 같습니다. 앱 코드node_modulescypress/fixtures/ 최신 JS 기반 웹 앱 스택을 사용하여 개발하는 경우에는 앱 코드(HTML, CSS, JS 등)를 감시하고 변경 사항이 있으면 앱을 다시 투명하게 로딩합니다. "},{"title":"설정​","type":1,"pageTitle":"테스트 작성 및 구성하기","url":"/docs-repository/docs/cypress/핵심-개념/테스트-작성-및-구성하기#설정","content":"파일 감시를 비활성화하려면 watchForFileChanges 설정 프로퍼티를 false로 설정하면 됩니다. 주의 cypress run에서는 아무 것도 감시되지 않습니다. watchForFileChanges 프로퍼티는 cypress open을 이용해 사이프러스를 실행할 때만 적용됩니다. 사이프러스에서 파일 감시 작동을 담당하는 것은 webpack-preprocessor입니다. 이것은 사이프러스와 함께 패키지된 기본 파일 감시자입니다. 파일 감시 작동에 대한 추가 제어가 필요한 경우에는 이 전처리기를 명시적으로 설정할 수 있습니다. 이는 감시 대상 설정이나, 변경 후 '업데이트' 이벤트 발생 전의 지연과 같은 작동을 설정하는 옵션을 제공합니다. 사이프러스는 다른 파일 감시 전처리기도 제공합니다. 사용하려면 명시적으로 설정해야 합니다. 사이프러스 감시 전처리기사이프러스 웹팩 전처리기 "},{"title":"소개","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/emmet","content":"소개 에밋(Emmet)은 HTML과 CSS의 워크플로를 개선할 수 있는 텍스트 편집기의 플러그인입니다. VSC에서는 Tab 키로 실행합니다.","keywords":""},{"title":"약어","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/emmet/약어","content":"","keywords":""},{"title":"문법​","type":1,"pageTitle":"약어","url":"/docs-repository/docs/miscellaneous/emmet/약어#문법","content":""},{"title":"요소​","type":1,"pageTitle":"약어","url":"/docs-repository/docs/miscellaneous/emmet/약어#요소","content":"요소의 이름을 그대로 사용해 HTML 태그를 생성할 수 있습니다. 약어: div 복사 div 복사 결과: html &lt;div&gt;&lt;/div&gt; 복사 html &lt;div&gt;&lt;/div&gt; 복사 "},{"title":"중첩 연산자​","type":1,"pageTitle":"약어","url":"/docs-repository/docs/miscellaneous/emmet/약어#중첩-연산자","content":"중첩 연산자는 생성된 트리 내부에 약어 요소를 배치하는 데 사용됩니다. 자식: &gt;​ div&gt;ul&gt;li 복사 div&gt;ul&gt;li 복사 html &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 복사 html &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 복사 형제: +​ div+p+bq 복사 div+p+bq 복사 html &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;blockquote&gt;&lt;/blockquote&gt; 복사 html &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;blockquote&gt;&lt;/blockquote&gt; 복사 등반: ^​ ^ 연산자는 &gt; 연산자와 반대 기능을 합니다. 한 번 사용할 때마다 트리를 한 단계씩 올라갑니다. div+div&gt;p&gt;span+em^^^bq 복사 div+div&gt;p&gt;span+em^^^bq 복사 html &lt;div&gt;&lt;/div&gt; &lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt; &lt;/div&gt; &lt;blockquote&gt;&lt;/blockquote&gt; 복사 html &lt;div&gt;&lt;/div&gt; &lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt; &lt;/div&gt; &lt;blockquote&gt;&lt;/blockquote&gt; 복사 곱하기: *​ ul&gt;li*5 복사 ul&gt;li*5 복사 html &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; 복사 html &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; 복사 그룹화: ()​ 괄호는 복잡한 약어에서 하위 트리를 그룹화할 때 사용합니다. div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p 복사 div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p 복사 html &lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; 복사 html &lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; 복사 * 연산자와 같이 사용할 수 있습니다. (div&gt;dl&gt;(dt+dd)*3)+footer&gt;p 복사 (div&gt;dl&gt;(dt+dd)*3)+footer&gt;p 복사 html &lt;div&gt; &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt; 복사 html &lt;div&gt; &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt; 복사 "},{"title":"속성 연산자​","type":1,"pageTitle":"약어","url":"/docs-repository/docs/miscellaneous/emmet/약어#속성-연산자","content":"아이디와 클래스​ div#header+div.page+div#footer.class1.class2.class3 복사 div#header+div.page+div#footer.class1.class2.class3 복사 html &lt;div id=&quot;header&quot;&gt;&lt;/div&gt; &lt;div class=&quot;page&quot;&gt;&lt;/div&gt; &lt;div id=&quot;footer&quot; class=&quot;class1 class2 class3&quot;&gt;&lt;/div&gt; 복사 html &lt;div id=&quot;header&quot;&gt;&lt;/div&gt; &lt;div class=&quot;page&quot;&gt;&lt;/div&gt; &lt;div id=&quot;footer&quot; class=&quot;class1 class2 class3&quot;&gt;&lt;/div&gt; 복사 사용자 정의 속성​ CSS에서 사용하는 표기법인 [attr]을 사용해 사용자 정의 속성을 요소에 추가할 수 있습니다. td[title=&quot;Hello world!&quot; colspan=3] 복사 td[title=&quot;Hello world!&quot; colspan=3] 복사 html &lt;td title=&quot;Hello world!&quot; colspan=&quot;3&quot;&gt;&lt;/td&gt; 복사 html &lt;td title=&quot;Hello world!&quot; colspan=&quot;3&quot;&gt;&lt;/td&gt; 복사 대괄호 안에 원하는 만큼 속성을 넣을 수 있습니다.속성값을 나중에 지정할 수 있습니다. td[colspan title]의 결과는 &lt;td colspan=&quot;&quot; title=&quot;&quot;&gt;이다. 탭 스탑(tab stop)을 이용해 빈 속성을 이동할 수 있습니다.속성값에 띄어쓰기가 없다면 따옴표로 감싸지 않아도 됩니다. 항목 번호 매기기: $​ 요소의 이름, 속성의 이름, 속성값에 $ 연산자를 사용해서 번호를 매길 수 있습니다. ul&gt;li.item$*5 복사 ul&gt;li.item$*5 복사 html &lt;ul&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item2&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 복사 html &lt;ul&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item2&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 복사 복수의 $을 사용하면 앞에 0을 붙일 수 있습니다. ul&gt;li.item$$$*5 복사 ul&gt;li.item$$$*5 복사 html &lt;ul&gt; &lt;li class=&quot;item001&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item002&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item003&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item004&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item005&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 복사 html &lt;ul&gt; &lt;li class=&quot;item001&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item002&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item003&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item004&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item005&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 복사 @ 수정자를 사용하면 오름차순/내림차순과 시작 값을 지정할 수 있습니다. 내림차순으로 바꾸려면 $ 뒤에 @-을 추가합니다. ul&gt;li.item$@-*5 복사 ul&gt;li.item$@-*5 복사 html &lt;ul&gt; &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item2&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 복사 html &lt;ul&gt; &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item2&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 복사 시작 값을 바꾸려면 $에 @N을 추가합니다. ul&gt;li.item$@-3*5 복사 ul&gt;li.item$@-3*5 복사 html &lt;ul&gt; &lt;li class=&quot;item7&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item6&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 복사 html &lt;ul&gt; &lt;li class=&quot;item7&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item6&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 복사 "},{"title":"텍스트: {}​","type":1,"pageTitle":"약어","url":"/docs-repository/docs/miscellaneous/emmet/약어#텍스트-","content":"중괄호를 사용해 요소에 텍스트를 추가할 수 있습니다. a{Click me} 복사 a{Click me} 복사 html &lt;a href=&quot;&quot;&gt;Click me&lt;/a&gt; 복사 html &lt;a href=&quot;&quot;&gt;Click me&lt;/a&gt; 복사 a{click}와 a&gt;{click}의 결과는 비슷해 보이지만 다른 연산자와 같이 쓰일 때 차이점이 명백해집니다. html &lt;!-- a{click}+b{here} --&gt; &lt;a href=&quot;&quot;&gt;click&lt;/a&gt;&lt;b&gt;here&lt;/b&gt; &lt;!-- a&gt;{click}+b{here} --&gt; &lt;a href=&quot;&quot;&gt;click&lt;b&gt;here&lt;/b&gt;&lt;/a&gt; 복사 html &lt;!-- a{click}+b{here} --&gt; &lt;a href=&quot;&quot;&gt;click&lt;/a&gt;&lt;b&gt;here&lt;/b&gt; &lt;!-- a&gt;{click}+b{here} --&gt; &lt;a href=&quot;&quot;&gt;click&lt;b&gt;here&lt;/b&gt;&lt;/a&gt; 복사 다음은 차이점을 보여주는 또 다른 예시입니다. html &lt;!-- p&gt;{Click }+a{here}+{ to continue} --&gt; &lt;p&gt;Click &lt;a href=&quot;&quot;&gt;here&lt;/a&gt; to continue&lt;/p&gt; &lt;!-- p{Click }+a{here}+{ to continue} --&gt; &lt;p&gt;Click&lt;/p&gt; &lt;a href=&quot;&quot;&gt;here&lt;/a&gt; to continue 복사 html &lt;!-- p&gt;{Click }+a{here}+{ to continue} --&gt; &lt;p&gt;Click &lt;a href=&quot;&quot;&gt;here&lt;/a&gt; to continue&lt;/p&gt; &lt;!-- p{Click }+a{here}+{ to continue} --&gt; &lt;p&gt;Click&lt;/p&gt; &lt;a href=&quot;&quot;&gt;here&lt;/a&gt; to continue 복사 "},{"title":"약어의 형식에 대한 참고 사항​","type":1,"pageTitle":"약어","url":"/docs-repository/docs/miscellaneous/emmet/약어#약어의-형식에-대한-참고-사항","content":"에밋에서 빈 칸은 약어의 파싱을 멈추는 곳입니다. 따라서 가독성을 위해 다음과 같이 빈 칸을 사용하면 의도대로 작동하지 않습니다. (header &gt; ul.nav &gt; li*5) + footer 복사 (header &gt; ul.nav &gt; li*5) + footer 복사 약어는 템플릿 언어가 아닙니다. 따라서 가독성보다는 확장과 제거가 쉬운 것이 더 중요합니다. 텍스트의 아무 곳에서나 약어를 사용할 수 있습니다. 약어를 새 줄에서 사용해야 한다는 제약은 없습니다. 하나의 복잡한 약어를 만드는 대신 짧은 약어를 여러 개 만드는 것이 더 좋습니다. 훨씬 빠르고 오류가 덜 발생합니다. "},{"title":"switch문","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/javascript/switch문","content":"switch문 switch문은 표현식(exp)을 case절과 일치시켜 표현식을 평가하고 break를 만나기 전까지 해당 절의 명령문을 실행한다. js switch (exp) { case value1: // if (exp === value1) ... [break;] case value2: // else if (exp === value2) ... [break;] // 복수의 case문을 묶을 수 있다. case value3: case value4: ... [break;] [default: ... [break;]] } 복사 js switch (exp) { case value1: // if (exp === value1) ... [break;] case value2: // else if (exp === value2) ... [break;] // 복수의 case문을 묶을 수 있다. case value3: case value4: ... [break;] [default: ... [break;]] } 복사 switch문은 일치 연산자(===)로 조건을 확인한다.표현식과 일치하는 case절이 하나도 없다면 default절이 실행된다.case절 안에 break가 없으면 뒤의 case절도 실행된다. 이를 이용해 여러 case문을 묶을 수 있다.다중 else if문을 switch문으로 바꿔서 가독성을 높일 수 있다.","keywords":""},{"title":"객체 복사하기","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/javascript/객체-복사하기","content":"","keywords":""},{"title":"얕은 복사​","type":1,"pageTitle":"객체 복사하기","url":"/docs-repository/docs/miscellaneous/javascript/객체-복사하기#얕은-복사","content":"전개 문법을 사용한다. js const obj = { a: 1, b: 2, c: 3 }; const arr = [1, 2, 3]; const objCopy = { ...obj }; const arrCopy = [ ...arr ]; 복사 js const obj = { a: 1, b: 2, c: 3 }; const arr = [1, 2, 3]; const objCopy = { ...obj }; const arrCopy = [ ...arr ]; 복사 "},{"title":"깊은 복사​","type":1,"pageTitle":"객체 복사하기","url":"/docs-repository/docs/miscellaneous/javascript/객체-복사하기#깊은-복사","content":"JSON.stringify()와 JSON.parse()를 활용한다. js const ingredientsList = ['noodles', { list: ['eggs', 'flour', 'water'] }]; const ingredientsListCopy = JSON.parse(JSON.stringify(ingredientsList)); 복사 js const ingredientsList = ['noodles', { list: ['eggs', 'flour', 'water'] }]; const ingredientsListCopy = JSON.parse(JSON.stringify(ingredientsList)); 복사 이 방법에서는 함수, 심볼형, undefined, Date 등의 값이 손실되거나 변형된다. 대신 structuredClone()이나 로대시의 cloneDeep을 사용할 수 있다. "},{"title":"스타일 프롭","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭","content":"","keywords":""},{"title":"레퍼런스​","type":1,"pageTitle":"스타일 프롭","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭#레퍼런스","content":"다음 표는 모든 스타일 프롭의 목록과 해당하는 CSS 속성을 보여줍니다. "},{"title":"마진과 패딩​","type":1,"pageTitle":"스타일 프롭","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭#마진과-패딩","content":"jsx import { Box } from &quot;@chakra-ui/react&quot; // m={2}는 theme.space[2]의 값을 나타냅니다. &lt;Box m={2}&gt;Tomato&lt;/Box&gt; // 사용자 지정 값을 사용하는 것도 가능합니다. &lt;Box maxW=&quot;960px&quot; mx=&quot;auto&quot; /&gt; // 모든 뷰포트에 마진 8px을 설정하고 첫 번째 중단점 이상에 12px을 설정합니다. &lt;Box m={[2, 3]} /&gt; 복사 jsx import { Box } from &quot;@chakra-ui/react&quot; // m={2}는 theme.space[2]의 값을 나타냅니다. &lt;Box m={2}&gt;Tomato&lt;/Box&gt; // 사용자 지정 값을 사용하는 것도 가능합니다. &lt;Box maxW=&quot;960px&quot; mx=&quot;auto&quot; /&gt; // 모든 뷰포트에 마진 8px을 설정하고 첫 번째 중단점 이상에 12px을 설정합니다. &lt;Box m={[2, 3]} /&gt; 복사 프롭\tCSS 프로퍼티\t테마 키m, margin\tmargin\tspace mt, marginTop\tmargin-top\tspace mr, marginRight\tmargin-right\tspace me, marginEnd\tmargin-inline-end\tspace mb, marginBottom\tmargin-bottom\tspace ml, marginLeft\tmargin-left\tspace ms, marginStart\tmargin-inline-start\tspace mx, marginX\tmargin-inline-start + margin-inline-end\tspace my, marginY\tmargin-top + margin-bottom\tspace p, padding\tpadding\tspace pt, paddingTop\tpadding-top\tspace pr, paddingRight\tpadding-right\tspace pe, paddingEnd\tpadding-inline-end\tspace pb, paddingBottom\tpadding-bottom\tspace pl, paddingLeft\tpadding-left\tspace ps, paddingStart\tpadding-inline-start\tspace px, paddingX\tpadding-inline-start + padding-inline-end\tspace py, paddingY\tpadding-top + padding-bottom\tspace 참고 mx와 px 프롭은 생성된 스타일이 RTL 친화적임을 보장하기 위해 margin-inline-start 및 margin-inline-end를 사용합니다. "},{"title":"색상과 배경색​","type":1,"pageTitle":"스타일 프롭","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭#색상과-배경색","content":"jsx import { Box } from &quot;@chakra-ui/react&quot; // 점 표기법을 사용하여 중첩된 색상 값을 선택합니다. // =&gt; `theme.colors.gray[50]` &lt;Box color='gray.50' /&gt; // 원시 CSS 색상 값 &lt;Box color='#f00' /&gt; // 배경색 &lt;Box bg='tomato' /&gt; // 장황한 프롭 &lt;Box backgroundColor='tomato' /&gt; 복사 jsx import { Box } from &quot;@chakra-ui/react&quot; // 점 표기법을 사용하여 중첩된 색상 값을 선택합니다. // =&gt; `theme.colors.gray[50]` &lt;Box color='gray.50' /&gt; // 원시 CSS 색상 값 &lt;Box color='#f00' /&gt; // 배경색 &lt;Box bg='tomato' /&gt; // 장황한 프롭 &lt;Box backgroundColor='tomato' /&gt; 복사 프롭\tCSS 프로퍼티\t테마 키color\tcolor\tcolors bg, background\tbackground\tcolors bgColor\tbackground-color\tcolors opacity\topacity\t없음 "},{"title":"그레이디언트​","type":1,"pageTitle":"스타일 프롭","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭#그레이디언트","content":"jsx import { Box, Text } from &quot;@chakra-ui/react&quot; // 선형 그레이디언트와 색상 트랜지션을 추가합니다. &lt;Box w=&quot;100%&quot; h=&quot;200px&quot; bgGradient=&quot;linear(to-t, green.200, pink.500)&quot; /&gt; // 방사형 그레이디언트와 색상 트랜지션을 추가합니다. &lt;Box w=&quot;100%&quot; h=&quot;200px&quot; bgGradient=&quot;radial(gray.300, yellow.400, pink.200)&quot; /&gt; // 텍스트 그레이디언트를 추가합니다. &lt;Text bgGradient=&quot;linear(to-l, #7928CA, #FF0080)&quot; bgClip=&quot;text&quot; fontSize=&quot;6xl&quot; fontWeight=&quot;extrabold&quot; &gt; Welcome to Chakra UI &lt;/Text&gt; 복사 jsx import { Box, Text } from &quot;@chakra-ui/react&quot; // 선형 그레이디언트와 색상 트랜지션을 추가합니다. &lt;Box w=&quot;100%&quot; h=&quot;200px&quot; bgGradient=&quot;linear(to-t, green.200, pink.500)&quot; /&gt; // 방사형 그레이디언트와 색상 트랜지션을 추가합니다. &lt;Box w=&quot;100%&quot; h=&quot;200px&quot; bgGradient=&quot;radial(gray.300, yellow.400, pink.200)&quot; /&gt; // 텍스트 그레이디언트를 추가합니다. &lt;Text bgGradient=&quot;linear(to-l, #7928CA, #FF0080)&quot; bgClip=&quot;text&quot; fontSize=&quot;6xl&quot; fontWeight=&quot;extrabold&quot; &gt; Welcome to Chakra UI &lt;/Text&gt; 복사 프롭\tCSS 프로퍼티\t테마 키bgGradient\tbackground-image\t없음 bgClip, backgroundClip\tbackground-clip\t없음 "},{"title":"타이포그래피​","type":1,"pageTitle":"스타일 프롭","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭#타이포그래피","content":"jsx import { Text } from &quot;@chakra-ui/react&quot; // theme.fontSizes.md의 font-size &lt;Text fontSize=&quot;md&quot; /&gt; // font-size 32px &lt;Text fontSize={32} /&gt; // font-size 2em &lt;Text fontSize='2em' /&gt; // 모든 뷰포트에 text-align left를 설정하고 첫 번째 중단점 이상에 center를 설정합니다. &lt;Text textAlign={[ 'left', 'center' ]} /&gt; 복사 jsx import { Text } from &quot;@chakra-ui/react&quot; // theme.fontSizes.md의 font-size &lt;Text fontSize=&quot;md&quot; /&gt; // font-size 32px &lt;Text fontSize={32} /&gt; // font-size 2em &lt;Text fontSize='2em' /&gt; // 모든 뷰포트에 text-align left를 설정하고 첫 번째 중단점 이상에 center를 설정합니다. &lt;Text textAlign={[ 'left', 'center' ]} /&gt; 복사 프롭\tCSS 프로퍼티\t테마 키fontFamily\tfont-family\tfonts fontSize\tfont-size\tfontSizes fontWeight\tfont-weight\tfontWeights lineHeight\tline-height\tlineHeights letterSpacing\tletter-spacing\tletterSpacings textAlign\ttext-align\t없음 fontStyle\tfont-style\t없음 textTransform\ttext-transform\t없음 textDecoration\ttext-decoration\t없음 "},{"title":"레이아웃, 너비와 높이​","type":1,"pageTitle":"스타일 프롭","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭#레이아웃-너비와-높이","content":"jsx import { Box } from &quot;@chakra-ui/react&quot; // 장황함 &lt;Box width=&quot;100%&quot; height={32} /&gt; // 약칭 &lt;Box w=&quot;100%&quot; h=&quot;32px&quot; /&gt; // 테마의 크기 사용 &lt;Box boxSize=&quot;sm&quot; /&gt; // 너비 256px &lt;Box w={256} /&gt; // 너비 40px &lt;Box w='40px' /&gt; 복사 jsx import { Box } from &quot;@chakra-ui/react&quot; // 장황함 &lt;Box width=&quot;100%&quot; height={32} /&gt; // 약칭 &lt;Box w=&quot;100%&quot; h=&quot;32px&quot; /&gt; // 테마의 크기 사용 &lt;Box boxSize=&quot;sm&quot; /&gt; // 너비 256px &lt;Box w={256} /&gt; // 너비 40px &lt;Box w='40px' /&gt; 복사 프롭\tCSS 프로퍼티\t테마 키w, width\twidth\tsizes h, height\theight\tsizes minW, minWidth\tmin-width\tsizes maxW, maxWidth\tmax-width\tsizes minH, minHeight\tmin-height\tsizes maxH, maxHeight\tmax-height\tsizes display\tdisplay\t없음 boxSize\twidth, height\tsizes verticalAlign\tvertical-align\t없음 overflow\toverflow\t없음 overflowX\toverflow-x\t없음 overflowY\toverflow-y\t없음 "},{"title":"플렉스박스​","type":1,"pageTitle":"스타일 프롭","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭#플렉스박스","content":"jsx import { Box, Flex } from &quot;@chakra-ui/react&quot; // 장황함 &lt;Box display=&quot;flex&quot; alignItems=&quot;center&quot; justifyContent=&quot;space-between&quot;&gt; Box with Flex props &lt;/Box&gt; // Flex 컴포넌트를 이용한 약칭 &lt;Flex align=&quot;center&quot; justify=&quot;center&quot;&gt; Flex Container &lt;/Flex&gt; 복사 jsx import { Box, Flex } from &quot;@chakra-ui/react&quot; // 장황함 &lt;Box display=&quot;flex&quot; alignItems=&quot;center&quot; justifyContent=&quot;space-between&quot;&gt; Box with Flex props &lt;/Box&gt; // Flex 컴포넌트를 이용한 약칭 &lt;Flex align=&quot;center&quot; justify=&quot;center&quot;&gt; Flex Container &lt;/Flex&gt; 복사 참고 * 프롭은 Flex 컴포넌트를 사용할 때만 작동합니다. 프롭\tCSS 프로퍼티\t테마 키gap\tgap\tspace rowGap\trow-gap\tspace columnGap\tcolumn-gap\tspace alignItems, *align\talign-items\t없음 alignContent\talign-content\t없음 justifyItems\tjustify-items\t없음 justifyContent, *justify\tjustify-content\t없음 flexWrap, *wrap\tflex-wrap\t없음 flexDirection, flexDir, *direction\tflex-direction\t없음 flex\tflex\t없음 flexGrow\tflex-grow\t없음 flexShrink\tflex-shrink\t없음 flexBasis\tflex-basis\t없음 justifySelf\tjustify-self\t없음 alignSelf\talign-self\t없음 order\torder\t없음 "},{"title":"그리드 레이아웃​","type":1,"pageTitle":"스타일 프롭","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭#그리드-레이아웃","content":"jsx import { Box, Grid } from &quot;@chakra-ui/react&quot; // 장황함 &lt;Box display=&quot;grid&quot; gridGap={2} gridAutoFlow=&quot;row dense&quot;&gt; Grid &lt;/Box&gt; // Grid 컴포넌트를 이용한 약칭 &lt;Grid gap={2} autoFlow=&quot;row dense&quot;&gt; Grid &lt;/Grid&gt; 복사 jsx import { Box, Grid } from &quot;@chakra-ui/react&quot; // 장황함 &lt;Box display=&quot;grid&quot; gridGap={2} gridAutoFlow=&quot;row dense&quot;&gt; Grid &lt;/Box&gt; // Grid 컴포넌트를 이용한 약칭 &lt;Grid gap={2} autoFlow=&quot;row dense&quot;&gt; Grid &lt;/Grid&gt; 복사 참고 * 프롭은 Grid 컴포넌트를 사용할 때만 작동합니다. 프롭\tCSS 프로퍼티\t테마 키gridGap, *gap\tgrid-gap\tspace gridRowGap, *rowGap\tgrid-row-gap\tspace gridColumnGap, *columnGap\tgrid-column-gap\tspace gridColumn, *column\tgrid-column\t없음 gridRow, *row\tgrid-row\t없음 gridArea, *area\tgrid-area\t없음 gridAutoFlow, *autoFlow\tgrid-auto-flow\t없음 gridAutoRows, *autoRows\tgrid-auto-rows\t없음 gridAutoColumns, *autoColumns\tgrid-auto-columns\t없음 gridTemplateRows, *templateRows\tgrid-template-rows\t없음 gridTemplateColumns, *templateColumns\tgrid-template-columns\t없음 gridTemplateAreas, *templateAreas\tgrid-template-areas\t없음 "},{"title":"배경​","type":1,"pageTitle":"스타일 프롭","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭#배경","content":"jsx import { Box } from &quot;@chakra-ui/react&quot; // 장황함 &lt;Box backgroundImage=&quot;url('/images/kyuubi.png')&quot; backgroundPosition=&quot;center&quot; backgroundRepeat=&quot;no-repeat&quot; /&gt; // 약칭 &lt;Box bgImage=&quot;url('/images/gaara.png')&quot; bgPosition=&quot;center&quot; bgRepeat=&quot;no-repeat&quot; /&gt; 복사 jsx import { Box } from &quot;@chakra-ui/react&quot; // 장황함 &lt;Box backgroundImage=&quot;url('/images/kyuubi.png')&quot; backgroundPosition=&quot;center&quot; backgroundRepeat=&quot;no-repeat&quot; /&gt; // 약칭 &lt;Box bgImage=&quot;url('/images/gaara.png')&quot; bgPosition=&quot;center&quot; bgRepeat=&quot;no-repeat&quot; /&gt; 복사 프롭\tCSS 프로퍼티\t테마 키bg, background\tbackground\t없음 bgImage, backgroundImage\tbackground-image\t없음 bgSize, backgroundSize\tbackground-size\t없음 bgPosition, backgroundPosition\tbackground-position\t없음 bgRepeat, backgroundRepeat\tbackground-repeat\t없음 bgAttachment, backgroundAttachment\tbackground-attachment\t없음 "},{"title":"테두리​","type":1,"pageTitle":"스타일 프롭","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭#테두리","content":"jsx &lt;Box border='1px' borderColor='gray.200'&gt; Card &lt;/Box&gt; 복사 jsx &lt;Box border='1px' borderColor='gray.200'&gt; Card &lt;/Box&gt; 복사 프롭\tCSS 프로퍼티\t테마 필드border\tborder\tborders borderWidth\tborder-width\tborderWidths borderStyle\tborder-style\tborderStyles borderColor\tborder-color\tcolors borderTop\tborder-top\tborders borderTopWidth\tborder-top-width\tborderWidths borderTopStyle\tborder-top-style\tborderStyles borderTopColor\tborder-top-color\tcolors borderRight\tborder-right\tborders borderEnd\tborder-inline-end\tborders borderRightWidth\tborder-right-width\tborderWidths borderEndWidth\tborder-inline-end-width\tborderWidths borderRightStyle\tborder-right-style\tborderStyles borderEndStyle\tborder-inline-end-style\tborderStyles borderRightColor\tborder-right-color\tcolors borderEndColor\tborder-inline-end-color\tcolors borderBottom\tborder-bottom\tborders borderBottomWidth\tborder-bottom-width\tborderWidths borderBottomStyle\tborder-bottom-style\tborderStyles borderBottomColor\tborder-bottom-color\tcolors borderLeft\tborder-left\tborders borderStart\tborder-inline-start\tborders borderLeftWidth\tborder-left-width\tborderWidths borderStartWidth\tborder-inline-start-width\tborderWidths borderLeftStyle\tborder-left-style\tborderStyles borderStartStyle\tborder-inline-start-style\tborderStyles borderLeftColor\tborder-left-color\tcolors borderStartColor\tborder-inline-start-color\tcolors borderX\tborder-left , border-right\tborders borderY\tborder-top , border-bottom\tborders "},{"title":"테두리 반경​","type":1,"pageTitle":"스타일 프롭","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭#테두리-반경","content":"jsx import { Button } from &quot;@chakra-ui/react&quot; // 이 버튼은 오른쪽 borderRadius가 없습니다. &lt;Button borderRightRadius=&quot;0&quot;&gt;Button 1&lt;/Button&gt; // 이 버튼은 왼쪽 borderRadius가 없습니다. &lt;Button borderLeftRadius=&quot;0&quot;&gt;Button 2&lt;/Button&gt; // 왼쪽 상단과 오른쪽 상단 반경은 theme.radii.md =&gt; 4px가 됩니다. &lt;Button borderTopRadius=&quot;md&quot;&gt;Button 2&lt;/Button&gt; 복사 jsx import { Button } from &quot;@chakra-ui/react&quot; // 이 버튼은 오른쪽 borderRadius가 없습니다. &lt;Button borderRightRadius=&quot;0&quot;&gt;Button 1&lt;/Button&gt; // 이 버튼은 왼쪽 borderRadius가 없습니다. &lt;Button borderLeftRadius=&quot;0&quot;&gt;Button 2&lt;/Button&gt; // 왼쪽 상단과 오른쪽 상단 반경은 theme.radii.md =&gt; 4px가 됩니다. &lt;Button borderTopRadius=&quot;md&quot;&gt;Button 2&lt;/Button&gt; 복사 프롭\tCSS 프로퍼티\t테마 필드borderRadius\tborder-radius\tradii borderTopLeftRadius\tborder-top-left-radius\tradii borderTopStartRadius\tborder-top-left-radius in LTR, border-top-right-radius in RTL\tradii borderTopRightRadius\tborder-top-right-radius\tradii borderTopEndRadius\tborder-top-right-radius in LTR, border-top-left-radius in RTL\tradii borderBottomRightRadius\tborder-bottom-right-radius\tradii borderBottomEndRadius\tborder-bottom-right-radius in LTR, border-bottom-left-radius in RTL\tradii borderBottomLeftRadius\tborder-bottom-left-radius\tradii borderBottomStartRadius\tborder-bottom-left-radius in LTR, border-bottom-left-radius in RTL\tradii borderTopRadius\tborder-top-left-radius + border-top-right-radius\tradii borderRightRadius\tborder-top-right-radius + border-bottom-right-radius\tradii borderEndRadius\tborder-top-right-radius + border-bottom-right-radius\tradii borderBottomRadius\tborder-bottom-left-radius + border-bottom-right-radius\tradii borderLeftRadius\tborder-top-left-radius + border-bottom-left-radius\tradii borderStartRadius\tborder-top-left-radius + border-bottom-left-radius\tradii "},{"title":"위치​","type":1,"pageTitle":"스타일 프롭","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭#위치","content":"jsx import { Box } from &quot;@chakra-ui/react&quot; // 장황함 &lt;Box position=&quot;absolute&quot;&gt;Cover&lt;/Box&gt; // 약칭 &lt;Box pos=&quot;absolute&quot;&gt;Cover&lt;/Box&gt; &lt;Box pos=&quot;absolute&quot; top=&quot;0&quot; left=&quot;0&quot;&gt; Absolute with top and left &lt;/Box&gt; &lt;Box pos=&quot;fixed&quot; w=&quot;100%&quot; zIndex={2}&gt; Fixed with zIndex &lt;/Box&gt; 복사 jsx import { Box } from &quot;@chakra-ui/react&quot; // 장황함 &lt;Box position=&quot;absolute&quot;&gt;Cover&lt;/Box&gt; // 약칭 &lt;Box pos=&quot;absolute&quot;&gt;Cover&lt;/Box&gt; &lt;Box pos=&quot;absolute&quot; top=&quot;0&quot; left=&quot;0&quot;&gt; Absolute with top and left &lt;/Box&gt; &lt;Box pos=&quot;fixed&quot; w=&quot;100%&quot; zIndex={2}&gt; Fixed with zIndex &lt;/Box&gt; 복사 프롭\tCSS 프로퍼티\t테마 필드pos, position\tposition\t없음 zIndex\tz-index\tzIndices top\ttop\tspace right\tright\tspace bottom\tbottom\tspace left\tleft\tspace "},{"title":"그림자​","type":1,"pageTitle":"스타일 프롭","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭#그림자","content":"jsx &lt;SimpleGrid bg='gray.50' columns={{ sm: 2, md: 4 }} spacing='8' p='10' textAlign='center' rounded='lg' color='gray.400' &gt; &lt;Box boxShadow='xs' p='6' rounded='md' bg='white'&gt; xs &lt;/Box&gt; &lt;Box boxShadow='sm' p='6' rounded='md' bg='white'&gt; sm &lt;/Box&gt; &lt;Box boxShadow='base' p='6' rounded='md' bg='white'&gt; Base &lt;/Box&gt; &lt;Box boxShadow='md' p='6' rounded='md' bg='white'&gt; md &lt;/Box&gt; &lt;Box boxShadow='lg' p='6' rounded='md' bg='white'&gt; lg &lt;/Box&gt; &lt;Box boxShadow='xl' p='6' rounded='md' bg='white'&gt; xl &lt;/Box&gt; &lt;Box boxShadow='2xl' p='6' rounded='md' bg='white'&gt; 2xl &lt;/Box&gt; &lt;Box boxShadow='dark-lg' p='6' rounded='md' bg='white'&gt; Dark lg &lt;/Box&gt; &lt;Box boxShadow='outline' p='6' rounded='md' bg='white'&gt; Outline &lt;/Box&gt; &lt;Box boxShadow='inner' p='6' rounded='md' bg='white'&gt; Inner &lt;/Box&gt; &lt;/SimpleGrid&gt; 복사 jsx &lt;SimpleGrid bg='gray.50' columns={{ sm: 2, md: 4 }} spacing='8' p='10' textAlign='center' rounded='lg' color='gray.400' &gt; &lt;Box boxShadow='xs' p='6' rounded='md' bg='white'&gt; xs &lt;/Box&gt; &lt;Box boxShadow='sm' p='6' rounded='md' bg='white'&gt; sm &lt;/Box&gt; &lt;Box boxShadow='base' p='6' rounded='md' bg='white'&gt; Base &lt;/Box&gt; &lt;Box boxShadow='md' p='6' rounded='md' bg='white'&gt; md &lt;/Box&gt; &lt;Box boxShadow='lg' p='6' rounded='md' bg='white'&gt; lg &lt;/Box&gt; &lt;Box boxShadow='xl' p='6' rounded='md' bg='white'&gt; xl &lt;/Box&gt; &lt;Box boxShadow='2xl' p='6' rounded='md' bg='white'&gt; 2xl &lt;/Box&gt; &lt;Box boxShadow='dark-lg' p='6' rounded='md' bg='white'&gt; Dark lg &lt;/Box&gt; &lt;Box boxShadow='outline' p='6' rounded='md' bg='white'&gt; Outline &lt;/Box&gt; &lt;Box boxShadow='inner' p='6' rounded='md' bg='white'&gt; Inner &lt;/Box&gt; &lt;/SimpleGrid&gt; 복사 jsx &lt;Text textShadow='1px 1px #ff0000' m='6'&gt; Text with shadows &lt;/Text&gt; 복사 jsx &lt;Text textShadow='1px 1px #ff0000' m='6'&gt; Text with shadows &lt;/Text&gt; 복사 프롭\tCSS 프로퍼티\t테마 필드textShadow\ttext-shadow\tshadows shadow, boxShadow\tbox-shadow\tshadows "},{"title":"필터​","type":1,"pageTitle":"스타일 프롭","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭#필터","content":"jsx function Filters() { const basicBoxStyles = { display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', boxSize: '250px', color: 'white', textShadow: '0 0 20px black', fontWeight: 'bold', fontSize: '20px', px: 4, background: 'url(https://picsum.photos/id/1080/200/300) center/cover no-repeat', } return ( &lt;Flex flexWrap='wrap' gap='24px' justifyContent='space-evenly'&gt; {/* 요소에 filter 프로퍼티 추가하기 */} &lt;Box sx={basicBoxStyles} filter='grayscale(80%)'&gt; Box with Filter &lt;/Box&gt; {/* 요소에 blur 프로퍼티 추가하기 */} &lt;Box sx={basicBoxStyles} filter='auto' blur='2px'&gt; Box with Blur &lt;/Box&gt; {/* 요소에 brightness 프로퍼티 추가하기 */} &lt;Box sx={basicBoxStyles} filter='auto' brightness='40%'&gt; Box with Brightness &lt;/Box&gt; &lt;/Flex&gt; ) } 복사 jsx function Filters() { const basicBoxStyles = { display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', boxSize: '250px', color: 'white', textShadow: '0 0 20px black', fontWeight: 'bold', fontSize: '20px', px: 4, background: 'url(https://picsum.photos/id/1080/200/300) center/cover no-repeat', } return ( &lt;Flex flexWrap='wrap' gap='24px' justifyContent='space-evenly'&gt; {/* 요소에 filter 프로퍼티 추가하기 */} &lt;Box sx={basicBoxStyles} filter='grayscale(80%)'&gt; Box with Filter &lt;/Box&gt; {/* 요소에 blur 프로퍼티 추가하기 */} &lt;Box sx={basicBoxStyles} filter='auto' blur='2px'&gt; Box with Blur &lt;/Box&gt; {/* 요소에 brightness 프로퍼티 추가하기 */} &lt;Box sx={basicBoxStyles} filter='auto' brightness='40%'&gt; Box with Brightness &lt;/Box&gt; &lt;/Flex&gt; ) } 복사 참고 요소에 blur, brightness, contrast, hueRotate, invert,saturate 프롭을 적용하려면, filter 프롭의 값을 auto로 지정합니다. jsx function BackdropFilters() { const outerBoxStyles = { boxSize: '250px', p: '10', background: 'url(https://picsum.photos/id/1068/200/300) center/cover no-repeat', } const innerBoxStyles = { display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', boxSize: 'full', color: 'white', textShadow: '0 0 20px black', fontWeight: 'bold', fontSize: '20px', } return ( &lt;Flex flexWrap='wrap' gap='24px' justifyContent='space-evenly'&gt; {/* 요소에 backdrop-filter 프로퍼티 추가하기 */} &lt;Box sx={outerBoxStyles}&gt; &lt;Box sx={innerBoxStyles} backdropFilter='invert(100%)'&gt; Box with Backdrop Filter &lt;/Box&gt; &lt;/Box&gt; {/* 요소에 backdrop-blur 프로퍼티 추가하기 */} &lt;Box sx={outerBoxStyles}&gt; &lt;Box sx={innerBoxStyles} backdropFilter='auto' backdropBlur='8px'&gt; Box with Backdrop Blur &lt;/Box&gt; &lt;/Box&gt; {/* 요소에 backdrop-contrast 프로퍼티 추가하기 */} &lt;Box sx={outerBoxStyles}&gt; &lt;Box sx={innerBoxStyles} backdropFilter='auto' backdropContrast='30%'&gt; Box with Backdrop Contrast &lt;/Box&gt; &lt;/Box&gt; &lt;/Flex&gt; ) } 복사 jsx function BackdropFilters() { const outerBoxStyles = { boxSize: '250px', p: '10', background: 'url(https://picsum.photos/id/1068/200/300) center/cover no-repeat', } const innerBoxStyles = { display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', boxSize: 'full', color: 'white', textShadow: '0 0 20px black', fontWeight: 'bold', fontSize: '20px', } return ( &lt;Flex flexWrap='wrap' gap='24px' justifyContent='space-evenly'&gt; {/* 요소에 backdrop-filter 프로퍼티 추가하기 */} &lt;Box sx={outerBoxStyles}&gt; &lt;Box sx={innerBoxStyles} backdropFilter='invert(100%)'&gt; Box with Backdrop Filter &lt;/Box&gt; &lt;/Box&gt; {/* 요소에 backdrop-blur 프로퍼티 추가하기 */} &lt;Box sx={outerBoxStyles}&gt; &lt;Box sx={innerBoxStyles} backdropFilter='auto' backdropBlur='8px'&gt; Box with Backdrop Blur &lt;/Box&gt; &lt;/Box&gt; {/* 요소에 backdrop-contrast 프로퍼티 추가하기 */} &lt;Box sx={outerBoxStyles}&gt; &lt;Box sx={innerBoxStyles} backdropFilter='auto' backdropContrast='30%'&gt; Box with Backdrop Contrast &lt;/Box&gt; &lt;/Box&gt; &lt;/Flex&gt; ) } 복사 주의 backdrop-filter는 파이어폭스에서 지원되지 않습니다. 사용자가 활성화할 수 있지만, 해당 프로퍼티의 유무에 상관없이 보기 좋은 컴포넌트를 설계하는 것이 좋습니다. 참고 요소에 backdropBlur, backdropBrightness, backdropContrast, backdropHueRotate, backdropInvert, backdropSaturate 프롭을 적용하려면, backdropFilter 프롭의 값을 auto로 지정합니다. 프롭\tCSS 프로퍼티\t테마 필드filter\tfilter\t없음 blur\tfilter\tblur brightness\tfilter\t없음 contrast\tfilter\t없음 hueRotate\tfilter\t없음 invert\tfilter\t없음 saturate\tfilter\t없음 dropShadow\tfilter\tshadows backdropFilter\tbackdrop-filter\t없음 backdropBlur\tbackdrop-filter\tblur backdropBrightness\tbackdrop-filter\t없음 backdropContrast\tbackdrop-filter\t없음 backdropHueRotate\tbackdrop-filter\t없음 backdropInvert\tbackdrop-filter\t없음 backdropSaturate\tbackdrop-filter\t없음 "},{"title":"의사​","type":1,"pageTitle":"스타일 프롭","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭#의사","content":"jsx import { Button } from &quot;@chakra-ui/react&quot; // :hover 스타일 &lt;Button colorScheme=&quot;teal&quot; _hover={{ background: &quot;white&quot;, color: &quot;teal.500&quot;, }} &gt; Hover me &lt;/Button&gt; // 부모 요소에 :hover를 적용합니다. &lt;Box role=&quot;group&quot; &gt; &lt;Box _hover={{ fontWeight: 'semibold' }} _groupHover={{ color: 'tomato' }} &gt; &lt;/Box&gt; &lt;/Box&gt; // ::before 의사 요소를 추가합니다. // 콘텐츠 값에는 추가 따옴표가 필요하다는 것을 유의하세요. &lt;Box _before={{ content: '&quot;🙂&quot;', display: 'inline-block', mr: '5px' }} &gt; A pseudo element &lt;/Box&gt; 복사 jsx import { Button } from &quot;@chakra-ui/react&quot; // :hover 스타일 &lt;Button colorScheme=&quot;teal&quot; _hover={{ background: &quot;white&quot;, color: &quot;teal.500&quot;, }} &gt; Hover me &lt;/Button&gt; // 부모 요소에 :hover를 적용합니다. &lt;Box role=&quot;group&quot; &gt; &lt;Box _hover={{ fontWeight: 'semibold' }} _groupHover={{ color: 'tomato' }} &gt; &lt;/Box&gt; &lt;/Box&gt; // ::before 의사 요소를 추가합니다. // 콘텐츠 값에는 추가 따옴표가 필요하다는 것을 유의하세요. &lt;Box _before={{ content: '&quot;🙂&quot;', display: 'inline-block', mr: '5px' }} &gt; A pseudo element &lt;/Box&gt; 복사 프롭\tCSS 프로퍼티\t테마 필드_hover\t&amp;:hover &amp;[data-hover]\t없음 _active\t&amp;:active &amp;[data-active]\t없음 _focus\t&amp;:focus &amp;[data-focus]\t없음 _highlighted\t&amp;[data-highlighted]\t없음 _focusWithin\t&amp;:focus-within\t없음 _focusVisible\t&amp;:focus-visible\t없음 _disabled\t&amp;[disabled] &amp;[aria-disabled=true] &amp;[data-disabled]\t없음 _readOnly\t&amp;[aria-readonly=true] &amp;[readonly] &amp;[data-readonly]\t없음 _before\t&amp;::before\t없음 _after\t&amp;::after\t없음 _empty\t&amp;:empty\t없음 _expanded\t&amp;[aria-expanded=true] &amp;[data-expanded]\t없음 _checked\t&amp;[aria-checked=true] &amp;[data-checked]\t없음 _grabbed\t&amp;[aria-grabbed=true] &amp;[data-grabbed]\t없음 _pressed\t&amp;[aria-pressed=true] &amp;[data-pressed]\t없음 _invalid\t&amp;[aria-invalid=true] &amp;[data-invalid]\t없음 _valid\t&amp;[data-valid] &amp;[data-state=valid]\t없음 _loading\t&amp;[data-loading] &amp;[aria-busy=true]\t없음 _selected\t&amp;[aria-selected=true] &amp;[data-selected]\t없음 _hidden\t&amp;[hidden] &amp;[data-hidden]\t없음 _autofill\t&amp;:-webkit-autofill\t없음 _even\t&amp;:nth-of-type(even)\t없음 _odd\t&amp;:nth-of-type(odd)\t없음 _first\t&amp;:first-of-type\t없음 _last\t&amp;:last-of-type\t없음 _notFirst\t&amp;:not(:first-of-type)\t없음 _notLast\t&amp;:not(:last-of-type)\t없음 _visited\t&amp;:visited\t없음 _activeLink\t&amp;[aria-current=page]\t없음 _activeStep\t&amp;[aria-current=step]\t없음 _indeterminate\t&amp;:indeterminate &amp;[aria-checked=mixed] &amp;[data-indeterminate]\t없음 _groupHover\t[role=group]:hover &amp; [role=group][data-hover] &amp; [data-group]:hover &amp; [data-group][data-hover] &amp; .group:hover &amp; .group[data-hover] &amp;\t없음 _peerHover\t[data-peer]:hover ~ &amp; [data-peer][data-hover] ~ &amp; .peer:hover ~ &amp; .peer[data-hover] ~ &amp;\t없음 _groupFocus\t[role=group]:focus &amp; [role=group][data-focus] &amp; [data-group]:focus &amp; [data-group][data-focus] &amp; .group:focus &amp; .group[data-focus] &amp;\t없음 _peerFocus\t[data-peer]:focus ~ &amp; [data-peer][data-focus] ~ &amp; .peer:focus ~ &amp; .peer[data-focus] ~ &amp;\t없음 _groupFocusVisible\t[role=group]:focus-visible &amp; [data-group]:focus-visible &amp; .group:focus-visible &amp;\t없음 _peerFocusVisible\t[data-peer]:focus-visible ~ &amp; .peer:focus-visible ~ &amp;\t없음 _groupActive\t[role=group]:active &amp; [role=group][data-active] &amp; [data-group]:active &amp; [data-group][data-active] &amp; .group:active &amp; .group[data-active] &amp;\t없음 _peerActive\t[data-peer]:active ~ &amp; [data-peer][data-active] ~ &amp; .peer:active ~ &amp; .peer[data-active] ~ &amp;\t없음 _groupDisabled\t[role=group]:disabled &amp; [role=group][data-disabled] &amp; [data-group]:disabled &amp; [data-group][data-disabled] &amp; .group:disabled &amp; .group[data-disabled] &amp;\t없음 _peerDisabled\t[data-peer]:disabled ~ &amp; [data-peer][data-disabled] ~ &amp; .peer:disabled ~ &amp; .peer[data-disabled] ~ &amp;\t없음 _groupInvalid\t[role=group]:invalid &amp; [role=group][data-invalid] &amp; [data-group]:invalid &amp; [data-group][data-invalid] &amp; .group:invalid &amp; .group[data-invalid] &amp;\t없음 _peerInvalid\t[data-peer]:invalid ~ &amp; [data-peer][data-invalid] ~ &amp; .peer:invalid ~ &amp; .peer[data-invalid] ~ &amp;\t없음 _groupChecked\t[role=group]:checked &amp; [role=group][data-checked] &amp; [data-group]:checked &amp; [data-group][data-checked] &amp; .group:checked &amp; .group[data-checked] &amp;\t없음 _peerChecked\t[data-peer]:checked ~ &amp; [data-peer][data-checked] ~ &amp; .peer:checked ~ &amp; .peer[data-checked] ~ &amp;\t없음 _groupFocusWithin\t[role=group]:focus-within &amp; [data-group]:focus-within &amp; .group:focus-within &amp;\t없음 _peerFocusWithin\t[data-peer]:focus-within ~ &amp; .peer:focus-within ~ &amp;\t없음 _peerPlaceholderShown\t[data-peer]:placeholder-shown ~ &amp; .peer:placeholder-shown ~ &amp;\t없음 _placeholder\t&amp;::placeholder\t없음 _placeholderShown\t&amp;:placeholder-shown\t없음 _fullScreen\t&amp;:fullscreen\t없음 _selection\t&amp;::selection\t없음 _rtl\t[dir=rtl] &amp; &amp;[dir=rtl]\t없음 _ltr\t[dir=ltr] &amp; &amp;[dir=ltr]\t없음 _mediaDark\t@media (prefers-color-scheme: dark)\t없음 _mediaReduceMotion\t@media (prefers-reduced-motion: reduce)\t없음 _dark\t.chakra-ui-dark &amp; [data-theme=dark] &amp; &amp;[data-theme=dark]\t없음 _light\t.chakra-ui-light &amp; [data-theme=light] &amp; &amp;[data-theme=light]\t없음 "},{"title":"기타 프롭​","type":1,"pageTitle":"스타일 프롭","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭#기타-프롭","content":"위에 나열된 모든 공통 스타일 프롭을 제외하고, 모든 컴포넌트는 다음 프롭을 허용합니다. 프롭\tCSS 프로퍼티\t테마 필드animation\tanimation\t없음 appearance\tappearance\t없음 content\tcontent\t없음 transform\ttransform\t없음 transformOrigin\ttransform-origin\t없음 visibility\tvisibility\t없음 whiteSpace\twhite-space\t없음 userSelect\tuser-select\t없음 pointerEvents\tpointer-events\t없음 wordBreak\tword-break\t없음 overflowWrap\toverflow-wrap\t없음 textOverflow\ttext-overflow\t없음 boxSizing\tbox-sizing\t없음 cursor\tcursor\t없음 resize\tresize\t없음 transition\ttransition\t없음 objectFit\tobject-fit\t없음 objectPosition\tobject-position\t없음 float\tfloat\t없음 fill\tfill\tcolors stroke\tstroke\tcolors outline\toutline\t없음 "},{"title":"as 프롭​","type":1,"pageTitle":"스타일 프롭","url":"/docs-repository/docs/miscellaneous/chakra-ui/스타일-프롭#as-프롭","content":"as 프롭을 이용하면 렌더링할 HTML 태그 또는 컴포넌트를 전달할 수 있습니다. 모든 컴포넌트에서 사용 가능합니다. 예를 들어 Button 컴포넌트를 링크로 사용하고 싶다고 가정해 보겠습니다. a와 Button을 다음과 같이 구성할 수 있습니다. jsx &lt;Button as='a' target='_blank' variant='outline' href='https://chakra-ui.com'&gt; Hello &lt;/Button&gt; 복사 jsx &lt;Button as='a' target='_blank' variant='outline' href='https://chakra-ui.com'&gt; Hello &lt;/Button&gt; 복사 이를 통해 버튼을 a 컴포넌트로 감싸지 않고도 모든 Button 프롭과 a 프롭을 사용할 수 있게 됩니다. "},{"title":"명시적 형 변환하기","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/javascript/명시적-형-변환하기","content":"명시적 형 변환하기 다양한 방법이 있지만 가독성을 위해 각 타입의 생성자 함수를 사용하는 것이 좋다. String()Number()Boolean() js const str = String(123); // '123' const num = Number('123'); // 123 const boolean = Boolean(null); // false 복사 js const str = String(123); // '123' const num = Number('123'); // 123 const boolean = Boolean(null); // false 복사 문자열로 변환할 때는 대신 toString()을 사용할 수 있다. 긴 코드일 때 유용하다. js const num = 7; const result = num.toString(); console.log(result); // '7' 복사 js const num = 7; const result = num.toString(); console.log(result); // '7' 복사 숫자형으로 변환할 때의 규칙은 다음과 같다. 전달받은 값\t결과undefined\tNaN null\t0 true / false\t1 / 0 문자열\t문자열의 처음과 끝 공백이 제거된다. 공백 제거 후 남은 문자열이 없다면 0, 존재한다면 문자열에서 숫자를 읽는다. 변환에 실패하면 NaN이 된다. 불린형으로 변환할 때의 규칙은 다음과 같다. 전달받은 값\t결과0, NaN, '', null, undefined\tfalse 그 외의 값\ttrue","keywords":""},{"title":"선택적 연쇄","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/javascript/선택적-연쇄","content":"선택적 연쇄 선택적 연쇄(optional chaining) ?.를 사용하면 중간 프로퍼티가 존재하지 않는 경우에도 중첩된 객체의 프로퍼티에 안전하게 접근할 수 있다. ?.은 왼쪽에 있는 평가 대상이 undefined나 null이면 평가를 멈추고 undefined를 반환한다. 문법: obj?.prop obj?.[expr] arr?.[index] func?.(args) 복사 obj?.prop obj?.[expr] arr?.[index] func?.(args) 복사 예시: js const user = { name: 'Alice', cat: { name: 'Dinah' } }; console.log(user.dog?.name); // undefined console.log(user.nonExistentMethod?.()); // undefined 복사 js const user = { name: 'Alice', cat: { name: 'Dinah' } }; console.log(user.dog?.name); // undefined console.log(user.nonExistentMethod?.()); // undefined 복사","keywords":""},{"title":"소개","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/jest","content":"","keywords":""},{"title":"무설정​","type":1,"pageTitle":"소개","url":"/docs-repository/docs/miscellaneous/jest#무설정","content":"제스트는 대부분의 자바스크립트 프로젝트에서 별도의 설정 없이 바로 사용하는 것을 목표로 합니다. "},{"title":"스냅숏​","type":1,"pageTitle":"소개","url":"/docs-repository/docs/miscellaneous/jest#스냅숏","content":"큰 물체를 쉽게 추적하는 테스트를 만드세요. 스냅숏은 테스트와 함께 실행되거나 인라인으로 내장됩니다. "},{"title":"격리​","type":1,"pageTitle":"소개","url":"/docs-repository/docs/miscellaneous/jest#격리","content":"테스트는 성능을 최대화하기 위해 자체 프로세스에서 실행되어 병렬화됩니다. "},{"title":"훌륭한 API​","type":1,"pageTitle":"소개","url":"/docs-repository/docs/miscellaneous/jest#훌륭한-api","content":"it부터 expect까지, 제스트에는 전체 툴킷이 있습니다. 잘 문서화되고, 잘 유지됩니다. "},{"title":"빠르고 안전​","type":1,"pageTitle":"소개","url":"/docs-repository/docs/miscellaneous/jest#빠르고-안전","content":"제스트의 테스트는 고유한 전역 상태를 가지므로 테스트가 병렬로 안정적으로 실행됩니다. 빠른 테스트를 위해 제스트는 이전에 실패한 테스트를 먼저 실행합니다. 그리고 테스트 파일의 소요 시간을 기준으로 테스트 실행을 재구성합니다. "},{"title":"코드 적용 범위​","type":1,"pageTitle":"소개","url":"/docs-repository/docs/miscellaneous/jest#코드-적용-범위","content":"--coverage 플래그를 추가해 코드 적용 범위를 생성합니다. 추가 설정이 필요하지 않습니다. 제스트는 테스트되지 않은 파일을 포함하여 전체 프로젝트에서 코드 적용 범위 정보를 수집할 수 있습니다. "},{"title":"쉬운 모조​","type":1,"pageTitle":"소개","url":"/docs-repository/docs/miscellaneous/jest#쉬운-모조","content":"제스트는 테스트의 가져오기에 사용자 지정 리졸버를 사용하므로 테스트 스코프 밖의 모든 객체를 간단하게 모조할 수 있습니다. 풍부한 모조 함수와 모조 가져오기를 사용하여 읽을 수 있는 테스트 문법으로 함수 호출을 감시할 수 있습니다. "},{"title":"훌륭한 예외​","type":1,"pageTitle":"소개","url":"/docs-repository/docs/miscellaneous/jest#훌륭한-예외","content":"테스트가 실패하면 제스트가 풍부한 컨텍스트를 제공합니다. "},{"title":"철학​","type":1,"pageTitle":"소개","url":"/docs-repository/docs/miscellaneous/jest#철학","content":"제스트는 모든 자바스크립트 코드베이스의 정확성을 보장하도록 설계된 자바스크립트 테스트 프레임워크입니다. 제스트를 이용하면 신속하게 결과를 제공하는 테스트를 접근성이 좋고 친숙하며 기능이 풍부한 API로 작성할 수 있습니다. 제스트는 문서화가 잘 되어 있고 설정이 거의 필요하지 않으며 요구 사항에 맞게 확장할 수 있습니다. 제스트는 테스트를 즐겁게 만듭니다. "},{"title":"배열과 메서드","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/javascript/배열과-메서드","content":"","keywords":""},{"title":"길이​","type":1,"pageTitle":"배열과 메서드","url":"/docs-repository/docs/miscellaneous/javascript/배열과-메서드#길이","content":"arr.length로 배열의 길이를 얻을 수 있다. arr.length = 0으로 배열을 간단하게 비우는 것이 가능하다. "},{"title":"병합​","type":1,"pageTitle":"배열과 메서드","url":"/docs-repository/docs/miscellaneous/javascript/배열과-메서드#병합","content":"전개 문법을 활용한다. js const arr1 = ['a', 'b', 'c']; const arr2 = ['d', 'e', 'f']; const mergedArr = [...arr1, ...arr2]; 복사 js const arr1 = ['a', 'b', 'c']; const arr2 = ['d', 'e', 'f']; const mergedArr = [...arr1, ...arr2]; 복사 또는 array.concat()을 사용할 수 있다. "},{"title":"for문​","type":1,"pageTitle":"배열과 메서드","url":"/docs-repository/docs/miscellaneous/javascript/배열과-메서드#for문","content":"예시: js const arr = ['사과', '오렌지', '배']; for (let i = 0; i &lt; arr.length; i++) { console.log(arr[i]); } 복사 js const arr = ['사과', '오렌지', '배']; for (let i = 0; i &lt; arr.length; i++) { console.log(arr[i]); } 복사 인덱스가 필요한 상황이 아니라면 forEach 메서드를 사용한다. "},{"title":"메서드​","type":1,"pageTitle":"배열과 메서드","url":"/docs-repository/docs/miscellaneous/javascript/배열과-메서드#메서드","content":"자주 사용되는 배열 메서드는 다음과 같다. "},{"title":"forEach​","type":1,"pageTitle":"배열과 메서드","url":"/docs-repository/docs/miscellaneous/javascript/배열과-메서드#foreach","content":"각 요소에 대해 콜백 함수를 실행한다. 문법: js arr.forEach(callback(value[, index[, array]])[, thisArg]) 복사 js arr.forEach(callback(value[, index[, array]])[, thisArg]) 복사 예시: js const array = ['a', 'b', 'c']; array.forEach(element =&gt; console.log(element)); // a // b // c 복사 js const array = ['a', 'b', 'c']; array.forEach(element =&gt; console.log(element)); // a // b // c 복사 "},{"title":"map​","type":1,"pageTitle":"배열과 메서드","url":"/docs-repository/docs/miscellaneous/javascript/배열과-메서드#map","content":"콜백 함수의 실행 결과로 이루어진 새로운 배열을 만든다. 문법: js arr.map(callback(value[, index[, array]])[, thisArg]) 복사 js arr.map(callback(value[, index[, array]])[, thisArg]) 복사 예시: js const array = [1, 4, 9, 16]; const map = array.map((x) =&gt; x * 2); console.log(map); // [2, 8, 18, 32] 복사 js const array = [1, 4, 9, 16]; const map = array.map((x) =&gt; x * 2); console.log(map); // [2, 8, 18, 32] 복사 "},{"title":"reduce​","type":1,"pageTitle":"배열과 메서드","url":"/docs-repository/docs/miscellaneous/javascript/배열과-메서드#reduce","content":"반환값이 다음 요소에 전달된다. 문법: js arr.reduce(callback(accumulator, value[, index[, array]])[, initialValue]) 복사 js arr.reduce(callback(accumulator, value[, index[, array]])[, initialValue]) 복사 initialValue는 선택 사항이지만 항상 명시하는 것이 좋다. 예시: js const arr = [1, 2, 3, 4, 5]; const result = arr.reduce((sum, current) =&gt; sum + current, 0); alert(result); // 15 복사 js const arr = [1, 2, 3, 4, 5]; const result = arr.reduce((sum, current) =&gt; sum + current, 0); alert(result); // 15 복사 "},{"title":"includes​","type":1,"pageTitle":"배열과 메서드","url":"/docs-repository/docs/miscellaneous/javascript/배열과-메서드#includes","content":"특정 요소가 포함되어 있는지 판별한다. 판별에서 일치 연산자(===)를 사용한다. 문법: js arr.includes(valueToFind[, fromIndex]) 복사 js arr.includes(valueToFind[, fromIndex]) 복사 예시: js const pets = ['cat', 'dog', 'bat']; console.log(pets.includes('cat')); // true console.log(pets.includes('at')); // false 복사 js const pets = ['cat', 'dog', 'bat']; console.log(pets.includes('cat')); // true console.log(pets.includes('at')); // false 복사 "},{"title":"filter​","type":1,"pageTitle":"배열과 메서드","url":"/docs-repository/docs/miscellaneous/javascript/배열과-메서드#filter","content":"조건에 해당하는 요소로 이루어진 배열을 만든다. 문법: js arr.filter(callback(value[, index[, array]])[, thisArg]) 복사 js arr.filter(callback(value[, index[, array]])[, thisArg]) 복사 예시: js const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present']; const result = words.filter((word) =&gt; word.length &gt; 6); console.log(result); // ['exuberant', 'destruction', 'present'] 복사 js const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present']; const result = words.filter((word) =&gt; word.length &gt; 6); console.log(result); // ['exuberant', 'destruction', 'present'] 복사 "},{"title":"sort​","type":1,"pageTitle":"배열과 메서드","url":"/docs-repository/docs/miscellaneous/javascript/배열과-메서드#sort","content":"주의 이 메서드는 원본 배열이 보존되지 않는다. 요소를 정렬한다. 정렬 함수를 지정하지 않으면 문자의 유니코드 값에 따라 정렬된다. 오름차순으로 정렬하려면 a가 b보다 클 때 양수를 반환하면 된다. 문법: js arr.sort([compare(a, b)]) 복사 js arr.sort([compare(a, b)]) 복사 예시: js const arr = [4, 2, 5, 1, 3]; arr.sort((a, b) =&gt; a - b); console.log(arr); // [1, 2, 3, 4, 5] 복사 js const arr = [4, 2, 5, 1, 3]; arr.sort((a, b) =&gt; a - b); console.log(arr); // [1, 2, 3, 4, 5] 복사 "},{"title":"some​","type":1,"pageTitle":"배열과 메서드","url":"/docs-repository/docs/miscellaneous/javascript/배열과-메서드#some","content":"조건에 해당하는 요소가 하나라도 있는지 확인한다. 해당 요소를 발견하면 즉시 true를 반환한다. 문법: js arr.some(callback(value[, index[, array]])[, thisArg]) 복사 js arr.some(callback(value[, index[, array]])[, thisArg]) 복사 예시: js const arr = [1, 2, 3, 4, 5]; const result = arr.some((element) =&gt; element % 2 === 0); console.log(result); // true 복사 js const arr = [1, 2, 3, 4, 5]; const result = arr.some((element) =&gt; element % 2 === 0); console.log(result); // true 복사 "},{"title":"every​","type":1,"pageTitle":"배열과 메서드","url":"/docs-repository/docs/miscellaneous/javascript/배열과-메서드#every","content":"모든 요소가 조건에 해당하는지 확인합니다. 조건에 해당되지 않는 요소를 발견하면 즉시 false를 반환한다. 문법: js arr.every(callback(value[, index[, array]])[, thisArg]) 복사 js arr.every(callback(value[, index[, array]])[, thisArg]) 복사 예시: js const arr = [1, 30, 39, 29, 10, 13]; const result = arr.every((value) =&gt; value &lt; 40); console.log(result); // true 복사 js const arr = [1, 30, 39, 29, 10, 13]; const result = arr.every((value) =&gt; value &lt; 40); console.log(result); // true 복사 기타 메서드는 MDN을 참고한다. "},{"title":"비동기 코드 테스트하기","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/jest/비동기-코드-테스트하기","content":"","keywords":""},{"title":"프라미스​","type":1,"pageTitle":"비동기 코드 테스트하기","url":"/docs-repository/docs/miscellaneous/jest/비동기-코드-테스트하기#프라미스","content":"테스트에서 프라미스를 반환하면 제스트는 해당 프라미스가 이행될 때까지 기다립니다. 프라미스가 거부되면 테스트는 실패합니다. 예를 들어 fetchData가 'peanut butter' 문자열로 이행되어야 하는 프라미스를 반환한다고 가정해 보겠습니다. 테스트를 다음과 같이 작성할 수 있습니다. js test('the data is peanut butter', () =&gt; { return fetchData().then(data =&gt; { expect(data).toBe('peanut butter'); }); }); 복사 js test('the data is peanut butter', () =&gt; { return fetchData().then(data =&gt; { expect(data).toBe('peanut butter'); }); }); 복사 "},{"title":"async와 await​","type":1,"pageTitle":"비동기 코드 테스트하기","url":"/docs-repository/docs/miscellaneous/jest/비동기-코드-테스트하기#async와-await","content":"테스트에서 async와 await를 사용할 수 있습니다. 비동기 테스트를 작성하려면 test에 전달된 함수 앞에 async 키워드를 사용합니다. 예를 들어 동일한 fetchData 시나리오를 다음과 같이 테스트할 수 있습니다. js test('the data is peanut butter', async () =&gt; { const data = await fetchData(); expect(data).toBe('peanut butter'); }); test('the fetch fails with an error', async () =&gt; { expect.assertions(1); try { await fetchData(); } catch (e) { expect(e).toMatch('error'); } }); 복사 js test('the data is peanut butter', async () =&gt; { const data = await fetchData(); expect(data).toBe('peanut butter'); }); test('the fetch fails with an error', async () =&gt; { expect.assertions(1); try { await fetchData(); } catch (e) { expect(e).toMatch('error'); } }); 복사 async와 await를 .resolves 또는 .rejects와 결합할 수 있습니다. js test('the data is peanut butter', async () =&gt; { await expect(fetchData()).resolves.toBe('peanut butter'); }); test('the fetch fails with an error', async () =&gt; { await expect(fetchData()).rejects.toMatch('error'); }); 복사 js test('the data is peanut butter', async () =&gt; { await expect(fetchData()).resolves.toBe('peanut butter'); }); test('the fetch fails with an error', async () =&gt; { await expect(fetchData()).rejects.toMatch('error'); }); 복사 이 경우 async와 await는 앞에서 사용한 프라미스와 동일한 논리를 가지는 효과적인 문법 설탕입니다. 주의 반드시 프라미스를 반환하거나 await를 사용해야 합니다. 그러지 않으면 fetchData에서 반환된 프라미스가 이행되거나 거부되기 전에 테스트가 완료됩니다. 프라미스가 거부될 것으로 기대되면 .catch 메서드를 사용합니다. expect.assertions를 추가하여 특정한 수의 단언이 호출되는지 확인합니다. 그러지 않으면 이행된 약속이 테스트에 실패하지 않습니다. js test('the fetch fails with an error', () =&gt; { expect.assertions(1); return fetchData().catch(e =&gt; expect(e).toMatch('error')); }); 복사 js test('the fetch fails with an error', () =&gt; { expect.assertions(1); return fetchData().catch(e =&gt; expect(e).toMatch('error')); }); 복사 "},{"title":"콜백​","type":1,"pageTitle":"비동기 코드 테스트하기","url":"/docs-repository/docs/miscellaneous/jest/비동기-코드-테스트하기#콜백","content":"프라미스를 사용하지 않는다면 대신 콜백을 사용할 수 있습니다. 예를 들어 fetchData가 프라미스를 반환하는 대신 콜백을 기대한다고 가정해 보겠습니다. 즉, 어떤 데이터를 가져오고 가져오기가 완료되면 callback(null, data)을 호출합니다. 반환된 데이터가 'peanut butter' 문자열인지 테스트하려고 합니다. 기본적으로 제스트 테스트는 실행의 끝에 도달하면 완료됩니다. 따라서 다음 테스트는 의도한 대로 작동하지 않습니다. js // 이렇게 작성하지 마세요! test('the data is peanut butter', () =&gt; { function callback(error, data) { if (error) { throw error; } expect(data).toBe('peanut butter'); } fetchData(callback); }); 복사 js // 이렇게 작성하지 마세요! test('the data is peanut butter', () =&gt; { function callback(error, data) { if (error) { throw error; } expect(data).toBe('peanut butter'); } fetchData(callback); }); 복사 문제는 콜백 호출 전에, fetchData가 완료되는 즉시 테스트가 끝난다는 것입니다. 이를 해결할 수 있는 test의 대체 방법이 있습니다. 빈 인수를 가진 함수에 테스트를 넣는 대신 done이라는 단일 인수를 사용합니다. 제스트는 테스트를 완료하기 전에 done 콜백이 호출될 때까지 기다립니다. js test('the data is peanut butter', done =&gt; { function callback(error, data) { if (error) { done(error); return; } try { expect(data).toBe('peanut butter'); done(); } catch (error) { done(error); } } fetchData(callback); }); 복사 js test('the data is peanut butter', done =&gt; { function callback(error, data) { if (error) { done(error); return; } try { expect(data).toBe('peanut butter'); done(); } catch (error) { done(error); } } fetchData(callback); }); 복사 done()이 호출되지 않으면 원래 의도대로 (타임아웃 오류와 함께) 테스트가 실패합니다. expect문이 실패하면 오류가 발생하고 done()이 호출되지 않습니다. 테스트 로그에서 실패 이유를 보려면 expect를 try 블록으로 감싸고 catch 블록에서 done에 오류를 전달해야 합니다. 그러지 않으면 expect(data)에서 받은 값이 표시되지 않는 불분명한 타임아웃 오류가 발생합니다. 주의 제스트는 동일한 테스트 함수가 done() 콜백을 통과하고 프라미스를 반환하는 경우에 오류가 발생합니다. 이는 테스트에서 메모리 누수를 방지하기 위한 예방 조치입니다. "},{"title":".resolves와 .rejects​","type":1,"pageTitle":"비동기 코드 테스트하기","url":"/docs-repository/docs/miscellaneous/jest/비동기-코드-테스트하기#resolves와-rejects","content":"expect문에 .resolves 매처를 사용할 수도 있습니다. 그러면 제스트는 해당 프라미스가 이행(resolve)될 때까지 기다립니다. 프라미스가 거부되면 테스트는 자동으로 실패합니다. js test('the data is peanut butter', () =&gt; { return expect(fetchData()).resolves.toBe('peanut butter'); }); 복사 js test('the data is peanut butter', () =&gt; { return expect(fetchData()).resolves.toBe('peanut butter'); }); 복사 단언을 반환해야 합니다. return문을 생략하면 fetchData에서 반환된 프라미스가 이행되고 then()이 콜백을 실행하기 전에 테스트가 완료됩니다. 프라미스가 거부될 것으로 기대되면 .rejects 매처를 사용합니다. 이 매처는 .resolves 매처와 유사하게 작동합니다. 프라미스가 이행되면 테스트는 자동으로 실패합니다. js test('the fetch fails with an error', () =&gt; { return expect(fetchData()).rejects.toMatch('error'); }); 복사 js test('the fetch fails with an error', () =&gt; { return expect(fetchData()).rejects.toMatch('error'); }); 복사 특별히 더 우수한 방법은 없습니다. 단지 어떤 스타일로 테스트를 단순하게 만드느냐에 달려 있습니다. 코드베이스 전체 또는 단일 파일에서 이 방법들을 혼합하고 일치시킬 수 있습니다. "},{"title":"매처 사용하기","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/jest/매처-사용하기","content":"","keywords":""},{"title":"일반 매처​","type":1,"pageTitle":"매처 사용하기","url":"/docs-repository/docs/miscellaneous/jest/매처-사용하기#일반-매처","content":"값을 테스트하는 가장 간단한 방법은 일치를 사용하는 것입니다. js test('two plus two is four', () =&gt; { expect(2 + 2).toBe(4); }); 복사 js test('two plus two is four', () =&gt; { expect(2 + 2).toBe(4); }); 복사 이 코드에서 expect(2 + 2)는 기대(expectation) 객체를 반환합니다. 일반적으로 기대 객체에는 호출 매처를 제외하면 많은 작업을 수행하지 않습니다. 이 코드에서 .toBe(4)가 매처입니다. 제스트가 실행되면 모든 실패한 매처를 추적하여 멋진 오류 메시지를 출력할 수 있습니다. toBe는 Object.is를 사용하여 일치를 확인합니다. 객체의 값을 확인하려면 대신 toEqual를 사용합니다. js test('object assignment', () =&gt; { const data = {one: 1}; data['two'] = 2; expect(data).toEqual({one: 1, two: 2}); }); 복사 js test('object assignment', () =&gt; { const data = {one: 1}; data['two'] = 2; expect(data).toEqual({one: 1, two: 2}); }); 복사 toEqual은 객체나 배열의 모든 필드를 재귀적으로 확인합니다. 매처의 반대를 테스트할 수도 있습니다. js test('adding positive numbers is not zero', () =&gt; { for (let a = 1; a &lt; 10; a++) { for (let b = 1; b &lt; 10; b++) { expect(a + b).not.toBe(0); } } }); 복사 js test('adding positive numbers is not zero', () =&gt; { for (let a = 1; a &lt; 10; a++) { for (let b = 1; b &lt; 10; b++) { expect(a + b).not.toBe(0); } } }); 복사 "},{"title":"참 같은 값​","type":1,"pageTitle":"매처 사용하기","url":"/docs-repository/docs/miscellaneous/jest/매처-사용하기#참-같은-값","content":"테스트에서 undefined, null, false를 구별해야 할 때도 있고 그러지 않을 때도 있습니다. 제스트에는 원하는 것을 명시할 수 있는 도우미가 포함되어 있습니다. toBeNull은 null만 일치시킴toBeUndefined는 undefined만 일치시킴toBeDefined는 toBeUndefined의 반대toBeTruthy는 if문이 true로 판단하는 모든 것과 일치시킴toBeFalsy는 if문이 false로 판단하는 모든 것과 일치시킴 예시: js test('null', () =&gt; { const n = null; expect(n).toBeNull(); expect(n).toBeDefined(); expect(n).not.toBeUndefined(); expect(n).not.toBeTruthy(); expect(n).toBeFalsy(); }); test('zero', () =&gt; { const z = 0; expect(z).not.toBeNull(); expect(z).toBeDefined(); expect(z).not.toBeUndefined(); expect(z).not.toBeTruthy(); expect(z).toBeFalsy(); }); 복사 js test('null', () =&gt; { const n = null; expect(n).toBeNull(); expect(n).toBeDefined(); expect(n).not.toBeUndefined(); expect(n).not.toBeTruthy(); expect(n).toBeFalsy(); }); test('zero', () =&gt; { const z = 0; expect(z).not.toBeNull(); expect(z).toBeDefined(); expect(z).not.toBeUndefined(); expect(z).not.toBeTruthy(); expect(z).toBeFalsy(); }); 복사 코드에서 수행하려는 작업과 가장 정확하게 일치하는 매처를 사용해야 합니다. "},{"title":"숫자​","type":1,"pageTitle":"매처 사용하기","url":"/docs-repository/docs/miscellaneous/jest/매처-사용하기#숫자","content":"숫자를 비교하는 대부분의 방법과 대응되는 매처가 존재합니다. js test('two plus two', () =&gt; { const value = 2 + 2; expect(value).toBeGreaterThan(3); expect(value).toBeGreaterThanOrEqual(3.5); expect(value).toBeLessThan(5); expect(value).toBeLessThanOrEqual(4.5); // toBe와 toEqual은 숫자에 대해 동일합니다. expect(value).toBe(4); expect(value).toEqual(4); }); 복사 js test('two plus two', () =&gt; { const value = 2 + 2; expect(value).toBeGreaterThan(3); expect(value).toBeGreaterThanOrEqual(3.5); expect(value).toBeLessThan(5); expect(value).toBeLessThanOrEqual(4.5); // toBe와 toEqual은 숫자에 대해 동일합니다. expect(value).toBe(4); expect(value).toEqual(4); }); 복사 부동 소수점 일치에서는 테스트에 작은 반올림 오차가 생기지 않도록 toEqual 대신 toBeCloseTo를 사용합니다. js test('adding floating point numbers', () =&gt; { const value = 0.1 + 0.2; // expect(value).toBe(0.3); // 반올림 오차 때문에 작동하지 않습니다. expect(value).toBeCloseTo(0.3); // 잘 작동합니다. }); 복사 js test('adding floating point numbers', () =&gt; { const value = 0.1 + 0.2; // expect(value).toBe(0.3); // 반올림 오차 때문에 작동하지 않습니다. expect(value).toBeCloseTo(0.3); // 잘 작동합니다. }); 복사 "},{"title":"문자열​","type":1,"pageTitle":"매처 사용하기","url":"/docs-repository/docs/miscellaneous/jest/매처-사용하기#문자열","content":"toMatch를 사용하면 정규 표현식으로 문자열을 확인할 수 있습니다. js test('there is no I in team', () =&gt; { expect('team').not.toMatch(/I/); }); test('but there is a &quot;stop&quot; in Christoph', () =&gt; { expect('Christoph').toMatch(/stop/); }); 복사 js test('there is no I in team', () =&gt; { expect('team').not.toMatch(/I/); }); test('but there is a &quot;stop&quot; in Christoph', () =&gt; { expect('Christoph').toMatch(/stop/); }); 복사 "},{"title":"배열과 반복 가능한 객체​","type":1,"pageTitle":"매처 사용하기","url":"/docs-repository/docs/miscellaneous/jest/매처-사용하기#배열과-반복-가능한-객체","content":"toContain을 사용하여 배열 또는 반복 가능한 객체(iterable)에 특정 항목이 포함되어 있는지 확인할 수 있습니다. js const shoppingList = [ 'diapers', 'kleenex', 'trash bags', 'paper towels', 'milk', ]; test('the shopping list has milk on it', () =&gt; { expect(shoppingList).toContain('milk'); expect(new Set(shoppingList)).toContain('milk'); }); 복사 js const shoppingList = [ 'diapers', 'kleenex', 'trash bags', 'paper towels', 'milk', ]; test('the shopping list has milk on it', () =&gt; { expect(shoppingList).toContain('milk'); expect(new Set(shoppingList)).toContain('milk'); }); 복사 "},{"title":"예외​","type":1,"pageTitle":"매처 사용하기","url":"/docs-repository/docs/miscellaneous/jest/매처-사용하기#예외","content":"특정 함수가 호출될 때 오류가 발생하는지 테스트하려면 toThrow를 사용합니다. js function compileAndroidCode() { throw new Error('you are using the wrong JDK!'); } test('compiling android goes as expected', () =&gt; { expect(() =&gt; compileAndroidCode()).toThrow(); expect(() =&gt; compileAndroidCode()).toThrow(Error); // 오류 메시지 또는 정규 표현식에 포함되어야 하는 문자열을 사용할 수도 있습니다. expect(() =&gt; compileAndroidCode()).toThrow('you are using the wrong JDK'); expect(() =&gt; compileAndroidCode()).toThrow(/JDK/); // 또는 다음과 같은 정규 표현식을 사용하여 정확한 오류 메시지를 일치시킬 수 있습니다. expect(() =&gt; compileAndroidCode()).toThrow(/^you are using the wrong JDK$/); // Test fails expect(() =&gt; compileAndroidCode()).toThrow(/^you are using the wrong JDK!$/); // Test pass }); 복사 js function compileAndroidCode() { throw new Error('you are using the wrong JDK!'); } test('compiling android goes as expected', () =&gt; { expect(() =&gt; compileAndroidCode()).toThrow(); expect(() =&gt; compileAndroidCode()).toThrow(Error); // 오류 메시지 또는 정규 표현식에 포함되어야 하는 문자열을 사용할 수도 있습니다. expect(() =&gt; compileAndroidCode()).toThrow('you are using the wrong JDK'); expect(() =&gt; compileAndroidCode()).toThrow(/JDK/); // 또는 다음과 같은 정규 표현식을 사용하여 정확한 오류 메시지를 일치시킬 수 있습니다. expect(() =&gt; compileAndroidCode()).toThrow(/^you are using the wrong JDK$/); // Test fails expect(() =&gt; compileAndroidCode()).toThrow(/^you are using the wrong JDK!$/); // Test pass }); 복사 팁 예외를 던지는 함수는 래퍼 함수 내에서 호출되어야 합니다. 그러지 않으면 toThrow 단언이 실패합니다. "},{"title":"기타​","type":1,"pageTitle":"매처 사용하기","url":"/docs-repository/docs/miscellaneous/jest/매처-사용하기#기타","content":"지금까지 살펴본 매처는 일부분일 뿐입니다. 매처의 전체 목록은 레퍼런스 문서를 확인하세요. 지원 매처를 학습한 후에는 비동기 코드 테스트를 확인하는 것을 추천합니다. "},{"title":"시작하기","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/jest/시작하기","content":"","keywords":""},{"title":"명령 행에서 실행하기​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/miscellaneous/jest/시작하기#명령-행에서-실행하기","content":"yarn global add jest나 npm install jest --global로 제스트가 PATH에서 전역적으로 사용 가능하다면 CLI에서 제스트를 직접 실행할 수 있습니다. 이때 다양하고 유용한 옵션을 사용할 수 있습니다. 다음 명령은 config.json을 설정 파일로 사용해 my-test와 일치하는 파일에 제스트를 실행합니다. 실행 후에는 기본 OS 알림을 표시합니다. bash jest my-test --notify --config=config.json 복사 bash jest my-test --notify --config=config.json 복사 명령 행으로 jest를 실행하는 방법에 대해 더 알고 싶다면 제스트 CLI 옵션 페이지를 참고하세요. "},{"title":"추가 설정​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/miscellaneous/jest/시작하기#추가-설정","content":""},{"title":"기본 설정 파일 생성하기​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/miscellaneous/jest/시작하기#기본-설정-파일-생성하기","content":"제스트는 프로젝트를 기반으로 몇 가지 질문을 하고 각 옵션에 대한 간단한 설명이 포함된 기본 설정 파일을 생성합니다. bash jest --init 복사 bash jest --init 복사 "},{"title":"바벨 사용하기​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/miscellaneous/jest/시작하기#바벨-사용하기","content":"바벨을 사용하려면 다음과 같이 패키지를 설치합니다. npmYarn bash npm install --save-dev babel-jest @babel/core @babel/preset-env 복사 bash npm install --save-dev babel-jest @babel/core @babel/preset-env 복사 프로젝트의 루트에 babel.config.js 파일을 생성하여 노드의 현재 버전을 대상으로 하도록 바벨을 설정합니다. babel.config.js js module.exports = { presets: [['@babel/preset-env', { targets: { node: 'current' } }]], }; 복사 babel.config.js js module.exports = { presets: [['@babel/preset-env', { targets: { node: 'current' } }]], }; 복사 "},{"title":"웹팩 사용하기​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/miscellaneous/jest/시작하기#웹팩-사용하기","content":"제스트는 웹팩으로 자산, 스타일, 컴파일을 관리하는 프로젝트에서 사용할 수 있습니다. 웹팩은 다른 도구에 비해 몇 가지 독특한 도전을 제공합니다. 시작하려면 웹팩 안내서를 참조하세요. "},{"title":"Vite 사용하기​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/miscellaneous/jest/시작하기#vite-사용하기","content":"Vite를 사용해 기본 ESM으로 소스 코드를 제공하여 일부 프런트 엔드 툴링을 제공하는 프로젝트에서 제스트를 사용할 수 있습니다. Vite는 독특한 도구이며 즉시 사용 가능한 워크플로를 제공합니다. Vite 플러그인 시스템의 작동 방식 때문에 Vite가 완전히 지원되지는 않습니다. 하지만 최고의 제스트 통합 방법인 vite-jest를 사용하는 몇 가지 예시가 있습니다. vite-jest의 제한도 확인하세요. 시작하려면 Vite 안내서를 참조하세요. 또는 vitest를 사용할 수 있습니다. "},{"title":"파설 사용하기​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/miscellaneous/jest/시작하기#파설-사용하기","content":"제스트는 웹팩과 유사하게 parcel-bundler로 자산, 스타일, 컴파일을 관리하는 프로젝트에서 사용할 수 있습니다. 파설에는 설정이 필요 없습니다. 시작하려면 공식 문서를 참조하세요. "},{"title":"타입스크립트 사용하기​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/miscellaneous/jest/시작하기#타입스크립트-사용하기","content":"babel로 타입스크립트 사용하기​ 제스트는 바벨로 타입스크립트를 지원합니다. 먼저 위의 바벨 사용하기 지침을 따랐는지 확인하고 @babel/preset-typescript을 설치합니다. npmYarn bash npm install --save-dev @babel/preset-typescript 복사 bash npm install --save-dev @babel/preset-typescript 복사 그리고 babel.config.js의 presets 목록에 @babel/preset-typescript를 추가합니다. babel.config.js js module.exports = { presets: [ ['@babel/preset-env', { targets: { node: 'current' } }], // highlight-next-line '@babel/preset-typescript', ], }; 복사 babel.config.js js module.exports = { presets: [ ['@babel/preset-env', { targets: { node: 'current' } }], // highlight-next-line '@babel/preset-typescript', ], }; 복사 바벨과 타입스크립트를 사용할 때 몇 가지 주의 사항이 있습니다. 바벨의 타입스크립트 지원은 단순한 트랜스파일이므로 제스트는 테스트가 실행될 때 타입 검사를 하지 않습니다. 타입 검사를 원한다면 ts-jest를 사용하거나, 타입스크립트 컴파일러 tsc를 별도로 (또는 빌드 프로세스의 일부로) 실행할 수 있습니다. ts-jest로 타입스크립트 사용하기​ ts-jest는 제스트에 대한 소스 맵을 지원하는 타입스크립트 전처리기입니다. 타입스크립트로 작성된 프로젝트를 제스트로 테스트하는 것이 가능해집니다. npmYarn bash npm install --save-dev ts-jest 복사 bash npm install --save-dev ts-jest 복사 타입 정의​ 타입스크립트로 작성된 테스트 파일에서 제스트 전역 API를 사용하는 방법은 두 가지가 있습니다. 제스트와 함께 제공되며 제스트를 업데이트할 때마다 갱신되는 타입 정의를 사용할 수 있습니다. @jest/globals 패키지에서 API를 가져오기만 하면 됩니다. sum.test.ts ts import { describe, expect, test } from '@jest/globals'; import { sum } from './sum'; describe('sum module', () =&gt; { test('adds 1 + 2 to equal 3', () =&gt; { expect(sum(1, 2)).toBe(3); }); }); 복사 sum.test.ts ts import { describe, expect, test } from '@jest/globals'; import { sum } from './sum'; describe('sum module', () =&gt; { test('adds 1 + 2 to equal 3', () =&gt; { expect(sum(1, 2)).toBe(3); }); }); 복사 팁 describe.each/test.each와 모조 함수의 추가 사용 설명서를 참조하세요. 또는 @types/jest 패키지를 설치하는 것을 선택할 수 있습니다. 별도로 가져올 필요 없이 제스트 전역에 대한 타입을 제공합니다. npmYarn bash npm install --save-dev @types/jest 복사 bash npm install --save-dev @types/jest 복사 정보 @types/jest는 DefinitelyTyped에서 관리되는 타사 라이브러리입니다. 따라서 최신 제스트 기능이나 버전은 아직 지원되지 않을 수 있습니다. 제스트와 @types/jest의 버전이 가능한 가까워야 합니다. 예를 들어 제스트 27.4.0을 사용한다면 @types/jest 27.4.x를 설치하는 것이 이상적입니다. "},{"title":"설정과 해제","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/jest/설정과-해제","content":"","keywords":""},{"title":"설정 반복하기​","type":1,"pageTitle":"설정과 해제","url":"/docs-repository/docs/miscellaneous/jest/설정과-해제#설정-반복하기","content":"여러 테스트에서 반복적으로 수행해야 하는 작업이 있다면 beforeEach와 afterEach 훅을 사용할 수 있습니다. 예를 들어 여러 테스트가 도시 데이터베이스와 상호 작용한다고 가정해 보겠습니다. 각 테스트 전에 호출해야 하는 initializeCityDatabase() 메서드와 각 테스트 후에 호출해야 하는 clearCityDatabase() 메서드가 있습니다. 테스트를 다음과 같이 작성할 수 있습니다. js beforeEach(() =&gt; { initializeCityDatabase(); }); afterEach(() =&gt; { clearCityDatabase(); }); test('city database has Vienna', () =&gt; { expect(isCity('Vienna')).toBeTruthy(); }); test('city database has San Juan', () =&gt; { expect(isCity('San Juan')).toBeTruthy(); }); 복사 js beforeEach(() =&gt; { initializeCityDatabase(); }); afterEach(() =&gt; { clearCityDatabase(); }); test('city database has Vienna', () =&gt; { expect(isCity('Vienna')).toBeTruthy(); }); test('city database has San Juan', () =&gt; { expect(isCity('San Juan')).toBeTruthy(); }); 복사 beforeEach와 afterEach는 테스트가 비동기 코드를 처리하는 방법과 동일한 방법으로 비동기 코드를 처리할 수 있습니다. 즉, done 매개변수를 사용하거나 프라미스를 반환할 수 있습니다. 예를 들어 initializeCityDatabase()가 데이터베이스가 초기화될 때 이행된 프라미스를 반환하면, 해당 프라미스를 반환하고자 합니다. js beforeEach(() =&gt; { return initializeCityDatabase(); }); 복사 js beforeEach(() =&gt; { return initializeCityDatabase(); }); 복사 "},{"title":"일회성 설정​","type":1,"pageTitle":"설정과 해제","url":"/docs-repository/docs/miscellaneous/jest/설정과-해제#일회성-설정","content":"어떤 경우에는 파일의 시작 부분에서 한 번만 설정하면 됩니다. 이는 설정이 비동기식일 때 특히 성가실 수 있으므로 인라인으로 수행할 수 없습니다. 제스트는 이런 상황을 처리하는 beforeAll과 afterAll 훅을 제공합니다. 예를 들어 initializeCityDatabase()와 clearCityDatabase()가 모두 프라미스를 반환하고 테스트 간에 도시 데이터베이스를 재사용할 수 있다면 테스트 코드를 다음과 같이 변경할 수 있습니다. js beforeAll(() =&gt; { return initializeCityDatabase(); }); afterAll(() =&gt; { return clearCityDatabase(); }); test('city database has Vienna', () =&gt; { expect(isCity('Vienna')).toBeTruthy(); }); test('city database has San Juan', () =&gt; { expect(isCity('San Juan')).toBeTruthy(); }); 복사 js beforeAll(() =&gt; { return initializeCityDatabase(); }); afterAll(() =&gt; { return clearCityDatabase(); }); test('city database has Vienna', () =&gt; { expect(isCity('Vienna')).toBeTruthy(); }); test('city database has San Juan', () =&gt; { expect(isCity('San Juan')).toBeTruthy(); }); 복사 "},{"title":"스코프 지정하기​","type":1,"pageTitle":"설정과 해제","url":"/docs-repository/docs/miscellaneous/jest/설정과-해제#스코프-지정하기","content":"기본적으로 beforeAll과 afterAll 블록은 파일의 모든 테스트에 적용됩니다. describe 블록을 사용하여 테스트와 함께 그룹화할 수도 있습니다. beforeAll과 afterAll은 describe 블록 안에 있으면 해당 describe 블록 내의 테스트에만 적용됩니다. 예를 들어 도시 데이터베이스뿐만 아니라 음식 데이터베이스도 있다고 가정해 보겠습니다. 다음과 같이 테스트마다 다른 설정을 할 수 있습니다. js // 이 파일의 모든 테스트에 적용됩니다. beforeEach(() =&gt; { return initializeCityDatabase(); }); test('city database has Vienna', () =&gt; { expect(isCity('Vienna')).toBeTruthy(); }); test('city database has San Juan', () =&gt; { expect(isCity('San Juan')).toBeTruthy(); }); describe('matching cities to foods', () =&gt; { // 이 describe 블록의 테스트에만 적용됩니다. beforeEach(() =&gt; { return initializeFoodDatabase(); }); test('Vienna &lt;3 veal', () =&gt; { expect(isValidCityFoodPair('Vienna', 'Wiener Schnitzel')).toBe(true); }); test('San Juan &lt;3 plantains', () =&gt; { expect(isValidCityFoodPair('San Juan', 'Mofongo')).toBe(true); }); }); 복사 js // 이 파일의 모든 테스트에 적용됩니다. beforeEach(() =&gt; { return initializeCityDatabase(); }); test('city database has Vienna', () =&gt; { expect(isCity('Vienna')).toBeTruthy(); }); test('city database has San Juan', () =&gt; { expect(isCity('San Juan')).toBeTruthy(); }); describe('matching cities to foods', () =&gt; { // 이 describe 블록의 테스트에만 적용됩니다. beforeEach(() =&gt; { return initializeFoodDatabase(); }); test('Vienna &lt;3 veal', () =&gt; { expect(isValidCityFoodPair('Vienna', 'Wiener Schnitzel')).toBe(true); }); test('San Juan &lt;3 plantains', () =&gt; { expect(isValidCityFoodPair('San Juan', 'Mofongo')).toBe(true); }); }); 복사 최상위 beforeEach는 describe 블록 내의 beforeEach 이전에 실행됩니다. 다음 예시를 보면 모든 훅의 실행 순서를 이해하는 데 도움이 될 것입니다. js beforeAll(() =&gt; console.log('1 - beforeAll')); afterAll(() =&gt; console.log('1 - afterAll')); beforeEach(() =&gt; console.log('1 - beforeEach')); afterEach(() =&gt; console.log('1 - afterEach')); test('', () =&gt; console.log('1 - test')); describe('Scoped / Nested block', () =&gt; { beforeAll(() =&gt; console.log('2 - beforeAll')); afterAll(() =&gt; console.log('2 - afterAll')); beforeEach(() =&gt; console.log('2 - beforeEach')); afterEach(() =&gt; console.log('2 - afterEach')); test('', () =&gt; console.log('2 - test')); }); // 1 - beforeAll // 1 - beforeEach // 1 - test // 1 - afterEach // 2 - beforeAll // 1 - beforeEach // 2 - beforeEach // 2 - test // 2 - afterEach // 1 - afterEach // 2 - afterAll // 1 - afterAll 복사 js beforeAll(() =&gt; console.log('1 - beforeAll')); afterAll(() =&gt; console.log('1 - afterAll')); beforeEach(() =&gt; console.log('1 - beforeEach')); afterEach(() =&gt; console.log('1 - afterEach')); test('', () =&gt; console.log('1 - test')); describe('Scoped / Nested block', () =&gt; { beforeAll(() =&gt; console.log('2 - beforeAll')); afterAll(() =&gt; console.log('2 - afterAll')); beforeEach(() =&gt; console.log('2 - beforeEach')); afterEach(() =&gt; console.log('2 - afterEach')); test('', () =&gt; console.log('2 - test')); }); // 1 - beforeAll // 1 - beforeEach // 1 - test // 1 - afterEach // 2 - beforeAll // 1 - beforeEach // 2 - beforeEach // 2 - test // 2 - afterEach // 1 - afterEach // 2 - afterAll // 1 - afterAll 복사 "},{"title":"실행 순서​","type":1,"pageTitle":"설정과 해제","url":"/docs-repository/docs/miscellaneous/jest/설정과-해제#실행-순서","content":"제스트는 실제 테스트를 실행하기 전에(before) 테스트 파일의 모든 describe 핸들러를 실행합니다. 따라서 describe 블록이 아닌 before*와 after* 핸들러 내부에서 설정과 해제 작업을 수행하는 것이 좋습니다. describe 블록이 완료되면 제스트는 기본적으로 수집 단계에서 만난 순서대로 모든 테스트를 연속적으로 실행합니다. 각 테스트가 완료되고 정리될 때까지 기다렸다가 다음 단계로 이동합니다. 예시: js describe('describe outer', () =&gt; { console.log('describe outer-a'); describe('describe inner 1', () =&gt; { console.log('describe inner 1'); test('test 1', () =&gt; console.log('test 1')); }); console.log('describe outer-b'); test('test 2', () =&gt; console.log('test 2')); describe('describe inner 2', () =&gt; { console.log('describe inner 2'); test('test 3', () =&gt; console.log('test 3')); }); console.log('describe outer-c'); }); // describe outer-a // describe inner 1 // describe outer-b // describe inner 2 // describe outer-c // test 1 // test 2 // test 3 복사 js describe('describe outer', () =&gt; { console.log('describe outer-a'); describe('describe inner 1', () =&gt; { console.log('describe inner 1'); test('test 1', () =&gt; console.log('test 1')); }); console.log('describe outer-b'); test('test 2', () =&gt; console.log('test 2')); describe('describe inner 2', () =&gt; { console.log('describe inner 2'); test('test 3', () =&gt; console.log('test 3')); }); console.log('describe outer-c'); }); // describe outer-a // describe inner 1 // describe outer-b // describe inner 2 // describe outer-c // test 1 // test 2 // test 3 복사 describe와 test 블록처럼 제스트는 선언 순서대로 before*과 after* 훅을 호출합니다. 내부 스코프의 after* 훅이 먼저 호출됩니다. 다음은 서로 종속되는 리소스를 설정하고 해제하는 예시입니다. js beforeEach(() =&gt; console.log('connection setup')); beforeEach(() =&gt; console.log('database setup')); afterEach(() =&gt; console.log('database teardown')); afterEach(() =&gt; console.log('connection teardown')); test('test 1', () =&gt; console.log('test 1')); describe('extra', () =&gt; { beforeEach(() =&gt; console.log('extra database setup')); afterEach(() =&gt; console.log('extra database teardown')); test('test 2', () =&gt; console.log('test 2')); }); // connection setup // database setup // test 1 // database teardown // connection teardown // connection setup // database setup // extra database setup // test 2 // extra database teardown // database teardown // connection teardown 복사 js beforeEach(() =&gt; console.log('connection setup')); beforeEach(() =&gt; console.log('database setup')); afterEach(() =&gt; console.log('database teardown')); afterEach(() =&gt; console.log('connection teardown')); test('test 1', () =&gt; console.log('test 1')); describe('extra', () =&gt; { beforeEach(() =&gt; console.log('extra database setup')); afterEach(() =&gt; console.log('extra database teardown')); test('test 2', () =&gt; console.log('test 2')); }); // connection setup // database setup // test 1 // database teardown // connection teardown // connection setup // database setup // extra database setup // test 2 // extra database teardown // database teardown // connection teardown 복사 참고 jasmine2 테스트 러너를 사용한다면 선언의 역순으로 after* 훅을 호출합니다. 동일한 출력을 얻으려면 위의 예시를 다음과 같이 변경해야 합니다. diff beforeEach(() =&gt; console.log('connection setup')); + afterEach(() =&gt; console.log('connection teardown')); beforeEach(() =&gt; console.log('database setup')); + afterEach(() =&gt; console.log('database teardown')); - afterEach(() =&gt; console.log('database teardown')); - afterEach(() =&gt; console.log('connection teardown')); // ... 복사 diff beforeEach(() =&gt; console.log('connection setup')); + afterEach(() =&gt; console.log('connection teardown')); beforeEach(() =&gt; console.log('database setup')); + afterEach(() =&gt; console.log('database teardown')); - afterEach(() =&gt; console.log('database teardown')); - afterEach(() =&gt; console.log('connection teardown')); // ... 복사 "},{"title":"일반적인 조언​","type":1,"pageTitle":"설정과 해제","url":"/docs-repository/docs/miscellaneous/jest/설정과-해제#일반적인-조언","content":"테스트가 실패하면 가장 먼저 확인할 것 중 하나는 테스트가 혼자 실행될 때도 실패하는지 여부입니다. 제스트에서 하나의 테스트만 실행하려면 해당 test 명령을 잠시 test.only로 변경하면 됩니다. js test.only('this will be the only test that runs', () =&gt; { expect(true).toBe(false); }); test('this test will not run', () =&gt; { expect('A').toBe('A'); }); 복사 js test.only('this will be the only test that runs', () =&gt; { expect(true).toBe(false); }); test('this test will not run', () =&gt; { expect('A').toBe('A'); }); 복사 더 큰 스위트의 일부로 실행할 때는 자주 실패하지만 혼자 실행할 때는 실패하지 않는다면, 다른 테스트의 무언가가 해당 테스트를 방해하고 있을 확률이 높습니다. beforeEach로 일부 공유 상태를 제거하면 이 문제가 종종 해결되곤 합니다. 어떤 공유 상태가 변경되는지 확실하지 않다면 데이터를 기록하는 beforeEach를 시도해 볼 수 있습니다. "},{"title":"소개","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/next-auth-js","content":"","keywords":""},{"title":"유연성과 사용성​","type":1,"pageTitle":"소개","url":"/docs-repository/docs/miscellaneous/next-auth-js#유연성과-사용성","content":"모든 OAuth 서비스와 함께 작동하도록 설계되었으며 OAuth 1.0, 1.0A, 2.0 그리고 오픈ID 커넥트(OIDC)를 지원여러 인기 있는 로그인 서비스를 내장 지원이메일, 비밀번호가 없는 인증 지원모든 백엔드(액티브 디렉터리, LDAP 등)에서 무상태 인증 지원JSON 웹 토큰(JWT) 및 데이터베이스 세션 모두 지원서버리스용으로 설계되었지만 어디서나 실행 가능 (AWS 람다, 도커, 헤로쿠 등) "},{"title":"자체 데이터를 소유​","type":1,"pageTitle":"소개","url":"/docs-repository/docs/miscellaneous/next-auth-js#자체-데이터를-소유","content":"넥스트인증은 데이터베이스와 함께 또는 데이터베이스 없이 사용할 수 있습니다. 데이터를 계속 제어할 수 있는 오픈 소스 솔루션BYOD(Bring Your Own Database)를 지원하며 모든 데이터베이스와 함께 사용 가능마이SQL, 마리아DB, 포스트그레, SQL 서버, 몽고DB, SQL라이트에 대한 내장 지원인기 있는 호스팅 제공업체의 데이터베이스와 잘 작동함데이터베이스 없이도 사용 가능 (예: OAuth + JWT) 참고 이메일 로그인을 위해서는 일회용 인증 토큰을 저장하도록 데이터베이스를 구성해야 합니다. "},{"title":"기본 보안​","type":1,"pageTitle":"소개","url":"/docs-repository/docs/miscellaneous/next-auth-js#기본-보안","content":"암호 없는 로그인 메커니즘 사용 촉진기본적으로 안전하도록 설계되었으며 사용자 데이터를 보호하기 위한 모범 사례를 권장POST 경로(로그인, 로그아웃)에서 사이트 간 요청 위조 토큰 사용기본 쿠키 정책은 각 쿠키에 가장 적합한 가장 제한적인 정책을 목표로 함JSON 웹 토큰이 활성화되면 A256GCM을 사용하여 기본적으로 암호화됨 (JWE)개발자 편의를 위해 대칭 서명 및 암호화 키 자동 생성단기 세션을 지원하는 탭/창 동기화 및 연결 유지 메시지 기능OWASP에서 발표한 최신 지침 구현 시도 고급 옵션을 사용하면 JSON 웹 토큰을 인코딩/디코딩하고 커스텀 쿠키 보안 정책 및 세션 속성을 설정하는 등 로그인의 커스텀 루틴을 정의할 수 있습니다. 따라서 로그인할 수 있는 사용자와 세션의 유효성을 다시 확인하는 빈도를 제어할 수 있습니다. "},{"title":"REST API","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/REST-API","content":"","keywords":""},{"title":"GET /api/auth/signin​","type":1,"pageTitle":"REST API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/REST-API#get-apiauthsignin","content":"내장된 비브랜드 로그인 페이지를 표시합니다. "},{"title":"POST /api/auth/signin/:provider​","type":1,"pageTitle":"REST API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/REST-API#post-apiauthsigninprovider","content":"제공자별 로그인 흐름을 시작합니다. POST 제출에는 /api/auth/csrf의 CSRF 토큰이 필요합니다. OAuth 제공자의 경우, 이 엔드포인트를 호출하면 ID 제공자에 대한 권한 부여 요청이 시작됩니다. OAuth 사양에서 자세한 내용을 확인하세요. 이메일 제공자를 사용하는 경우, 이 엔드포인트를 호출하면 사용자의 이메일 주소로 로그인 URL이 전송됩니다. signIn 메서드에서도 이 엔드포인트를 내부적으로 사용합니다. "},{"title":"GET/POST /api/auth/callback/:provider​","type":1,"pageTitle":"REST API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/REST-API#getpost-apiauthcallbackprovider","content":"로그인하는 동안 OAuth 서비스의 반환 요청을 처리합니다. checks: [&quot;state&quot;] 옵션을 지원하는 OAuth 2.0 제공자의 경우 로그인 흐름이 시작될 때 생성된 것과 비교하여 상태 매개변수를 확인합니다. 이는 로그인 동안 POST 및 GET 호출에서 모두 일치해야 하는 CSRF 토큰의 해시를 사용합니다. OAuth 사양에서 자세한 내용을 확인하세요. "},{"title":"GET /api/auth/signout​","type":1,"pageTitle":"REST API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/REST-API#get-apiauthsignout","content":"내장된 비브랜드 로그아웃 페이지를 표시합니다. "},{"title":"POST /api/auth/signout​","type":1,"pageTitle":"REST API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/REST-API#post-apiauthsignout","content":"사용자 로그아웃 처리합니다. 이는 악의적인 링크가 동의 없이 사용자를 로그아웃시키는 것을 방지하기 위한 POST 제출입니다. 세션을 저장할 때 선택한 흐름에 따라 사용자 세션이 쿠키나 데이터베이스에서 무효화 또는 제거됩니다. POST 제출에는 /api/auth/csrf의 CSRF 토큰이 필요합니다. signOut 메서드에서도 이 엔드포인트를 내부적으로 사용합니다. "},{"title":"GET /api/auth/session​","type":1,"pageTitle":"REST API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/REST-API#get-apiauthsession","content":"클라이언트에 안전한 세션 객체를 반환하거나 세션이 없는 경우 빈 객체를 반환합니다. 반환되는 세션 객체의 내용은 session 콜백으로 설정할 수 있습니다. "},{"title":"GET /api/auth/csrf​","type":1,"pageTitle":"REST API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/REST-API#get-apiauthcsrf","content":"CSRF 토큰을 포함된 객체를 반환합니다. 넥스트인증에서 CSRF 보호는 모든 인증 경로에 있습니다. 서명된 HttpOnly, 호스트 전용 쿠키를 사용하는 '이중 제출 쿠키 방식'을 사용합니다. 이 엔드포인트에서 반환된 CSRF 토큰은 모든 API 엔드포인트에 대한 모든 POST 제출에 csrfToken이라는 폼 변수로 전달되어야 합니다. "},{"title":"GET /api/auth/providers​","type":1,"pageTitle":"REST API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/REST-API#get-apiauthproviders","content":"설정된 OAuth 서비스 목록과 각 서비스의 세부 정보(예: 로그인 및 콜백 URL)를 반환합니다. 커스텀 가입 페이지를 동적으로 생성하고 각 OAuth 제공자의 콜백 URL을 확인할 때 유용합니다. 참고 기본 경로는 /api/auth이며 NEXTAUTH_URL에서 커스텀 경로를 지정할 수 있습니다. 예시: NEXTAUTH_URL=https://example.com/myapp/api/authentication /api/auth/signin → /myapp/api/authentication/signin "},{"title":"자격 증명","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/next-auth-js/설정/자격-증명","content":"","keywords":""},{"title":"방법​","type":1,"pageTitle":"자격 증명","url":"/docs-repository/docs/miscellaneous/next-auth-js/설정/자격-증명#방법","content":"자격 증명 제공자를 사용하면 사용자 이름과 비밀번호, 이중 인증(2FA), 하드웨어 장치(예: YubiKey U2F / FIDO)와 같은 임의 자격 증명으로 로그인을 처리할 수 있습니다. 사용자를 인증해야 하는 기존 시스템이 있는 유스 케이스를 지원합니다. pages/api/auth/[...nextauth].js js import CredentialsProvider from &quot;next-auth/providers/credentials&quot; ... providers: [ CredentialsProvider({ // 로그인 폼에 표시할 이름 (예: '...로 로그인') name: 'Credentials', // 자격 증명은 로그인 페이지에서 적절한 폼을 생성하는 데 사용됩니다. // 제출할 것으로 예상되는 필드를 지정할 수 있습니다. // 예: 도메인, 사용자 이름, 비밀번호, 2FA 토큰 등 // 객체를 통해 HTML 속성을 &lt;input&gt; 태그로 전달할 수 있습니다. credentials: { username: { label: &quot;Username&quot;, type: &quot;text&quot;, placeholder: &quot;jsmith&quot; }, password: { label: &quot;Password&quot;, type: &quot;password&quot; } }, async authorize(credentials, req) { // 제출된 자격 증명을 사용해 사용자를 나타내는 객체를 반환하거나 // 자격 증명이 유효하지 않다면 false/null 값을 반환하는 // 자체 논리를 이곳에 작성해야 합니다. // 예시: `return { id: 1, name: 'J Smith', email: 'jsmith@example.com' }` // req 객체를 사용해 추가 매개변수를 얻을 수도 있습니다. // 예시: 요청 IP 주소 const res = await fetch(&quot;/your/endpoint&quot;, { method: 'POST', body: JSON.stringify(credentials), headers: { &quot;Content-Type&quot;: &quot;application/json&quot; } }) const user = await res.json() // 오류가 없고 사용자 데이터가 있으면 user를 반환합니다. if (res.ok &amp;&amp; user) { return user } // 사용자 데이터가 검색되지 않으면 null을 반환합니다. return null } }) ] ... 복사 pages/api/auth/[...nextauth].js js import CredentialsProvider from &quot;next-auth/providers/credentials&quot; ... providers: [ CredentialsProvider({ // 로그인 폼에 표시할 이름 (예: '...로 로그인') name: 'Credentials', // 자격 증명은 로그인 페이지에서 적절한 폼을 생성하는 데 사용됩니다. // 제출할 것으로 예상되는 필드를 지정할 수 있습니다. // 예: 도메인, 사용자 이름, 비밀번호, 2FA 토큰 등 // 객체를 통해 HTML 속성을 &lt;input&gt; 태그로 전달할 수 있습니다. credentials: { username: { label: &quot;Username&quot;, type: &quot;text&quot;, placeholder: &quot;jsmith&quot; }, password: { label: &quot;Password&quot;, type: &quot;password&quot; } }, async authorize(credentials, req) { // 제출된 자격 증명을 사용해 사용자를 나타내는 객체를 반환하거나 // 자격 증명이 유효하지 않다면 false/null 값을 반환하는 // 자체 논리를 이곳에 작성해야 합니다. // 예시: `return { id: 1, name: 'J Smith', email: 'jsmith@example.com' }` // req 객체를 사용해 추가 매개변수를 얻을 수도 있습니다. // 예시: 요청 IP 주소 const res = await fetch(&quot;/your/endpoint&quot;, { method: 'POST', body: JSON.stringify(credentials), headers: { &quot;Content-Type&quot;: &quot;application/json&quot; } }) const user = await res.json() // 오류가 없고 사용자 데이터가 있으면 user를 반환합니다. if (res.ok &amp;&amp; user) { return user } // 사용자 데이터가 검색되지 않으면 null을 반환합니다. return null } }) ] ... 복사 자세한 내용은 자격 증명 제공자 문서을 참조하세요. 참고 자격 증명 제공자는 세션에 대해 JSON 웹 토큰이 활성화된 경우에만 사용할 수 있습니다. 자격 증명 제공자로 인증된 사용자는 데이터베이스에 저장되지 않습니다. "},{"title":"옵션​","type":1,"pageTitle":"자격 증명","url":"/docs-repository/docs/miscellaneous/next-auth-js/설정/자격-증명#옵션","content":"이름\t설명\t타입\t필수id\t제공자의 고유 ID\tstring\t예 name\t제공자를 설명하는 이름\tstring\t예 type\t제공자의 유형으로 이 경우에는 credentials\t&quot;credentials&quot;\t예 credentials\t로그인할 자격 증명\tObject\t예 authorize\t사용자에게 권한이 부여되면 실행할 콜백\t(credentials, req) =&gt; Promise&lt;User&gt;\t예 "},{"title":"초기화","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/next-auth-js/설정/초기화","content":"","keywords":""},{"title":"간단한 초기화​","type":1,"pageTitle":"초기화","url":"/docs-repository/docs/miscellaneous/next-auth-js/설정/초기화#간단한-초기화","content":"대부분의 경우 NextAuth.js이 어떤 일을 하는지 신경 쓸 필요가 없습니다. 다음 초기화만 수행하면 됩니다. /pages/api/auth/[...nextauth].js ts import NextAuth from &quot;next-auth&quot; export default NextAuth({ ... }) 복사 /pages/api/auth/[...nextauth].js ts import NextAuth from &quot;next-auth&quot; export default NextAuth({ ... }) 복사 여기서는 NextAuth에 옵션만 건네주면 나머지는 NextAuth가 처리합니다. 이는 코드를 단순화하고 인증 흐름에서 잠재적인 오류를 줄이기 때문에 튜토리얼이나 문서의 다른 부분에서 선호되는 초기화입니다. "},{"title":"고급 초기화​","type":1,"pageTitle":"초기화","url":"/docs-repository/docs/miscellaneous/next-auth-js/설정/초기화#고급-초기화","content":"특정 유스 케이스가 있고 넥스트인증의 설계 의도와 약간 다른 작업을 수행하고 싶다면 고급 초기화를 사용합니다. [...nextauth].js 설정 파일은 결국 일반적인 API 경로에 불과하다는 점을 명심하세요. NextAuth.js를 다음과 같이 초기화할 수 있습니다. /pages/api/auth/[...nextauth].ts ts import type { NextApiRequest, NextApiResponse } from &quot;next&quot; import NextAuth from &quot;next-auth&quot; export default async function auth(req: NextApiRequest, res: NextApiResponse) { // 요청이 NextAuth로 전달되기 전에 여기에서 원하는 작업을 수행합니다. return await NextAuth(req, res, { ... }) } 복사 /pages/api/auth/[...nextauth].ts ts import type { NextApiRequest, NextApiResponse } from &quot;next&quot; import NextAuth from &quot;next-auth&quot; export default async function auth(req: NextApiRequest, res: NextApiResponse) { // 요청이 NextAuth로 전달되기 전에 여기에서 원하는 작업을 수행합니다. return await NextAuth(req, res, { ... }) } 복사 ... 부분은 여전히 옵션입니다. 하지만 이제 요청의 어떤 것을 실행하거나 수정할 수 있습니다. 예를 들어 요청을 기록하거나, 헤더를 추가하거나, query나 body 매개변수 읽는 작업 같이 API 경로에서 수행할만한 작업을 작성할 수 있습니다. 팁 이곳은 포괄 경로이므로 어떤 종류의 넥스트인증 작업이 실행되고 있는지 확인해야 합니다. REST API를 req.query.nextauth 매개변수와 비교하세요. 예를 들어 요청이 POST 메서드일 때 콜백 작업에서 무언가를 실행하려면 req.query.nextauth.includes(&quot;callback&quot;) &amp;&amp; req.method === &quot;POST&quot;로 확인할 수 있습니다. 참고 NextAuth는 res.end, res.send 등을 호출해 암시적으로 응답을 닫습니다. 따라서 함수 본문에서 NextAuth 이후에 코드를 실행해서는 안 됩니다. return NextAuth를 사용하면 잊지 않을 것입니다. 이 방법으로 만든 변수는 같은 스코프에 있으므로 NextAuth 옵션에서도 사용할 수 있습니다. /pages/api/auth/[...nextauth].ts ts import type { NextApiRequest, NextApiResponse } from &quot;next&quot; import NextAuth from &quot;next-auth&quot; export default async function auth(req: NextApiRequest, res: NextApiResponse) { if(req.query.nextauth.includes(&quot;callback&quot;) &amp;&amp; req.method === &quot;POST&quot;) { console.log( &quot;Handling callback request from my Identity Provider&quot;, req.body ) } // 요청에서 사용자 정의 쿠키 값을 가져옵니다. const someCookie = req.cookies[&quot;some-custom-cookie&quot;] return await NextAuth(req, res, { ... callbacks: { session({ session, token }) { // 세션의 일부로 쿠키 값을 반환합니다. // `req.query.nextauth.includes(&quot;session&quot;) &amp;&amp; req.method === &quot;GET&quot;`일 때 이 부분이 실행됩니다. session.someCookie = someCookie return session } } }) } 복사 /pages/api/auth/[...nextauth].ts ts import type { NextApiRequest, NextApiResponse } from &quot;next&quot; import NextAuth from &quot;next-auth&quot; export default async function auth(req: NextApiRequest, res: NextApiResponse) { if(req.query.nextauth.includes(&quot;callback&quot;) &amp;&amp; req.method === &quot;POST&quot;) { console.log( &quot;Handling callback request from my Identity Provider&quot;, req.body ) } // 요청에서 사용자 정의 쿠키 값을 가져옵니다. const someCookie = req.cookies[&quot;some-custom-cookie&quot;] return await NextAuth(req, res, { ... callbacks: { session({ session, token }) { // 세션의 일부로 쿠키 값을 반환합니다. // `req.query.nextauth.includes(&quot;session&quot;) &amp;&amp; req.method === &quot;GET&quot;`일 때 이 부분이 실행됩니다. session.someCookie = someCookie return session } } }) } 복사 실용적인 예는 기본 로그인 페이지에 특정 제공자를 표시하지 않지만 여전히 해당 제공자로 로그인이 가능하게 만드는 것입니다. (발상은 이 토론에서 나왔습니다.): /pages/api/auth/[...nextauth].js js import NextAuth from &quot;next-auth&quot; import CredentialsProvider from &quot;next-auth/providers/credentials&quot; import GoogleProvider from &quot;next-auth/providers/google&quot; export default async function auth(req, res) { const providers = [ CredentialsProvider(...), GoogleProvider(...), ] const isDefaultSigninPage = req.method === &quot;GET&quot; &amp;&amp; req.query.nextauth.includes(&quot;signin&quot;) // '/api/auth/signin'을 방문할 때 GoogleProvider를 숨깁니다. if (isDefaultSigninPage) providers.pop() return await NextAuth(req, res, { providers, ... }) } 복사 /pages/api/auth/[...nextauth].js js import NextAuth from &quot;next-auth&quot; import CredentialsProvider from &quot;next-auth/providers/credentials&quot; import GoogleProvider from &quot;next-auth/providers/google&quot; export default async function auth(req, res) { const providers = [ CredentialsProvider(...), GoogleProvider(...), ] const isDefaultSigninPage = req.method === &quot;GET&quot; &amp;&amp; req.query.nextauth.includes(&quot;signin&quot;) // '/api/auth/signin'을 방문할 때 GoogleProvider를 숨깁니다. if (isDefaultSigninPage) providers.pop() return await NextAuth(req, res, { providers, ... }) } 복사 사용 가능한 모든 작업과 지원 메서드에 대한 자세한 내용은 REST API 문서나 소스 코드의 해당 부분을 확인하세요. NextAuth를 초기화하는 이 방법은 매우 강력하지만 필요할 때만 사용해야 합니다. 위험 기본 쿠키를 건드리는 것과 같이 NextAuth에 필수적인 요청의 일부를 변경하면 예기치 않은 결과와 보안 취약점이 발생할 수 있습니다. 결과를 이해한 경우에만 변경하세요. "},{"title":"클라이언트 API","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API","content":"","keywords":""},{"title":"useSession()​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#usesession","content":"클라이언트 측 - 예서버 측 - 아니오 넥스트인증 클라이언트의 useSession() 리액트 훅은 누군가 로그인했는지 확인하는 가장 쉬운 방법입니다. SessionProvider가 pages/_app.js에 추가되었는지 확인해야 합니다. 예시: jsx import { useSession } from &quot;next-auth/react&quot; export default function Component() { const { data: session, status } = useSession() if (status === &quot;authenticated&quot;) { return &lt;p&gt;Signed in as {session.user.email}&lt;/p&gt; } return &lt;a href=&quot;/api/auth/signin&quot;&gt;Sign in&lt;/a&gt; } 복사 jsx import { useSession } from &quot;next-auth/react&quot; export default function Component() { const { data: session, status } = useSession() if (status === &quot;authenticated&quot;) { return &lt;p&gt;Signed in as {session.user.email}&lt;/p&gt; } return &lt;a href=&quot;/api/auth/signin&quot;&gt;Sign in&lt;/a&gt; } 복사 useSession()은 다음 두 개의 값을 포함하는 객체를 반환합니다. data - 세 가지 값이 될 수 있습니다. 세션을 아직 가져오지 않았을 때 undefined세션 검색에 실패한 경우 null성공할 경우 Session status - 가능한 세 가지 세션 상태에 대한 열거형 매핑 &quot;loading&quot; | &quot;authenticated&quot; | &quot;unauthenticated&quot; "},{"title":"세션이 필요​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#세션이-필요","content":"넥스트의 getServerSideProps와 getInitialProps 작동 방식 때문에, 모든 보호된 페이지 로드는 세션이 유효한지 확인한 이후에 요청된 페이지(SSR)를 생성하기 위해 서버 측 요청을 해야 합니다. 이렇게 하면 서버 부하가 증가하므로 클라이언트 요청에 능숙하다면 대안이 있습니다. useSession을 사용해 항상 유효한 세션이 있는지 확인하는 것입니다. 초기 로드 상태 이후에 세션을 찾지 못한 경우 적절한 응답을 할 수 있습니다. 기본 동작은 사용자를 로그인 페이지로 리디렉션하는 것입니다. 여기서 로그인에 성공하면 시작한 페이지로 다시 보내집니다. 다른 작업을 수행하고 싶다면 onFail() 콜백을 정의합니다. 예시: pages/protected.jsx jsx import { useSession } from &quot;next-auth/react&quot; export default function Admin() { const { status } = useSession({ required: true, onUnauthenticated() { // 인증받지 않은 사용자는 이곳에서 처리합니다. }, }) if (status === &quot;loading&quot;) { return &quot;Loading or not authenticated...&quot; } return &quot;User is logged in&quot; } 복사 pages/protected.jsx jsx import { useSession } from &quot;next-auth/react&quot; export default function Admin() { const { status } = useSession({ required: true, onUnauthenticated() { // 인증받지 않은 사용자는 이곳에서 처리합니다. }, }) if (status === &quot;loading&quot;) { return &quot;Loading or not authenticated...&quot; } return &quot;User is logged in&quot; } 복사 "},{"title":"커스텀 클라이언트 세션 처리​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#커스텀-클라이언트-세션-처리","content":"넥스트의 getServerSideProps와 getInitialProps 작동 방식 때문에, 모든 보호된 페이지 로드는 세션이 유효한지 확인한 이후에 요청된 페이지를 생성하기 위해 서버 측 요청을 해야 합니다. 이 대체 솔루션을 사용하면 서버를 확인하고 페이지를 다시 생성할 필요 없이, 초기 확인에서 로드 상태를 표시할 수 있으며 이후의 모든 페이지 전환은 클라이언트 측에서 처리합니다. pages/admin.jsx jsx export default function AdminDashboard() { const { data: session } = useSession() // 이 페이지 내의 리액트 트리에서는 세션이 항상 null이 아닙니다. return &quot;Some super secret dashboard&quot; } AdminDashboard.auth = true 복사 pages/admin.jsx jsx export default function AdminDashboard() { const { data: session } = useSession() // 이 페이지 내의 리액트 트리에서는 세션이 항상 null이 아닙니다. return &quot;Some super secret dashboard&quot; } AdminDashboard.auth = true 복사 pages/_app.jsx jsx export default function App({ Component, pageProps: { session, ...pageProps }, }) { return ( &lt;SessionProvider session={session}&gt; {Component.auth ? ( &lt;Auth&gt; &lt;Component {...pageProps} /&gt; &lt;/Auth&gt; ) : ( &lt;Component {...pageProps} /&gt; )} &lt;/SessionProvider&gt; ) } function Auth({ children }) { // { required: true }가 제공된다면, status는 &quot;loading&quot;이나 &quot;authenticated&quot;만 가능합니다. const { status } = useSession({ required: true }) if (status === &quot;loading&quot;) { return &lt;div&gt;Loading...&lt;/div&gt; } return children } 복사 pages/_app.jsx jsx export default function App({ Component, pageProps: { session, ...pageProps }, }) { return ( &lt;SessionProvider session={session}&gt; {Component.auth ? ( &lt;Auth&gt; &lt;Component {...pageProps} /&gt; &lt;/Auth&gt; ) : ( &lt;Component {...pageProps} /&gt; )} &lt;/SessionProvider&gt; ) } function Auth({ children }) { // { required: true }가 제공된다면, status는 &quot;loading&quot;이나 &quot;authenticated&quot;만 가능합니다. const { status } = useSession({ required: true }) if (status === &quot;loading&quot;) { return &lt;div&gt;Loading...&lt;/div&gt; } return children } 복사 페이지에서 역할 기반 인증을 위한 옵션 객체와 같은 것을 지원하도록 쉽게 확장하거나 수정할 수 있습니다. 예시: pages/admin.jsx jsx AdminDashboard.auth = { role: &quot;admin&quot;, loading: &lt;AdminLoadingSkeleton /&gt;, unauthorized: &quot;/login-with-different-user&quot;, // 이 url로 리디렉션됩니다. } 복사 pages/admin.jsx jsx AdminDashboard.auth = { role: &quot;admin&quot;, loading: &lt;AdminLoadingSkeleton /&gt;, unauthorized: &quot;/login-with-different-user&quot;, // 이 url로 리디렉션됩니다. } 복사 _app의 논리 덕분에 인증이 필요하지 않은 페이지는 /api/auth/session 엔드포인트에 불필요하게 연결되지 않습니다. 자세한 내용은 깃허브 이슈에서 확인하세요. "},{"title":"넥스트인증과 리액트 쿼리​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#넥스트인증과-리액트-쿼리","content":"리액트 쿼리 또는 SWR 같은 데이터 가져오기 라이브러리를 사용하여 자신만의 세션 관리 솔루션을 만들 수 있습니다. @next-auth/react-query의 원본 구현을 사용하고 next-auth/react 소스 코드를 시작점으로 삼을 수 있습니다. "},{"title":"getSession()​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#getsession","content":"클라이언트 측 - 예서버 측 - 아니오 (unstable_getServerSession() 참고) 넥스트인증은 현재 활성 세션을 반환하기 위해 클라이언트 측에서만 사용해야 하는 getSession() 헬퍼를 제공합니다. 서버 측에서 getSession()을 여전히 사용할 수는 있지만 앞으로는 unstable_getServerSession을 사용하는 것을 권장합니다. 이는 서버 측에서의 불필요한 추가 fetch 호출을 피하기 위함입니다. 자세한 내용은 이슈를 확인하세요. 참고 API는 향후 변경될 수 있으므로 unstable_getServerSession에는 현재 unstable_ 접두사가 붙어 있습니다. 현재 알려진 버그는 없으며 사용에 문제가 없습니다. 이 헬퍼는 리액트 컨텍스트 외부에서 세션을 읽으려는 경우에 유용합니다. getSession()은 호출되면 /api/auth/session에 요청을 보내고 세션 객체가 있는 프라미스를 반환합니다. 세션이 없으면 null을 반환합니다. jsx async function myFunction() { const session = await getSession() /* ... */ } 복사 jsx async function myFunction() { const session = await getSession() /* ... */ } 복사 페이지와 API 경로를 보호하는 방법을 읽고 unstability_getServerSession()을 사용해 서버 측 호출에서 세션을 가져오는 방법을 확인하세요. "},{"title":"getCsrfToken()​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#getcsrftoken","content":"클라이언트 측 - 예서버 측 - 예 getCsrfToken() 메서드는 POST 요청(예: 로그인 및 로그아웃)을 만드는 데 필요한 현재 사이트 간 요청 위조 토큰(CSRF 토큰)을 반환합니다. 내장 signIn()과 signOut() 메서드를 사용하지 않는 경우에만 이것을 사용해야 합니다. 클라이언트 측 예시: jsx async function myFunction() { const csrfToken = await getCsrfToken() /* ... */ } 복사 jsx async function myFunction() { const csrfToken = await getCsrfToken() /* ... */ } 복사 서버 측 예시: jsx import { getCsrfToken } from &quot;next-auth/react&quot; export default async (req, res) =&gt; { const csrfToken = await getCsrfToken({ req }) /* ... */ res.end() } 복사 jsx import { getCsrfToken } from &quot;next-auth/react&quot; export default async (req, res) =&gt; { const csrfToken = await getCsrfToken({ req }) /* ... */ res.end() } 복사 "},{"title":"getProviders()​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#getproviders","content":"클라이언트 측 - 예서버 측 - 예 getProviders() 메서드는 현재 로그인에 설정된 제공자 목록을 반환합니다. /api/auth/providers를 호출하고 현재 설정된 인증 제공자 목록을 반환합니다. 동적 커스텀 로그인 페이지를 만들 때 유용합니다. API 경로 예시: pages/api/example.js jsx import { getProviders } from &quot;next-auth/react&quot; export default async (req, res) =&gt; { const providers = await getProviders() console.log(&quot;Providers&quot;, providers) res.end() } 복사 pages/api/example.js jsx import { getProviders } from &quot;next-auth/react&quot; export default async (req, res) =&gt; { const providers = await getProviders() console.log(&quot;Providers&quot;, providers) res.end() } 복사 참고 getCsrfToken()와 달리, 서버 측에서 getProviders()를 호출할 때 클라이언트 측에서 호출하는 것처럼 아무 것도 건네줄 필요가 없습니다. "},{"title":"signIn()​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#signin","content":"클라이언트 측 - 예서버 측 - 아니오 signIn() 메서드는 사용자가 로그인 과정을 완료하고 시작한 페이지로 돌아갈 것을 보장합니다. 또한 이메일로 로그인할 때 이 메서드가 자동으로 CSRF 토큰을 처리합니다. signIn() 메서드는 다음과 같이 클라이언트에서 다양한 방식으로 호출할 수 있습니다. "},{"title":"클릭 시 로그인 페이지로 리디렉션하기​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#클릭-시-로그인-페이지로-리디렉션하기","content":"jsx import { signIn } from &quot;next-auth/react&quot; export default () =&gt; &lt;button onClick={() =&gt; signIn()}&gt;Sign in&lt;/button&gt; 복사 jsx import { signIn } from &quot;next-auth/react&quot; export default () =&gt; &lt;button onClick={() =&gt; signIn()}&gt;Sign in&lt;/button&gt; 복사 "},{"title":"클릭 시 OAuth 로그인 흐름 시작하기​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#클릭-시-oauth-로그인-흐름-시작하기","content":"인수 없이 signIn() 메서드를 호출하면 넥스트인증 로그인 페이지로 리디렉션됩니다. 이를 건너뛰고 공급자 페이지로 리디렉션하려면 공급자의 id로 signIn()을 호출합니다. 다음 예시는 구글 로그인입니다. jsx import { signIn } from &quot;next-auth/react&quot; export default () =&gt; ( &lt;button onClick={() =&gt; signIn(&quot;google&quot;)}&gt;Sign in with Google&lt;/button&gt; ) 복사 jsx import { signIn } from &quot;next-auth/react&quot; export default () =&gt; ( &lt;button onClick={() =&gt; signIn(&quot;google&quot;)}&gt;Sign in with Google&lt;/button&gt; ) 복사 "},{"title":"클릭 시 이메일 로그인 흐름 시작하기​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#클릭-시-이메일-로그인-흐름-시작하기","content":"이메일 흐름과 함께 사용할 경우 타겟 email을 옵션으로 전달합니다. jsx import { signIn } from &quot;next-auth/react&quot; export default ({ email }) =&gt; ( &lt;button onClick={() =&gt; signIn(&quot;email&quot;, { email })}&gt;Sign in with Email&lt;/button&gt; ) 복사 jsx import { signIn } from &quot;next-auth/react&quot; export default ({ email }) =&gt; ( &lt;button onClick={() =&gt; signIn(&quot;email&quot;, { email })}&gt;Sign in with Email&lt;/button&gt; ) 복사 "},{"title":"callbackUrl 지정하기​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#callbackurl-지정하기","content":"callbackUrl은 로그인 후 사용자가 리디렉션될 URL을 지정합니다. 기본값은 사용자의 현재 URL입니다. signIn()의 두 번째 인수로 다른 callbackUrl을 지정할 수 있습니다. 이것은 모든 제공자에 적용됩니다. 예시: jsx signIn(undefined, { callbackUrl: '/foo' }) 복사 jsx signIn(undefined, { callbackUrl: '/foo' }) 복사 jsx signIn('google', { callbackUrl: 'http://localhost:3000/bar' }) 복사 jsx signIn('google', { callbackUrl: 'http://localhost:3000/bar' }) 복사 jsx signIn('email', { email, callbackUrl: 'http://localhost:3000/foo' }) 복사 jsx signIn('email', { email, callbackUrl: 'http://localhost:3000/foo' }) 복사 URL은 리디렉션 콜백 핸들러에서 유효한 것이어야 합니다. 기본적으로 URL은 동일한 호스트 이름의 절대 URL이거나 /로 시작하는 상대 URL이어야 합니다. 일치하지 않으면 홈페이지로 리디렉션됩니다. 다른 URL을 허용하도록 고유한 리디렉션 콜백을 정의하는 것도 가능합니다. "},{"title":"redirect: false 옵션 사용하기​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#redirect-false-옵션-사용하기","content":"참고 리디렉션 옵션은 credentials과 email 제공자에서만 사용 가능합니다. 경우에 따라 동일한 페이지에서 로그인 응답을 처리하고 기본 리디렉션을 비활성화할 수 있습니다. 예를 들어 오류가 발생하는 경우(예: 사용자가 잘못된 자격 증명을 제공) 동일한 페이지에서 오류를 처리할 수 있습니다. 이를 위해 두 번째 매개변수 객체에 redirect: false를 전달합니다. 예시: jsx signIn('credentials', { redirect: false, password: 'password' }) 복사 jsx signIn('credentials', { redirect: false, password: 'password' }) 복사 jsx signIn('email', { redirect: false, email: 'bill@fillmurray.com' }) 복사 jsx signIn('email', { redirect: false, email: 'bill@fillmurray.com' }) 복사 그러면 signIn에서 다음과 같이 이행되는 프라미스를 반환합니다. json { /** * 오류의 유형에 따라 다른 오류 코드가 될 것입니다. */ error: string | undefined /** * HTTP 상태 코드로, 발생한 오류의 종류를 나타냅니다. */ status: number /** * 로그인이 성공했다면 true입니다. */ ok: boolean /** * 오류가 있었다면 null입니다. * 그러지 않으면 사용자가 리디렉션될 url입니다. */ url: string | null } 복사 json { /** * 오류의 유형에 따라 다른 오류 코드가 될 것입니다. */ error: string | undefined /** * HTTP 상태 코드로, 발생한 오류의 종류를 나타냅니다. */ status: number /** * 로그인이 성공했다면 true입니다. */ ok: boolean /** * 오류가 있었다면 null입니다. * 그러지 않으면 사용자가 리디렉션될 url입니다. */ url: string | null } 복사 "},{"title":"추가 매개변수​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#추가-매개변수","content":"signIn()의 세 번째 인수로 /authorize 엔드포인트에 추가 매개변수를 전달할 수 있습니다. 몇 가지 아이디어는 인증 요청 OIDC 사양을 참고합니다. (이것만이 가능한 것은 아니며 모든 매개변수가 전달됨) 예시: jsx // 항상 사용자에게 재인증을 요청 signIn(&quot;identity-server4&quot;, null, { prompt: &quot;login&quot; }) 복사 jsx // 항상 사용자에게 재인증을 요청 signIn(&quot;identity-server4&quot;, null, { prompt: &quot;login&quot; }) 복사 jsx // 제공자에게 이메일 주소를 알려줌 signIn(&quot;auth0&quot;, null, { login_hint: &quot;info@example.com&quot; }) 복사 jsx // 제공자에게 이메일 주소를 알려줌 signIn(&quot;auth0&quot;, null, { login_hint: &quot;info@example.com&quot; }) 복사 참고 provider.authorizationParams로 이 매개변수를 설정하는 것도 가능합니다. 참고 redirect_uri, state 매개변수는 항상 서버 측에서 재정의됩니다. "},{"title":"signOut()​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#signout","content":"클라이언트 측 - 예서버 측 - 아니오 signOut() 메서드를 사용하면 사용자가 로그아웃 흐름을 완료하고 시작한 페이지로 돌아갈 것을 보장합니다. 또한 이 메서드는 CSRF 토큰을 자동으로 처리합니다. 로그아웃이 완료되면 브라우저에서 페이지를 다시 로드합니다. jsx import { signOut } from &quot;next-auth/react&quot; export default () =&gt; &lt;button onClick={() =&gt; signOut()}&gt;Sign out&lt;/button&gt; 복사 jsx import { signOut } from &quot;next-auth/react&quot; export default () =&gt; &lt;button onClick={() =&gt; signOut()}&gt;Sign out&lt;/button&gt; 복사 "},{"title":"callbackUrl 지정하기​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#callbackurl-지정하기-1","content":"signIn() 함수와 동일하게 callbackUrl 매개변수를 옵션으로 전달할 수 있습니다. 예시: jsx signOut({ callbackUrl: 'http://localhost:3000/foo' }) 복사 jsx signOut({ callbackUrl: 'http://localhost:3000/foo' }) 복사 URL은 리디렉션 콜백 핸들러에서 유효한 것이어야 합니다. 기본적으로 URL은 동일한 호스트 이름의 절대 URL이거나 /로 시작하는 상대 URL이어야 합니다. 일치하지 않으면 홈페이지로 리디렉션됩니다. 다른 URL을 허용하도록 고유한 리디렉션 콜백을 정의하는 것도 가능합니다. "},{"title":"redirect: false 옵션 사용하기​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#redirect-false-옵션-사용하기-1","content":"signOut에 redirect: false를 전달하면 페이지가 다시 로드되지 않습니다. 세션이 삭제되고 useSession 훅에 알림이 전송되어 사용자와 관련된 모든 것이 자동으로 로그아웃됩니다. 이는 사용자에게 매우 만족스러운 경험을 선사합니다. 팁 다른 페이지로 리디렉션하면서도 페이지를 다시 로드하지 않으려면 const data = waitsignOut({redirect: false, callbackUrl: &quot;/foo&quot;})를 시도해 보세요. 여기서 data.url은 넥스트의 useRouter().push(data.url)을 사용하여 깜빡임 없이 사용자를 리디렉션할 수 있는 유효한 URL입니다. "},{"title":"SessionProvider​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#sessionprovider","content":"제공된 &lt;SessionProvider&gt;를 사용하면 useSession()의 인스턴스가 장막 뒤에서 리액트 컨텍스트를 사용해 컴포넌트 간에 세션 객체를 공유합니다. 또한 탭·창 간에 세션을 업데이트하고 동기화되게 관리합니다. pages/_app.js jsx import { SessionProvider } from &quot;next-auth/react&quot; export default function App({ Component, pageProps: { session, ...pageProps }, }) { return ( &lt;SessionProvider session={session}&gt; &lt;Component {...pageProps} /&gt; &lt;/SessionProvider&gt; ) } 복사 pages/_app.js jsx import { SessionProvider } from &quot;next-auth/react&quot; export default function App({ Component, pageProps: { session, ...pageProps }, }) { return ( &lt;SessionProvider session={session}&gt; &lt;Component {...pageProps} /&gt; &lt;/SessionProvider&gt; ) } 복사 위의 예시와 같이 &lt;SessionProvider&gt;에 session 페이지 프롭을 전달하면 서버 측과 클라이언트 측 렌더링을 모두 지원하는 페이지에서 세션을 두 번 확인하는 것을 피할 수 있습니다. 그러나 이는 올바른 pageProps를 건네준 페이지에서만 유효합니다. 보통은 다음과 같이 getInitialProps나 getServerSideProps에서 개별 페이지 단위로 수행됩니다. pages/index.js jsx import { unstable_getServerSession } from &quot;next-auth/next&quot; import { authOptions } from './api/auth/[...nextauth]' ... export async function getServerSideProps({ req, res }) { return { props: { session: await unstable_getServerSession(req, res, authOptions) } } } 복사 pages/index.js jsx import { unstable_getServerSession } from &quot;next-auth/next&quot; import { authOptions } from './api/auth/[...nextauth]' ... export async function getServerSideProps({ req, res }) { return { props: { session: await unstable_getServerSession(req, res, authOptions) } } } 복사 _app의 getInitialProps에서 모든 페이지를 보호할 수 있습니다. 또는 페이지 단위로 이를 수행할 수 있습니다. 또는 대체 클라이언트 세션 처리에서 아래의 메서드를 사용해 각 인증 확인(SSR)을 차단하는 대신 페이지별 인증 확인이 가능합니다. "},{"title":"옵션​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#옵션","content":"세션 상태는 열려 있는 모든 탭·창에서 자동으로 동기화되며 refetchOnWindowFocus가 true일 때는 포커스를 얻거나, 잃거나, 상태가 변경될 때(예: 사용자가 로그인 또는 로그아웃)마다 모두 업데이트됩니다. 세션 만료 시간이 30일(기본값) 이상이라면 제공자의 기본 옵션을 변경할 필요가 없습니다. 필요한 경우 클라이언트 측 함수에서 getSession()을 호출하여 모든 탭·창에서 세션 객체의 업데이트를 트리거할 수 있습니다. 그러나 세션 동작을 커스터마이즈하고 싶거나 짧은 세션 만료 시간을 원한다면, 해당 옵션을 제공자에게 건네줘서 useSession() 훅의 동작을 커스터마이즈합니다. pages/_app.js jsx import { SessionProvider } from &quot;next-auth/react&quot; export default function App({ Component, pageProps: { session, ...pageProps }, }) { return ( &lt;SessionProvider session={session} // 커스텀 경로를 사용하며 앱이 &quot;/&quot;가 아닌 &quot;/cool-app&quot; 경로에 있는 경우 basePath=&quot;cool-app&quot; // 5분마다 세션을 다시 가져온다. refetchInterval={5 * 60} // 윈도우가 포커스되면 세션을 다시 가져온다. refetchOnWindowFocus={true} &gt; &lt;Component {...pageProps} /&gt; &lt;/SessionProvider&gt; ) } 복사 pages/_app.js jsx import { SessionProvider } from &quot;next-auth/react&quot; export default function App({ Component, pageProps: { session, ...pageProps }, }) { return ( &lt;SessionProvider session={session} // 커스텀 경로를 사용하며 앱이 &quot;/&quot;가 아닌 &quot;/cool-app&quot; 경로에 있는 경우 basePath=&quot;cool-app&quot; // 5분마다 세션을 다시 가져온다. refetchInterval={5 * 60} // 윈도우가 포커스되면 세션을 다시 가져온다. refetchOnWindowFocus={true} &gt; &lt;Component {...pageProps} /&gt; &lt;/SessionProvider&gt; ) } 복사 참고 이 옵션은 로그인하지 않은 클라이언트에는 영향을 미치지 않습니다. 모든 탭·창은 로컬 세션 상태의 자체 복사본을 유지 관리합니다. 세션은 로컬스토리지나 세션스토리지와 같은 공유 저장소에 저장되지 않습니다. 한 탭·창의 업데이트는 다른 탭·창에 대한 메시지를 트리거하여 자체 세션 상태를 업데이트합니다. refetchInterval에 작은 값을 사용하면 인증된 클라이언트의 네트워크 트래픽과 부하가 증가하고 호스팅 비용과 성능에 영향을 미칠 수 있습니다. 기본 경로​ 커스텀 기본 경로를 사용 중이고 앱 진입점이 도메인의 루트 /가 아니라 다른 곳(예: /my-app/)인 경우, basePath 프롭을 사용하여 넥스트인증이 이를 인식하게 만들고 모든 리디렉션 및 세션 처리가 예상대로 작동되게 합니다. 다시 가져오기 간격​ refetchInterval 옵션을 사용하면 서버에 연결하여 세션 만료를 막을 수 있습니다. refetchInterval을 0(기본값)으로 설정하면 세션 폴링이 없습니다. 클라이언트가 세션 상태를 업데이트하기 위해 서버에 접속해야 하는 빈도를 초 단위로 지정합니다. 다시 가져오기가 트리거될 때 세션 상태가 만료되었다면 열려 있는 모든 탭·창이 이를 반영하도록 업데이트됩니다. refetchInterval의 값은 항상 세션의 maxAge 세션 옵션의 값보다 작아야 합니다. 창이 포커스되면 다시 가져오기​ refetchOnWindowFocus 옵션을 사용하여 탭·창에서 포커스를 전환할 때의 세션 상태 자동 업데이트를 설정할 수 있습니다. refetchOnWindowFocus를 true(기본값)로 설정하면 탭·창이 포커스를 얻거나 잃을 때 탭·창이 업데이트되고 컴포넌트의 상태가 초기화됩니다. 그러나 false로 설정된 경우, 세션 다시 가져오기를 중지하고 컴포넌트는 그대로 유지됩니다. 참고 넥스트 앱의 _app.js에 대한 자세한 내용은 넥스트 문서를 참고하세요. "},{"title":"커스텀 기본 경로​","type":1,"pageTitle":"클라이언트 API","url":"/docs-repository/docs/miscellaneous/next-auth-js/기초/클라이언트-API#커스텀-기본-경로","content":"넥스트 앱이 커스텀 기본 경로를 사용하는 경우, 아래 예시와 이곳에 설명된 대로 NEXTAUTH_URL 환경 변수를 API 엔드포인트의 전체 경로로 설정합니다. 또한 아래 예시와 같이 &lt;SessionProvider&gt;에 basePath 페이지 프롭을 전달하여 넥스트인증에서 커스텀 기본 경로를 완전히 설정하고 사용되게 합니다. 다음 예시에서 사용된 커스텀 기본 경로는 /custom-route입니다. NEXTAUTH_URL=https://example.com/custom-route/api/auth 복사 NEXTAUTH_URL=https://example.com/custom-route/api/auth 복사 pages/_app.js jsx import { SessionProvider } from &quot;next-auth/react&quot; export default function App({ Component, pageProps: { session, ...pageProps }, }) { return ( &lt;SessionProvider session={session} basePath=&quot;/custom-route/api/auth&quot;&gt; &lt;Component {...pageProps} /&gt; &lt;/SessionProvider&gt; ) } 복사 pages/_app.js jsx import { SessionProvider } from &quot;next-auth/react&quot; export default function App({ Component, pageProps: { session, ...pageProps }, }) { return ( &lt;SessionProvider session={session} basePath=&quot;/custom-route/api/auth&quot;&gt; &lt;Component {...pageProps} /&gt; &lt;/SessionProvider&gt; ) } 복사 "},{"title":"시작하기","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/next-auth-js/시작하기","content":"","keywords":""},{"title":"새로운 프로젝트​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/miscellaneous/next-auth-js/시작하기#새로운-프로젝트","content":"가장 쉬운 방법은 예시 앱을 복제하고 README.md의 지침을 따르는 것입니다. https://next-auth-example.vercel.app/에서 라이브 데모를 확인할 수 있습니다. "},{"title":"기존 프로젝트​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/miscellaneous/next-auth-js/시작하기#기존-프로젝트","content":""},{"title":"넥스트인증 설치하기​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/miscellaneous/next-auth-js/시작하기#넥스트인증-설치하기","content":"npmYarn bash npm install next-auth 복사 bash npm install next-auth 복사 정보 타입스크립트를 사용하는 경우 넥스트인증는 패키지 내에서 타입 정의와 함께 제공됩니다. next-auth의 타입스크립트에 대해 자세히 알아보려면 타입스크립트 문서를 확인하세요. "},{"title":"API 경로 추가하기​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/miscellaneous/next-auth-js/시작하기#api-경로-추가하기","content":"프로젝트에 넥스트인증을 추가하려면 pages/api/auth에 [...nextauth].js라는 파일을 만듭니다. 이 파일에는 모든 전역 넥스트인증 설정과 동적 경로 핸들러가 포함됩니다. pages/api/auth/[...nextauth].js js import NextAuth from &quot;next-auth&quot; import GithubProvider from &quot;next-auth/providers/github&quot; export default NextAuth({ // 하나 이상의 인증 제공자를 설정합니다. providers: [ GithubProvider({ clientId: process.env.GITHUB_ID, clientSecret: process.env.GITHUB_SECRET, }), // ...여기에 제공자를 추가합니다. ], }) 복사 pages/api/auth/[...nextauth].js js import NextAuth from &quot;next-auth&quot; import GithubProvider from &quot;next-auth/providers/github&quot; export default NextAuth({ // 하나 이상의 인증 제공자를 설정합니다. providers: [ GithubProvider({ clientId: process.env.GITHUB_ID, clientSecret: process.env.GITHUB_SECRET, }), // ...여기에 제공자를 추가합니다. ], }) 복사 /api/auth/*(signIn, callback, signOut 등)에 대한 모든 요청은 넥스트인증에서 자동으로 처리됩니다. 공유 세션 상태 설정하기​ useSession을 사용하려면 먼저 앱의 최상위 수준에 세션 컨텍스트 SessionProvider를 노출해야 합니다. pages/_app.jsx tsx import { SessionProvider } from &quot;next-auth/react&quot; export default function App({ Component, pageProps: { session, ...pageProps }, }) { return ( &lt;SessionProvider session={session}&gt; &lt;Component {...pageProps} /&gt; &lt;/SessionProvider&gt; ) } 복사 pages/_app.jsx tsx import { SessionProvider } from &quot;next-auth/react&quot; export default function App({ Component, pageProps: { session, ...pageProps }, }) { return ( &lt;SessionProvider session={session}&gt; &lt;Component {...pageProps} /&gt; &lt;/SessionProvider&gt; ) } 복사 그러면 useSession의 인스턴스가 세션 데이터와 상태에 접근할 수 있습니다. 또한 &lt;SessionProvider /&gt;는 브라우저 탭과 창 간에 세션을 업데이트하고 동기화합니다. "},{"title":"프런트엔드 - 리액트 훅 추가하기​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/miscellaneous/next-auth-js/시작하기#프런트엔드---리액트-훅-추가하기","content":"넥스트인증 클라이언트의 useSession() 리액트 훅은 누군가 로그인했는지 확인하는 가장 쉬운 방법입니다. components/login-btn.jsx jsx import { useSession, signIn, signOut } from &quot;next-auth/react&quot; export default function Component() { const { data: session } = useSession() if (session) { return ( &lt;&gt; Signed in as {session.user.email} &lt;br /&gt; &lt;button onClick={() =&gt; signOut()}&gt;Sign out&lt;/button&gt; &lt;/&gt; ) } return ( &lt;&gt; Not signed in &lt;br /&gt; &lt;button onClick={() =&gt; signIn()}&gt;Sign in&lt;/button&gt; &lt;/&gt; ) } 복사 components/login-btn.jsx jsx import { useSession, signIn, signOut } from &quot;next-auth/react&quot; export default function Component() { const { data: session } = useSession() if (session) { return ( &lt;&gt; Signed in as {session.user.email} &lt;br /&gt; &lt;button onClick={() =&gt; signOut()}&gt;Sign out&lt;/button&gt; &lt;/&gt; ) } return ( &lt;&gt; Not signed in &lt;br /&gt; &lt;button onClick={() =&gt; signIn()}&gt;Sign in&lt;/button&gt; &lt;/&gt; ) } 복사 앱의 모든 위치(예: 헤더 컴포넌트)에서 useSession 훅을 사용할 수 있습니다. "},{"title":"백엔드 - API 경로​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/miscellaneous/next-auth-js/시작하기#백엔드---api-경로","content":"경로 API를 보호하기 위해 unstable_getServerSession() 메서드를 사용할 수 있습니다. pages/api/restricted.js jsx import { unstable_getServerSession } from &quot;next-auth/next&quot; import { authOptions } from &quot;./auth/[...nextauth]&quot; export default async (req, res) =&gt; { const session = await unstable_getServerSession(req, res, authOptions) if (session) { res.send({ content: &quot;This is protected content. You can access this content because you are signed in.&quot;, }) } else { res.send({ error: &quot;You must be sign in to view the protected content on this page.&quot;, }) } } 복사 pages/api/restricted.js jsx import { unstable_getServerSession } from &quot;next-auth/next&quot; import { authOptions } from &quot;./auth/[...nextauth]&quot; export default async (req, res) =&gt; { const session = await unstable_getServerSession(req, res, authOptions) if (session) { res.send({ content: &quot;This is protected content. You can access this content because you are signed in.&quot;, }) } else { res.send({ error: &quot;You must be sign in to view the protected content on this page.&quot;, }) } } 복사 "},{"title":"확장성​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/miscellaneous/next-auth-js/시작하기#확장성","content":"넥스트인증 콜백 사용하기​ 넥스트인증을 사용하면 내장 콜백을 통해 인증 흐름의 다양한 부분에 연결할 수 있습니다. 예를 들어 로그인에서 클라이언트 측 프런트엔드로 값을 전달하려면 다음과 같이 session과 jwt 콜백 조합을 사용할 수 있습니다. pages/api/auth/[...nextauth].js js ... callbacks: { async jwt({ token, account }) { // 로그인 후 바로 토큰에 대한 OAuth access_token을 유지합니다. if (account) { token.accessToken = account.access_token } return token }, async session({ session, token, user }) { // 제공자의 access_token과 같은 프로퍼티를 클라이언트에게 보냅니다. session.accessToken = token.accessToken return session } } ... 복사 pages/api/auth/[...nextauth].js js ... callbacks: { async jwt({ token, account }) { // 로그인 후 바로 토큰에 대한 OAuth access_token을 유지합니다. if (account) { token.accessToken = account.access_token } return token }, async session({ session, token, user }) { // 제공자의 access_token과 같은 프로퍼티를 클라이언트에게 보냅니다. session.accessToken = token.accessToken return session } } ... 복사 이제 getSession이나 useSession를 호출할 때마다 반환되는 데이터 개체에 accessToken 값이 포함됩니다. components/accessToken.jsx jsx import { useSession, signIn, signOut } from &quot;next-auth/react&quot; export default function Component() { const { data } = useSession() const { accessToken } = data return &lt;div&gt;Access Token: {accessToken}&lt;/div&gt; } 복사 components/accessToken.jsx jsx import { useSession, signIn, signOut } from &quot;next-auth/react&quot; export default function Component() { const { data } = useSession() const { accessToken } = data return &lt;div&gt;Access Token: {accessToken}&lt;/div&gt; } 복사 "},{"title":"콜백 URL 설정하기 (OAuth만 해당)​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/miscellaneous/next-auth-js/시작하기#콜백-url-설정하기-oauth만-해당","content":"OAuth 제공자를 기본 제공자 중 하나 또는 커스텀 제공자를 통해 사용하는 경우, 제공자의 설정에서 콜백 URL을 지정해야 합니다. 각 제공자에는 수행 방법에 대한 포인터를 제공하는 '설정' 섹션이 있습니다. 이 단계에 따라 OAuth 제공자와 통합하는 방법을 배울 수 있습니다. "},{"title":"프로덕션에 배포하기​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/miscellaneous/next-auth-js/시작하기#프로덕션에-배포하기","content":"사이트를 배포할 때 NEXTAUTH_URL 환경 변수를 웹사이트의 표준 URL로 설정합니다. text NEXTAUTH_URL=https://example.com 복사 text NEXTAUTH_URL=https://example.com 복사 팁 프로덕션에서는 이 값을 앱을 배포하는 데 사용하는 서비스에서 환경 변수로 설정해야 합니다. 베르셀에서 환경 변수를 설정하려면 대시보드나 vercel env pull 명령을 사용합니다. "},{"title":"소개","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/regular-expression","content":"소개 정규 표현식(regular expression) 혹은 정규식(regex)은 텍스트를 찾고 조작하는 데 쓰는 문자열입니다. 정규 표현식은 텍스트를 조작하는 가장 강력한 도구 중 하나입니다. 정규 표현식을 사용하는 유형은 두 가지로 나뉩니다. 검색와 치환입니다. 유효성 검사도 일종의 검색입니다. 정규 표현식은 정규 표현 언어를 사용해 만듭니다. 정규 표현 언어는 완전한 프로그래밍 언어가 아닙니다. 다른 프로그래밍 언어나 제품에 포함된 작은 언어(mini language)일 때가 많습니다. 메타 문자는 정규 표현식에서 특별한 의미를 가지는 문자입니다. 팁: 정규 표현식으로 예상한 결과를 일치시키는 일은 쉽습니다. 하지만 원하지 않는 결과와 일치하지 않도록, 발생할 수 있는 상황을 모두 예상해 정규 표현식을 작성하는 일은 훨씬 어렵습니다. 정규 표현식에 옳고 그름은 없습니다. 얼마나 엄격하게 패턴을 일치시킬지에 따라 패턴이 복잡해지는 정도가 달라질 뿐입니다. 메타 문자를 순수한 문자로 사용할 때는 \\을 이용해 명시적으로 이스케이프하는 것이 좋습니다. 텍스트 형식을 바꿔야 할 때는 해당 텍스트를 여러 조각의 하위 표현식으로 나누는 편이 좋습니다.","keywords":""},{"title":"자격 증명","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/next-auth-js/제공자/자격-증명","content":"","keywords":""},{"title":"개요​","type":1,"pageTitle":"자격 증명","url":"/docs-repository/docs/miscellaneous/next-auth-js/제공자/자격-증명#개요","content":"자격 증명 제공자를 사용하면 사용자 이름과 비밀번호, 도메인, 이중 인증, 하드웨어 장치(예: YubiKey U2F / FIDO)와 같은 임의 자격 증명으로 로그인을 처리할 수 있습니다. 사용자를 인증해야 하는 기존 시스템이 있는 유스 케이스를 지원합니다. 이 방식으로 인증된 사용자는 데이터베이스에 저장되지 않습니다. 그리고 결과적으로 세션에 대해 JSON 웹 토큰이 활성화된 경우에만 자격 증명 제공자를 사용할 수 있다는 제약이 있습니다. 위험 자격 증명 기반 인증에 제공되는 기능은 비밀번호 사용을 막기 위해 의도적으로 제한됩니다. 이는 비밀번호와 관련된 고유한 보안 위험, 사용자 이름 및 비밀번호 지원과 관련된 추가 복잡성 때문입니다. "},{"title":"옵션​","type":1,"pageTitle":"자격 증명","url":"/docs-repository/docs/miscellaneous/next-auth-js/제공자/자격-증명#옵션","content":"자격 증명 제공자는 기본 옵션 세트와 함께 제공됩니다. 자격 증명 제공자 옵션 자신의 유스 케이스에 맞게 옵션을 재정의할 수 있습니다. "},{"title":"예시​","type":1,"pageTitle":"자격 증명","url":"/docs-repository/docs/miscellaneous/next-auth-js/제공자/자격-증명#예시","content":""},{"title":"사용자 이름과 비밀번호​","type":1,"pageTitle":"자격 증명","url":"/docs-repository/docs/miscellaneous/next-auth-js/제공자/자격-증명#사용자-이름과-비밀번호","content":"자격 증명 제공자는 다른 제공자와 거의 유사합니다. HTTP POST로 제출된 자격 증명을 입력으로 받고 다음 중 하나를 반환하는 authorize() 핸들러를 정의해야 한다는 점만 다릅니다. 자격 증명이 유효함을 나타내는 user 객체 이후에 객체를 거부하는 사용자 정의 signIn() 콜백이 설정되지 않았다면, 해당 객체는 JSON 웹 토큰에 저장되고 사용자가 로그인됩니다. null을 반환하면 사용자에게 세부 정보를 확인하라는 오류가 표시됨 오류가 발생하면 사용자는 오류 메시지가 쿼리 매개변수로 포함되어 오류 페이지로 전송됨 자격 증명 제공자의 authorize() 메서드는 두 번째 매개변수로 요청 객체를 제공합니다. 다음 예시를 참고하세요. pages/api/auth/[...nextauth].js js import CredentialsProvider from &quot;next-auth/providers/credentials&quot;; ... providers: [ CredentialsProvider({ // 로그인 폼에 표시할 이름 (예: '...로 로그인') name: &quot;Credentials&quot;, // 자격 증명은 로그인 페이지에서 적절한 폼을 생성하는 데 사용됩니다. // 제출할 것으로 예상되는 필드를 지정할 수 있습니다. // 예: 도메인, 사용자 이름, 비밀번호, 2FA 토큰 등 // 객체를 통해 HTML 속성을 &lt;input&gt; 태그로 전달할 수 있습니다. credentials: { username: { label: &quot;Username&quot;, type: &quot;text&quot;, placeholder: &quot;jsmith&quot; }, password: { label: &quot;Password&quot;, type: &quot;password&quot; } }, async authorize(credentials, req) { // 제공된 자격 증명에서 사용자를 조회하는 논리를 여기에 추가합니다. const user = { id: 1, name: &quot;J Smith&quot;, email: &quot;jsmith@example.com&quot; } if (user) { // 반환된 모든 객체는 JWT의 user 프로퍼티에 저장됩니다. return user } else { // null을 반환하면 사용자에게 세부 정보를 확인하라는 오류가 표시됩니다. return null // 오류와 함께 이 콜백을 거부할 수도 있으며 사용자는 오류 메시지가 쿼리 매개변수로 포함된 오류 페이지로 전송됩니다. } } }) ] ... 복사 pages/api/auth/[...nextauth].js js import CredentialsProvider from &quot;next-auth/providers/credentials&quot;; ... providers: [ CredentialsProvider({ // 로그인 폼에 표시할 이름 (예: '...로 로그인') name: &quot;Credentials&quot;, // 자격 증명은 로그인 페이지에서 적절한 폼을 생성하는 데 사용됩니다. // 제출할 것으로 예상되는 필드를 지정할 수 있습니다. // 예: 도메인, 사용자 이름, 비밀번호, 2FA 토큰 등 // 객체를 통해 HTML 속성을 &lt;input&gt; 태그로 전달할 수 있습니다. credentials: { username: { label: &quot;Username&quot;, type: &quot;text&quot;, placeholder: &quot;jsmith&quot; }, password: { label: &quot;Password&quot;, type: &quot;password&quot; } }, async authorize(credentials, req) { // 제공된 자격 증명에서 사용자를 조회하는 논리를 여기에 추가합니다. const user = { id: 1, name: &quot;J Smith&quot;, email: &quot;jsmith@example.com&quot; } if (user) { // 반환된 모든 객체는 JWT의 user 프로퍼티에 저장됩니다. return user } else { // null을 반환하면 사용자에게 세부 정보를 확인하라는 오류가 표시됩니다. return null // 오류와 함께 이 콜백을 거부할 수도 있으며 사용자는 오류 메시지가 쿼리 매개변수로 포함된 오류 페이지로 전송됩니다. } } }) ] ... 복사 토큰과 상호 작용하는 방법에 대한 내용은 콜백 문서를 참조하세요. "},{"title":"Web3와 이더리움으로 로그인​","type":1,"pageTitle":"자격 증명","url":"/docs-repository/docs/miscellaneous/next-auth-js/제공자/자격-증명#web3와-이더리움으로-로그인","content":"자격 증명 제공자를 사용하여 이더리움으로 로그인 같은 서비스와 통합할 수 있습니다. 자세한 내용은 다음 링크를 확인하세요. 튜토리얼예시 앱 저장소예시 앱 데모 "},{"title":"복수의 제공자​","type":1,"pageTitle":"자격 증명","url":"/docs-repository/docs/miscellaneous/next-auth-js/제공자/자격-증명#복수의-제공자","content":"각 자격 증명 제공자에 고유한 id를 지정하여 여러 개의 자격 증명 제공자를 지정할 수 있습니다. 다른 제공자 옵션과 함께 사용할 수도 있습니다. 다른 모든 제공자와 마찬가지로 지정 순서는 로그인 페이지에 표시되는 순서입니다. js providers: [ CredentialsProvider({ id: &quot;domain-login&quot;, name: &quot;Domain Account&quot;, async authorize(credentials, req) { const user = { /* 사용자를 얻는 함수 추가 */ } return user }, credentials: { domain: { label: &quot;Domain&quot;, type: &quot;text &quot;, placeholder: &quot;CORPNET&quot;, value: &quot;CORPNET&quot;, }, username: { label: &quot;Username&quot;, type: &quot;text &quot;, placeholder: &quot;jsmith&quot; }, password: { label: &quot;Password&quot;, type: &quot;password&quot; }, }, }), CredentialsProvider({ id: &quot;intranet-credentials&quot;, name: &quot;Two Factor Auth&quot;, async authorize(credentials, req) { const user = { /* 사용자를 얻는 함수 추가 */ } return user }, credentials: { email: { label: &quot;Username&quot;, type: &quot;text &quot;, placeholder: &quot;jsmith&quot; }, &quot;2fa-key&quot;: { label: &quot;2FA Key&quot; }, }, }), /* ... 추가 제공자 ... */ 복사 js providers: [ CredentialsProvider({ id: &quot;domain-login&quot;, name: &quot;Domain Account&quot;, async authorize(credentials, req) { const user = { /* 사용자를 얻는 함수 추가 */ } return user }, credentials: { domain: { label: &quot;Domain&quot;, type: &quot;text &quot;, placeholder: &quot;CORPNET&quot;, value: &quot;CORPNET&quot;, }, username: { label: &quot;Username&quot;, type: &quot;text &quot;, placeholder: &quot;jsmith&quot; }, password: { label: &quot;Password&quot;, type: &quot;password&quot; }, }, }), CredentialsProvider({ id: &quot;intranet-credentials&quot;, name: &quot;Two Factor Auth&quot;, async authorize(credentials, req) { const user = { /* 사용자를 얻는 함수 추가 */ } return user }, credentials: { email: { label: &quot;Username&quot;, type: &quot;text &quot;, placeholder: &quot;jsmith&quot; }, &quot;2fa-key&quot;: { label: &quot;2FA Key&quot; }, }, }), /* ... 추가 제공자 ... */ 복사  "},{"title":"메타 문자 사용하기","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/regular-expression/메타-문자-사용하기","content":"","keywords":""},{"title":"이스케이프​","type":1,"pageTitle":"메타 문자 사용하기","url":"/docs-repository/docs/miscellaneous/regular-expression/메타-문자-사용하기#이스케이프","content":"메타 문자 앞에 역슬래시 \\를 붙여 이스케이프할 수 있습니다. 예시: myArray\\[[0-9]\\] 복사 myArray\\[[0-9]\\] 복사 "},{"title":"공백 문자​","type":1,"pageTitle":"메타 문자 사용하기","url":"/docs-repository/docs/miscellaneous/regular-expression/메타-문자-사용하기#공백-문자","content":"메타 문자\t설명[\\b]\t백스페이스 \\f\t페이지 넘김(form feed) \\n\t줄바꿈 \\r\t캐리지 리턴 \\t\t탭 \\v\t수직 탭 \\r, \\n, \\t을 주로 사용합니다. "},{"title":"문자 클래스​","type":1,"pageTitle":"메타 문자 사용하기","url":"/docs-repository/docs/miscellaneous/regular-expression/메타-문자-사용하기#문자-클래스","content":"자주 쓰는 문자 집합들은 특수한 메타 문자로 대신할 수 있는데 이를 문자 클래스라고 부릅니다. 메타 문자\t설명\t동일한 정규 표현식\\d\t숫자 하나\t[0-9] \\D\t숫자를 제외한 문자 하나\t[^0-9] \\w\t대소문자와 밑줄을 포함하는 모든 영숫자\t[a-zA-Z0-9_] \\W\t영숫자나 밑줄이 아닌 모든 문자\t[^a-zA-Z0-9_] \\s\t모든 공백 문자\t[ \\f\\n\\r\\t\\v] \\S\t공백 문자가 아닌 모든 문자\t[^ \\f\\n\\r\\t\\v] 대문자 메타 문자는 주로 그에 대응하는 소문자 메타 문자와 반대되는 기능을 지닙니다. 대소문자를 구별하지 않고 검색을 수행할 때도 문법은 대소문자를 구별합니다. 예시: myArray\\[\\d\\] 복사 myArray\\[\\d\\] 복사 \\w\\d\\w\\d\\w\\d 복사 \\w\\d\\w\\d\\w\\d 복사 "},{"title":"16진수와 8진수 표현하기​","type":1,"pageTitle":"메타 문자 사용하기","url":"/docs-repository/docs/miscellaneous/regular-expression/메타-문자-사용하기#16진수와-8진수-표현하기","content":"16진수 값은 앞에 \\x를 붙여 표시합니다. 8진수 값은 앞에 \\0를 붙여 표시합니다. "},{"title":"포직스 문자 클래스​","type":1,"pageTitle":"메타 문자 사용하기","url":"/docs-repository/docs/miscellaneous/regular-expression/메타-문자-사용하기#포직스-문자-클래스","content":"자바스크립트에서는 지원하지 않습니다. 분류\t내용\t동일한 정규 표현식[:alnum:]\t모든 영숫자\t[a-zA-Z0-9] [:alpha:]\t모든 영문자\t[a-zA-Z] [:blank:]\t빈칸(space)이나 탭 문자 [:cntrl:]\t아스키 제어 문자(아스키 0번부터 31번, 127번) [:digit:]\t모든 한 자리 숫자\t[0-9] [:graph:]\t[:print:]와 동일하나 빈칸은 제외 [:lower:]\t모든 소문자\t[a-z] [:print:]\t출력 가능한 모든 문자 [:punct:]\t[:alnum:]이나 [:cntrl:]가 포함되지 않은 모든 문자 [:space:]\t빈칸을 포함한 모든 공백 문자\t[\\f\\n\\r\\t\\v] [:upper:]\t모든 대문자\t[A-Z] [:xdigit:]\t모든 16진수 숫자\t[a-fA-F0-9] 예를 들어 RGB 값을 찾을 때 #[[:xdigit:][:xdigit:][:xdigit:][:xdigit:][:xdigit:][:xdigit:]]을 이용할 수 있습니다. 주의 포직스 클래스를 사용할 때는 대괄호를 잊지 말아야 합니다. "},{"title":"메타 문자 정리","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/regular-expression/메타-문자-정리","content":"","keywords":""},{"title":"기본 메타 문자​","type":1,"pageTitle":"메타 문자 정리","url":"/docs-repository/docs/miscellaneous/regular-expression/메타-문자-정리#기본-메타-문자","content":"메타 문자\t설명.\t모든 문자 |\t또는 []\t집합 정의 [^]\t집합 제외 -\t범위 정의 \\\t이스케이프 "},{"title":"수량자​","type":1,"pageTitle":"메타 문자 정리","url":"/docs-repository/docs/miscellaneous/regular-expression/메타-문자-정리#수량자","content":"메타 문자\t설명*\t문자가 없거나 하나 이상 연속 +\t문자 하나 이상 ?\t문자가 없거나 하나 {n}\t요소와 n번 일치 {m,n}\t요소와 m~n번 일치 {n,}\t요소와 n번 이상 일치 *, +, {n,} 뒤에 ?를 붙여 게으르게 만들 수 있습니다. "},{"title":"위치 지정​","type":1,"pageTitle":"메타 문자 정리","url":"/docs-repository/docs/miscellaneous/regular-expression/메타-문자-정리#위치-지정","content":"메타 문자\t설명^\t문자열의 시작 $\t문자열의 끝 \\b\t단어 경계 \\B\t\\b의 반대 "},{"title":"문자 클래스​","type":1,"pageTitle":"메타 문자 정리","url":"/docs-repository/docs/miscellaneous/regular-expression/메타-문자-정리#문자-클래스","content":"메타 문자\t설명\\d\t모든 숫자 \\w\t영숫자 문자와 밑줄 \\s\t공백 문자 대문자는 반대 클래스입니다. "},{"title":"역참조와 전후방탐색​","type":1,"pageTitle":"메타 문자 정리","url":"/docs-repository/docs/miscellaneous/regular-expression/메타-문자-정리#역참조와-전후방탐색","content":"메타 문자\t설명()\t하위 표현식 정의 \\n\tn번째 하위 표현식 ?=\t전방탐색 ?&lt;=\t후방탐색 ?!\t부정형 전방탐색 ?&lt;!\t부정형 후방탐색 "},{"title":"대소문자 변환​","type":1,"pageTitle":"메타 문자 정리","url":"/docs-repository/docs/miscellaneous/regular-expression/메타-문자-정리#대소문자-변환","content":"메타 문자\t설명\\E\t\\L이나 \\U 변환을 끝냄 \\l\t다음에 오는 글자를 소문자로 변환 \\L\t\\E를 만날 때까지 모든 문자를 소문자로 변환 \\u\t다음에 오는 글자를 대문자로 변환 \\U\t\\E를 만날 때까지 모든 문자를 대문자로 변환 "},{"title":"문자 집합으로 찾기","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/regular-expression/문자-집합으로-찾기","content":"","keywords":""},{"title":"문자 집합​","type":1,"pageTitle":"문자 집합으로 찾기","url":"/docs-repository/docs/miscellaneous/regular-expression/문자-집합으로-찾기#문자-집합","content":"대괄호 []를 사용해 문자 집합을 표현합니다. 문자 집합은 특정 영역만 대소문자를 구별하지 않을 검색할 때 많이 사용합니다. 예시: [Rr]eg[Ee]x 복사 [Rr]eg[Ee]x 복사 .나 + 같은 메타 문자들이 집합의 구성원일 때는 문자 그대로 취급되므로 굳이 이스케이프할 필요가 없습니다. "},{"title":"문자 집합 범위 사용하기​","type":1,"pageTitle":"문자 집합으로 찾기","url":"/docs-repository/docs/miscellaneous/regular-expression/문자-집합으로-찾기#문자-집합-범위-사용하기","content":"문자 범위를 지정할 때 하이픈 -을 사용합니다. 예시: [A-Z][a-z][0-9][A-Za-z0-9] 주의 A-z에는 [와 ^ 같은 문자도 포함되므로 사용하지 말아야 합니다. 범위를 지정할 때는 더 큰 값이 앞에 나오면 안 됩니다. -은 [] 안에서만 메타 문자인 특수 메타 문자입니다. 집합 밖에서는 단순한 문자입니다. "},{"title":"제외하고 찾기​","type":1,"pageTitle":"문자 집합으로 찾기","url":"/docs-repository/docs/miscellaneous/regular-expression/문자-집합으로-찾기#제외하고-찾기","content":"지정한 목록을 제외하려면 캐럿 ^을 사용합니다. ^은 집합 안의 있는 문자나 범위를 모두 제외합니다. 예시: [ns]a[^0-9]\\.xls 복사 [ns]a[^0-9]\\.xls 복사 "},{"title":"문자 하나 찾기","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/regular-expression/문자-하나-찾기","content":"","keywords":""},{"title":"모든 문자 찾기​","type":1,"pageTitle":"문자 하나 찾기","url":"/docs-repository/docs/miscellaneous/regular-expression/문자-하나-찾기#모든-문자-찾기","content":"마침표 .는 아무 문자 하나와 일치합니다. 예시: sales. 복사 sales. 복사 참고 .은 대다수 정규 표현식 구현에서 줄바꿈 문자를 제외한 모든 문자와 일치합니다. "},{"title":"특수문자 찾기​","type":1,"pageTitle":"문자 하나 찾기","url":"/docs-repository/docs/miscellaneous/regular-expression/문자-하나-찾기#특수문자-찾기","content":"역슬래시 \\는 문자를 이스케이프합니다. 예를 들어 \\.은 마침표 문자를 의미합니다. 역슬래시 문자는 \\\\로 표현합니다. 예시: .a.\\.xls 복사 .a.\\.xls 복사 "},{"title":"역참조 사용하기","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/regular-expression/역참조-사용하기","content":"","keywords":""},{"title":"역참조로 찾기​","type":1,"pageTitle":"역참조 사용하기","url":"/docs-repository/docs/miscellaneous/regular-expression/역참조-사용하기#역참조로-찾기","content":"역참조(backreferences)는 앞에 나온 표현을 역으로 가리킵니다. 역참조를 변수라고 생각할 수 있습니다. 예시: [ ]+(\\w+)[ ]+\\1 복사 [ ]+(\\w+)[ ]+\\1 복사 예시의 \\1은 첫 번째 하위 표현식을 참조하며, 이는 (\\w+)을 참조한다는 것을 의미합니다. 참고 역참조 문법은 정규 표현식 구현에 따라 크게 다릅니다. 자바스크립트에서는 \\를 사용합니다. 다음 정규 표현식은 역참조를 이용해 짝이 맞는 헤더 태그만 찾습니다. &lt;[hH]([1-6])&gt;/*?&lt;\\/[hH]\\1&gt; 복사 &lt;[hH]([1-6])&gt;/*?&lt;\\/[hH]\\1&gt; 복사 일치하는 부분을 참조하는 숫자는 주로 1부터 시작합니다. 많은 구현에서 0번째 참조는 표현식 전체를 가리킵니다. 참고 일부 정규 표현식 구현은 '이름 붙여 저장하기' 기능을 지원합니다. 각 하위 표현식에 고유한 이름을 줄 수 있습니다. "},{"title":"치환 작업 수행하기​","type":1,"pageTitle":"역참조 사용하기","url":"/docs-repository/docs/miscellaneous/regular-expression/역참조-사용하기#치환-작업-수행하기","content":"이메일 주소에 링크를 걸고 싶다면 다음과 같이 정규 표현식을 활용할 수 있습니다. 예문: Hello, ben@forta.com is my email address. 복사 Hello, ben@forta.com is my email address. 복사 정규 표현식: (\\w+[\\w.]*@[\\w.]+\\.\\w+) 복사 (\\w+[\\w.]*@[\\w.]+\\.\\w+) 복사 치환: &lt;a href=&quot;mailto:$1&quot;&gt;$1&lt;\\a&gt; 복사 &lt;a href=&quot;mailto:$1&quot;&gt;$1&lt;\\a&gt; 복사 결과: html Hello, &lt;a href=&quot;mailto:ben@forta.com&quot;&gt;ben@forta.com&lt;\\a&gt; is my email address.&lt;/a&gt; 복사 html Hello, &lt;a href=&quot;mailto:ben@forta.com&quot;&gt;ben@forta.com&lt;\\a&gt; is my email address.&lt;/a&gt; 복사 자바스크립트에서는 $로 역참조를 사용합니다. 예시에서 확인할 수 있듯이 동일한 역참조를 여러 번 사용할 수 있습니다. "},{"title":"대소문자 변환하기​","type":1,"pageTitle":"역참조 사용하기","url":"/docs-repository/docs/miscellaneous/regular-expression/역참조-사용하기#대소문자-변환하기","content":"일부 정규 표현식 구현에서는 다음 메타 문자를 지원합니다. 메타 문자\t설명\\E\t\\L이나 \\U 변환을 끝냄 \\l\t다음에 오는 글자를 소문자로 변환 \\L\t\\E를 만날 때까지 모든 문자를 소문자로 변환 \\u\t다음에 오는 글자를 대문자로 변환 \\U\t\\E를 만날 때까지 모든 문자를 대문자로 변환 "},{"title":"반복 찾기","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/regular-expression/반복-찾기","content":"","keywords":""},{"title":"하나 이상의 문자 찾기​","type":1,"pageTitle":"반복 찾기","url":"/docs-repository/docs/miscellaneous/regular-expression/반복-찾기#하나-이상의-문자-찾기","content":"더하기 +는 하나 이상의 문자를 찾습니다. 문자 집합에 +를 사용할 때는 +를 집합 바깥에 두어야 합니다. ❌ [0-9+] - 숫자 0부터 9와 문자 더하기를 집합으로 정의한 것 ✔️ [0-9]+ - 의도에 맞는 것 예시: 이메일 주소 html \\w+@\\w+\\.\\w+ 복사 이메일 주소 html \\w+@\\w+\\.\\w+ 복사 "},{"title":"문자가 없거나 하나 이상 연속하는 문자 찾기​","type":1,"pageTitle":"반복 찾기","url":"/docs-repository/docs/miscellaneous/regular-expression/반복-찾기#문자가-없거나-하나-이상-연속하는-문자-찾기","content":"별표 *는 문자가 없거나 하나 이상 연속하는 문자를 찾습니다. *는 주어진 문자가 있는 경우에 일치시키는 선택적 메타 문자로 생각할 수 있습니다. 예시: 이메일 주소 html \\w+[\\w.]*@[\\w.]+\\.\\w+ 복사 이메일 주소 html \\w+[\\w.]*@[\\w.]+\\.\\w+ 복사 "},{"title":"문자가 없거나 하나인 문자 찾기​","type":1,"pageTitle":"반복 찾기","url":"/docs-repository/docs/miscellaneous/regular-expression/반복-찾기#문자가-없거나-하나인-문자-찾기","content":"물음표 ?는 문자가 없거나 하나인 문자를 찾습니다. 예시: URL html https?:\\/\\/[\\w.\\/]+ 복사 URL html https?:\\/\\/[\\w.\\/]+ 복사 유닉스 환경에서 빈 줄 html [\\r]?\\n[\\r]?\\n 복사 유닉스 환경에서 빈 줄 html [\\r]?\\n[\\r]?\\n 복사 [\\r]?은 \\r?과 같은 기능을 하지만 뒤에 나오는 메타 문자가 어디에 적용되는지 확실하게 하기 위해 사용하기도 합니다. "},{"title":"구간 지정하기​","type":1,"pageTitle":"반복 찾기","url":"/docs-repository/docs/miscellaneous/regular-expression/반복-찾기#구간-지정하기","content":"문자가 일치하는 수를 정확히 정하려면 중괄호 {}를 사용해 구간(interval)을 표현합니다. 예시: RGB 값 html [A-Fa-f0-9]{6} 복사 RGB 값 html [A-Fa-f0-9]{6} 복사 구간에 두 개의 숫자를 넣으면 일치 횟수의 범위를 지정할 수 있습니다. 즉 일치 횟수의 최솟값과 최댓값을 지정합니다. 예시: 날짜 html \\d{1,2}[-\\/]\\d{1,2}[-\\/]\\d{2,4} 복사 날짜 html \\d{1,2}[-\\/]\\d{1,2}[-\\/]\\d{2,4} 복사 구간은 0부터 시작할 수 있습니다. ?는 {0,1}과 동일한 기능을 합니다. 최솟값만 지정하는 것도 가능합니다. {3,}과 같이 작성할 수 있습니다. +는 {1,}과 동일한 기능을 합니다. 예시: \\d+: \\$\\d{3,}\\.\\d{2} 복사 \\d+: \\$\\d{3,}\\.\\d{2} 복사 "},{"title":"과하게 일치하는 상황 방지하기​","type":1,"pageTitle":"반복 찾기","url":"/docs-repository/docs/miscellaneous/regular-expression/반복-찾기#과하게-일치하는-상황-방지하기","content":"탐욕적 수량자\t게으른 수량자*\t*? +\t+? {n,}\t{n,}? 다음 예시에서는 &lt;b&gt;로 둘러싸인 텍스트를 일치시키고자 합니다. living in &lt;b&gt;AK&lt;/b&gt; and &lt;b&gt;HI&lt;/b&gt;. 복사 living in &lt;b&gt;AK&lt;/b&gt; and &lt;b&gt;HI&lt;/b&gt;. 복사 탐욕적(greedy) 수량자를 이용해 정규 표현식을 작성하면 &lt;[Bb]&gt;.*&lt;\\/[Bb]&gt;이며 그 결과는 &lt;b&gt;AK&lt;/b&gt; and &lt;b&gt;HI&lt;/b&gt;입니다. 대신 게으른(lazy) 수량자를 이용해 정규 표현식을 작성하면 &lt;[Bb]&gt;.*?&lt;\\/[Bb]&gt;이며 그 결과는 &lt;b&gt;AK&lt;/b&gt;과 &lt;b&gt;HI&lt;/b&gt;로 원하는 결과를 얻습니다. "},{"title":"위치 찾기","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/regular-expression/위치-찾기","content":"","keywords":""},{"title":"단어 경계 지정하기​","type":1,"pageTitle":"위치 찾기","url":"/docs-repository/docs/miscellaneous/regular-expression/위치-찾기#단어-경계-지정하기","content":"\\b로 단어의 경계를 지정합니다. \\b는 일반적으로 단어의 일부로 사용하는 문자(\\w)와 그 외의 문자(\\W) 사이에 있는 위치와 일치합니다. 완전한 단어 하나를 일치시키고자 한다면 단어 앞뒤에 \\b을 붙이면 됩니다. 예시: `\\bcat\\b` 복사 `\\bcat\\b` 복사 \\B는 반대 기능을 합니다. "},{"title":"문자열 경계 정의하기​","type":1,"pageTitle":"위치 찾기","url":"/docs-repository/docs/miscellaneous/regular-expression/위치-찾기#문자열-경계-정의하기","content":"단어 경계와 기능은 비슷하지만 문자열에 대해 경계를 지정합니다. 캐럿 ^으로 문자열의 시작을, 달러 기호 $로 문자열의 마지막을 나타냅니다. 여러 용도로 쓰이는 ^ ^은 집합 안에서 [ 바로 다음에 쓰면 부정을 뜻합니다. 집합 밖에서 패턴 시작 부분에 ^을 쓰면 문자열의 시작 부분과 일치합니다. 다음 예시는 &lt;?xml&gt;로 시작하는지 확인합니다. ^\\s*&lt;\\?xml.*?\\?&gt; 복사 ^\\s*&lt;\\?xml.*?\\?&gt; 복사 다음 예시는 &lt;/html&gt;로 끝나는지 확인합니다. &lt;/[Hh][Tt][Mm][Ll]&gt;\\s*$ 복사 &lt;/[Hh][Tt][Mm][Ll]&gt;\\s*$ 복사 "},{"title":"다중행 모드 사용하기​","type":1,"pageTitle":"위치 찾기","url":"/docs-repository/docs/miscellaneous/regular-expression/위치-찾기#다중행-모드-사용하기","content":"주의 이 기능은 자바스크립트를 포함한 대부분의 정규 표현식 구현에서는 지원하지 않습니다. 다른 메타 문자의 작동을 변경하는 메타 문자 중 하나가 (?m)으로 다중행(multiline)을 지원합니다. 다중행 모드로 변경하면 정규 표현식 엔진이 줄바꿈 문자를 문자열 구분자로 강제로 인식합니다. ^은 문자열의 시작이나 줄바꿈 다음(새로운 행)에 나오는 문자열의 시작과 일치하고, $는 문자열의 마지막이나 줄바꿈 다음에 나오는 문자열의 마지막과 일치합니다. (?m)은 항상 패턴의 맨 앞에 두어야 합니다. 예시: 자바스크립트 주석 html (?m)^\\s*\\/\\/.*$ 복사 자바스크립트 주석 html (?m)^\\s*\\/\\/.*$ 복사 "},{"title":"전방탐색과 후방탐색","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/regular-expression/전방탐색과-후방탐색","content":"","keywords":""},{"title":"전방탐색​","type":1,"pageTitle":"전방탐색과 후방탐색","url":"/docs-repository/docs/miscellaneous/regular-expression/전방탐색과-후방탐색#전방탐색","content":"전방탐색 패턴의 구문은 ?=로 시작하고 = 다음에 일치할 텍스트가 오는 하위 표현식입니다. 예를 들어 각 URL에서 프로토콜의 위치를 추출하고 싶다면 .+(?=:)을 이용할 수 있습니다. 이 정규 표현식과 .+(:)의 차이는 :을 검색 결과에 포함시키는지 여부입니다. "},{"title":"후방탐색​","type":1,"pageTitle":"전방탐색과 후방탐색","url":"/docs-repository/docs/miscellaneous/regular-expression/전방탐색과-후방탐색#후방탐색","content":"후방탐색 연산자는 ?&lt;=입니다. 사용 방법은 전방탐색과 동일합니다. 전방탐색 패턴은 .와 +를 포함하여 텍스트의 길이를 다양하게 일치시킬 수 있으며 매우 동적입니다. 반면 후방탐색 패턴은 보통 일치시킬 텍스트의 길이를 고정해야 합니다. HTML 제목의 텍스트만 추출하고 싶다면 전방탐색과 후방탐색을 함께 사용해 다음과 같은 정규 표현식을 작성할 수 있습니다. (?&lt;=&lt;[tT][iI][tT][lL][eE]&gt;).*(?=&lt;\\/[tT][iI][tT][lL][eE]&gt;) 복사 (?&lt;=&lt;[tT][iI][tT][lL][eE]&gt;).*(?=&lt;\\/[tT][iI][tT][lL][eE]&gt;) 복사 이 예시에서는 혼란을 방지하고자 &lt;을 이스케이프하는 편이 좋을 수 있습니다. "},{"title":"부정형 전후방탐색​","type":1,"pageTitle":"전방탐색과 후방탐색","url":"/docs-repository/docs/miscellaneous/regular-expression/전방탐색과-후방탐색#부정형-전후방탐색","content":"부정형(negative) 전후방탐색은 많이 쓰이지 않는 기능으로 지정한 패턴과 일치하지 않는 텍스트를 찾습니다. 전후방탐색 명령에서 부정형을 나타낼 때는 = 대신 !를 사용합니다. 종류\t긍정형\t부정형전방탐색\t(?=)\t(?!) 후방탐색\t(?&lt;=)\t(?&lt;!) 다음 정규 표현식은 앞에 $가 없는 숫자를 찾습니다. \\b(?&lt;!\\$)\\d+\\b 복사 \\b(?&lt;!\\$)\\d+\\b 복사 "},{"title":"조건 달기","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/regular-expression/조건-달기","content":"","keywords":""},{"title":"조건 사용하기​","type":1,"pageTitle":"조건 달기","url":"/docs-repository/docs/miscellaneous/regular-expression/조건-달기#조건-사용하기","content":"정규 표현식 조건은 물음표 ?를 사용해 정의합니다. "},{"title":"역참조 조건​","type":1,"pageTitle":"조건 달기","url":"/docs-repository/docs/miscellaneous/regular-expression/조건-달기#역참조-조건","content":"역참조 조건은 이전 하위 표현식이 검색에 성공했을 경우에만 다시 그 표현식을 검사합니다. 조건을 표현하는 구문은 다음과 같습니다. (?(backreference)true) 복사 (?(backreference)true) 복사 ?로 조건을 시작하고 괄호 안에서 역참조를 지정한 다음, 역참조가 존재하는 경우에만 평가될 표현식이 뒤에 나옵니다. 예시: (&lt;[Aa]\\s+[^&gt;]+&lt;\\s*)?&lt;[Ii][Mm][Gg]\\s+[^&gt;]+&gt;(?(1)\\s*&lt;\\/[Aa]&gt;) 복사 (&lt;[Aa]\\s+[^&gt;]+&lt;\\s*)?&lt;[Ii][Mm][Gg]\\s+[^&gt;]+&gt;(?(1)\\s*&lt;\\/[Aa]&gt;) 복사 여기서 ?(1)은 역참조 1(&lt;A&gt; 시작 태그)이 있을 때만 수행하라는 뜻입니다. 역참조 번호를 조건에서 이스케이프할 필요는 없습니다. 조건문 else 표현식을 사용할 수도 있습니다. 이 경우의 구문은 다음과 같습니다. (?(backreference)true|false) 복사 (?(backreference)true|false) 복사 "},{"title":"전후방탐색 조건​","type":1,"pageTitle":"조건 달기","url":"/docs-repository/docs/miscellaneous/regular-expression/조건-달기#전후방탐색-조건","content":"전후방탐색 조건은 전후방탐색 명령의 성공 여부에 따라 표현식을 수행할지 결정합니다. 문법은 역참조와 동일합니다. 올바른 미국 우편번호를 찾는 정규 표현식은 다음과 같이 작성할 수 있습니다. \\d{5}(?(?=-)-\\d{4}) 복사 \\d{5}(?(?=-)-\\d{4}) 복사 전후방탐색 조건을 이용해서 33333-과 같은 잘못된 우편번호는 일치하지 않습니다. 더 간단한 방법으로 비슷한 결과를 얻을 수 있으므로 이 기능은 자주 사용하지 않습니다. "},{"title":"예시","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/regular-expression/예시","content":"","keywords":""},{"title":"URL​","type":1,"pageTitle":"예시","url":"/docs-repository/docs/miscellaneous/regular-expression/예시#url","content":"호스트 이름, 포트 번호, 경로로 이루어진 URL을 일치시킵니다. 정규 표현식: https?:\\/\\/[-\\w.]+(:\\d+)?(\\/([\\w\\/_.]*)?)? 복사 https?:\\/\\/[-\\w.]+(:\\d+)?(\\/([\\w\\/_.]*)?)? 복사 "},{"title":"완전한 URL​","type":1,"pageTitle":"예시","url":"/docs-repository/docs/miscellaneous/regular-expression/예시#완전한-url","content":"위 정규 표현식보다 완전하지만 느린 패턴입니다. 쿼리 문자열과 사용자 정보가 포함된 URL을 일치시킵니다. 정규 표현식: https?:\\/\\/(\\w*:\\w*@)?[-\\w.]+(:\\d+)?(\\/([\\w\\/_.]*(\\?\\S+)?)?)? 복사 https?:\\/\\/(\\w*:\\w*@)?[-\\w.]+(:\\d+)?(\\/([\\w\\/_.]*(\\?\\S+)?)?)? 복사 (\\w*:\\w*@)은 사용자 이름과 암호가 포함된 경우를 처리합니다. (\\?\\S+)는 쿼리 문자열을 처리합니다. "},{"title":"이메일 주소​","type":1,"pageTitle":"예시","url":"/docs-repository/docs/miscellaneous/regular-expression/예시#이메일-주소","content":"정규 표현식: (\\w+\\.)*\\w+@(\\w+\\.)+[A-Za-z]+ 복사 (\\w+\\.)*\\w+@(\\w+\\.)+[A-Za-z]+ 복사 이 패턴으로는 올바른 형식을 한 이메일 주소를 모두 검증할 수 없습니다. 예를 들어 이 패턴은 잘못된 이메일 주소인 ben..forta@forta.com을 일치시킵니다. 그리고 호스트 이름에 IP 주소가 들어가는 올바른 이메일 주소를 불일치시킵니다. 그래도 대다수의 이메일 주소를 검사하는 것이 가능합니다. "},{"title":"신용카드 번호​","type":1,"pageTitle":"예시","url":"/docs-repository/docs/miscellaneous/regular-expression/예시#신용카드-번호","content":"신용카드에는 모두 간단한 숫자 매김 체계가 있는데, 몇 자리 특정 숫자를 필두로 나머지 숫자들이 따라옵니다. 마스터카드​ 16자리 숫자이고 첫 숫자는 항상 5이며, 두 번째 숫자는 1에서 5 사이입니다. 정규 표현식: 5[1-5]\\d{14} 복사 5[1-5]\\d{14} 복사 비자​ 4로 시작하고 13 자리나 16 자리 숫자로 이루어집니다. 정규 표현식: 4\\d{12}(\\d{3})? 복사 4\\d{12}(\\d{3})? 복사 아메리칸익스프레스​ 15 자리 숫자이고 34나 37로 시작합니다. 정규 표현식: 3[47]\\d{13} 복사 3[47]\\d{13} 복사 디스커버​ 18 자리 숫자이고 6011로 시작합니다. 정규 표현식: 6011\\d{14} 복사 6011\\d{14} 복사 다이너스클럽​ 14 자리 숫자로 300에서 305 사이 혹은 36이나 38로 시작합니다. 정규 표현식: (30[0-5]|36\\d|38\\d)\\d{11} 복사 (30[0-5]|36\\d|38\\d)\\d{11} 복사 모두 포함하기​ 앞의 카드 번호 패턴들을 모두 포함하면 다음과 같습니다. (5[1-5]\\d{14})|(4\\d{12}(\\d{3})?)|(3[47]\\d{13})|(6011\\d{14})|((30[0-5]|36\\d|38\\d)\\d{11}) 복사 (5[1-5]\\d{14})|(4\\d{12}(\\d{3})?)|(3[47]\\d{13})|(6011\\d{14})|((30[0-5]|36\\d|38\\d)\\d{11}) 복사 이 예시는 신용카드 번호가 시작하는 숫자와 길이가 맞는지를 확인하는 패턴입니다. 신용카드 번호가 정말로 유효한지는 모드 10(Mod 10)이라고 알려진 공식을 사용해야 합니다. 룬 알고리즘으로도 부르는 이 공식은 위키피디아에서 확인할 수 있습니다. "},{"title":"주민등록번호​","type":1,"pageTitle":"예시","url":"/docs-repository/docs/miscellaneous/regular-expression/예시#주민등록번호","content":"전체 자릿수, 날짜 형식, 성별 숫자가 유효한 주민등록번호를 일치시킵니다. \\d{2}(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])-[1-4]\\d{6} 복사 \\d{2}(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])-[1-4]\\d{6} 복사 이 패턴의 한계는 날짜 형식이 완벽하지 않다는 점, 성별 숫자가 연도와 상관없다는 점입니다. 참고로 주민등록번호의 맨 뒷자리 숫자는 고유한 알고리즘으로 주민등록번호가 유효한지 확인합니다. "},{"title":"미국식 날짜 형식을 국제표준 날짜 형식으로 바꾸기​","type":1,"pageTitle":"예시","url":"/docs-repository/docs/miscellaneous/regular-expression/예시#미국식-날짜-형식을-국제표준-날짜-형식으로-바꾸기","content":"mm/dd/yyyy 날짜 형식을 yyyy-mm-dd 형식으로 변환해 보겠습니다. 정규 표현식: ([\\d]{2})\\/([\\d]{2})\\/([\\d]{4}) 복사 ([\\d]{2})\\/([\\d]{2})\\/([\\d]{4}) 복사 치환 표현식: $3-$1-$2 복사 $3-$1-$2 복사 "},{"title":"정규 표현식의 한글과 유니코드​","type":1,"pageTitle":"예시","url":"/docs-repository/docs/miscellaneous/regular-expression/예시#정규-표현식의-한글과-유니코드","content":"한글 일치시키기​ 한글은 \\w에 포함되지 않는다는 것을 주의해야 합니다. 예시로 점수 구간 '수우미양가'를 찾는다고 가정해 보겠습니다. 예문: 국어: 수 영어: 수 수학: 수 미술: 양 체육: 가 복사 국어: 수 영어: 수 수학: 수 미술: 양 체육: 가 복사 정규 표현식: 수|우|미|양|가 복사 수|우|미|양|가 복사 [수우미양가]가 아닌 수|우|미|양|가인 것을 주목할 필요가 있습니다. 한글처럼 2 바이트 이상으로 이루어진 문자는 집합에서 제대로 인식이 안 되는 경우가 많습니다. 정규 표현식: \\b(수|우|미|양|가)\\b 복사 \\b(수|우|미|양|가)\\b 복사 \\b는 영단어의 경계만 나타내므로 위 정규 표현식은 의도대로 작동하지 않습니다. 대신 다음과 같이 전후방탐색을 이용할 수 있습니다. 정규 표현식: (?&lt;=\\s)(수|우|미|양|가)(?=\\s) 복사 (?&lt;=\\s)(수|우|미|양|가)(?=\\s) 복사 만약 과목과 점수 사이에 공백이 없다면 다음의 정규 표현식을 이용할 수 있습니다. 예문: 국어:수 영어:수 수학:수 미술:양 체육:가 복사 국어:수 영어:수 수학:수 미술:양 체육:가 복사 정규 표현식: (?&lt;=[^가-힣])(수|우|미|양|가)(?=[^가-힣]) 복사 (?&lt;=[^가-힣])(수|우|미|양|가)(?=[^가-힣]) 복사 유니코드의 한글 문자 집합의 첫 번째 문자는 '가'이고 마지막 문자는 '힣'이기 때문에 [가-힣]로 한글 문자 집합을 표현할 수 있습니다. 유니코드 일치시키기​ 저작권 표시 ⓒ와 같은 기호를 정규 표현식으로 표현하려면 유니코드 번호(Unicode code point)를 이용합니다. 정규 표현식: `\\u00a9` 복사 `\\u00a9` 복사 "},{"title":"하위 표현식 사용하기","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/regular-expression/하위-표현식-사용하기","content":"","keywords":""},{"title":"하위 표현식으로 묶기​","type":1,"pageTitle":"하위 표현식 사용하기","url":"/docs-repository/docs/miscellaneous/regular-expression/하위-표현식-사용하기#하위-표현식으로-묶기","content":"하위 표현식은 큰 표현식 안에 속한 일부 표현식을 한 항목으로 다루도록 괄호 ()로 묶은 것입니다. 예시: IP 주소 html (\\d{1,3}\\.){3}\\d{1,3} 복사 IP 주소 html (\\d{1,3}\\.){3}\\d{1,3} 복사 19나 20으로 시작하는 네 자리 숫자 html (19|20)\\d{2} 복사 19나 20으로 시작하는 네 자리 숫자 html (19|20)\\d{2} 복사 "},{"title":"중첩된 하위 표현식​","type":1,"pageTitle":"하위 표현식 사용하기","url":"/docs-repository/docs/miscellaneous/regular-expression/하위-표현식-사용하기#중첩된-하위-표현식","content":"하위 표현식을 중첩하는 것도 가능합니다. 올바른 IP 주소와 일치하는 엄격한 정규 표현식을 작성하면 다음과 같습니다. (((25[0-5])|(2[0-4\\d])|(1\\d{2})|(\\d{1,2}))\\.){3}(((25[0-5])|(2[0-4\\d])|(1\\d{2})|(\\d{1,2}))) 복사 (((25[0-5])|(2[0-4\\d])|(1\\d{2})|(\\d{1,2}))\\.){3}(((25[0-5])|(2[0-4\\d])|(1\\d{2})|(\\d{1,2}))) 복사 "},{"title":"정적 타입 검사기","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/typescript","content":"","keywords":""},{"title":"문법​","type":1,"pageTitle":"정적 타입 검사기","url":"/docs-repository/docs/miscellaneous/typescript#문법","content":"타입스크립트는 자바스크립트의 상위 집합(superset)입니다. 따라서 자바스크립트 문법은 타입스크립트에서 사용 가능합니다. 문법은 프로그램을 구성하기 위해 텍스트를 작성하는 방식입니다. 예를 들어 다음 코드에는 )가 누락되어서 문법 오류가 발생합니다. ts let a = (4 // 오류: ')' expected. 복사 ts let a = (4 // 오류: ')' expected. 복사 타입스크립트가 자바스크립트 코드의 문법 때문에 오류를 발생시키지는 않습니다. 즉, 문제없이 작동하는 자바스크립트 코드를 타입스크립트로 가져올 때 문법 오류를 걱정할 필요가 없습니다. "},{"title":"타입​","type":1,"pageTitle":"정적 타입 검사기","url":"/docs-repository/docs/miscellaneous/typescript#타입","content":"그러나 타입스크립트는 타입 상위 집합(typed superset)입니다. 여러 타입의 값을 사용하는 방법에 대한 규칙이 추가됩니다. 앞의 obj.heigth에서 발생한 오류는 문법 오류가 아닙니다. 값의 타입을 잘못된 방식으로 사용해서 발생한 오류입니다. 다음은 브라우저에서 실행 가능한 자바스크립트 코드로 어떤 값을 기록합니다. ts console.log(4 / []); 복사 ts console.log(4 / []); 복사 문법상 가능한 이 프로그램은 Infinity를 기록합니다. 그러나 타입스크립트는 숫자를 배열로 나누는 것을 무의미한 작업으로 간주하고 오류를 발생시킵니다. ts console.log(4 / []); // The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type. 복사 ts console.log(4 / []); // The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type. 복사 어떤 일이 일어나는지 보기 위해 숫자를 배열로 나누는 것이 가능은 합니다. 하지만 대부분의 경우 이는 프로그래밍 실수입니다. 타입스크립트의 타입 검사기는 프로그램에서 일반적인 오류를 가능한 많이 찾아내며 프로그램을 올바르게 만들도록 설계되었습니다. (타입스크립트 검사의 엄격성 정도를 설정하는 방법은 나중에 배울 것입니다.) 자바스크립트의 코드 일부를 타입스크립트로 옮기면 타입 오류가 발생할 수 있습니다. 이는 코드의 타당한 문제 때문이거나, 타입스크립트가 지나치게 보수적이어서 생긴 오류일 수 있습니다. 이러한 오류를 제거하는 다양한 타입스크립트 문법을 안내서 전체에서 확인할 수 있습니다. "},{"title":"런타임 작동​","type":1,"pageTitle":"정적 타입 검사기","url":"/docs-repository/docs/miscellaneous/typescript#런타임-작동","content":"타입스크립트는 자바스크립트의 런타임 작동을 그대로 유지하는 프로그래밍 언어이기도 합니다. 예를 들어 자바스크립트에서 어떤 수를 0으로 나누면 런타임 예외를 던지는 대신 Infinity가 생성됩니다. 원칙적으로 타입스크립트는 자바스크립트 코드의 런타입 작동을 절대 변경하지 않습니다. 즉, 자바스크립트 코드를 타입스크립트로 옮기면 타입 오류가 있더라도 동일한 실행 방식을 보장합니다. 자바스크립트와 동일한 런타임 작동을 유지하는 것은 타입스크립트의 기본 약속입니다. 프로그램 작동을 멈출 수 있는 두 언어 간의 미묘한 차이에 대해 걱정할 필요가 없습니다. 자바스크립트와 타입스크립트는 서로 쉽게 전환할 수 있습니다. "},{"title":"삭제된 타입​","type":1,"pageTitle":"정적 타입 검사기","url":"/docs-repository/docs/miscellaneous/typescript#삭제된-타입","content":"타입스크립트의 컴파일러가 코드 검사를 완료하면 컴파일된 코드를 생성하기 위해 타입을 지웁니다. 즉, 코드가 컴파일되어 결과로 나온 일반 JS 코드에는 타입 정보가 없습니다. 이는 타입스크립트가 추론한 타입에 따라 프로그램 작동이 변경되지 않음을 의미합니다. 컴파일 과정에서 타입 오류가 표시될 수도 있습니다. 하지만 타입 시스템 자체는 프로그램이 실행될 때의 작동 방식에 영향을 미치지 않습니다. 마지막으로 타입스크립트는 추가 런타임 라이브러리를 제공하지 않습니다. 타입스크립트는 자바스크립트와 동일한 표준 라이브러리(또는 외부 라이브러리)를 사용합니다. 타입스크립트 관련 프레임워크를 추가로 배울 필요가 없습니다. "},{"title":"좁히기","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/typescript/좁히기","content":"","keywords":""},{"title":"typeof 타입 가드​","type":1,"pageTitle":"좁히기","url":"/docs-repository/docs/miscellaneous/typescript/좁히기#typeof-타입-가드","content":"앞에서 봤듯이, 자바스크립트는 런타임에 값의 타입에 대한 매우 기본적인 정보를 제공할 수 있는 typeof 연산자를 제공합니다. 타입스크립트는 해당 연산자가 다음의 문자열을 반환할 것을 예상합니다. &quot;string&quot;&quot;number&quot;&quot;bigint&quot;&quot;boolean&quot;&quot;symbol&quot;&quot;undefined&quot;&quot;object&quot;&quot;function&quot; padLeft에서 봤듯이 이 연산자는 자바스크립트 라이브러리에 자주 등장합니다. 타입스크립트는 이를 여러 분기의 좁은 타입으로 이해할 수 있습니다. 타입스크립트에서는 typeof에서 반환된 값을 확인하는 것이 타입 가드입니다. 타입스크립트는 typeof가 여러 값에서 작동하는 방식을 그대로 인코딩하므로 자바스크립트의 이상한 작동 방식을 그대로 갖습니다. 예를 들어 위의 typeof 반환 목록에 &quot;null&quot;이 없다는 점을 주목해야 합니다. 다음 예시를 확인하세요. ts function printAll(strs: string | string[] | null) { if (typeof strs === &quot;object&quot;) { for (const s of strs) { // 오류: Object is possibly 'null'. console.log(s); } } else if (typeof strs === &quot;string&quot;) { console.log(strs); } else { // 아무것도 하지 않습니다. } } 복사 ts function printAll(strs: string | string[] | null) { if (typeof strs === &quot;object&quot;) { for (const s of strs) { // 오류: Object is possibly 'null'. console.log(s); } } else if (typeof strs === &quot;string&quot;) { console.log(strs); } else { // 아무것도 하지 않습니다. } } 복사 strs가 배열 타입인지 확인하기 위해 strs가 객체인지 확인했습니다. 자바스크립트에서 배열은 객체이기 때문입니다. 하지만 자바스크립트에서 typeof null은 &quot;object&quot;를 반환합니다. 이는 자바스크립트 역사의 불행한 사고 중 하나입니다. 경험이 많지 않은 개발자는 이 문제를 처음 봤을 수도 있습니다. 다행히 타입스크립트는 strs가 string[]이 아닌 string[] | null로 좁혀졌을 뿐이라는 것을 알 수 있습니다. 이제 우리가 '참 같은 값' 검사라고 부르는 것에 대해 알아보겠습니다. "},{"title":"참 같은 값으로 좁히기​","type":1,"pageTitle":"좁히기","url":"/docs-repository/docs/miscellaneous/typescript/좁히기#참-같은-값으로-좁히기","content":"참 같은 값(truthiness 또는 truthy)이라는 용어는 자바스크립트에서 많이 볼 수 있습니다. 자바스크립트에서는 조건문에 &amp;&amp;, ||, if문, 불린 부정(!) 같은 표현식을 사용할 수 있습니다. 예를 들어 if문은 조건이 boolean 타입이 아니어도 됩니다. ts function getUsersOnlineMessage(numUsersOnline: number) { if (numUsersOnline) { return `There are ${numUsersOnline} online now!`; } return &quot;Nobody's here. :(&quot;; } 복사 ts function getUsersOnlineMessage(numUsersOnline: number) { if (numUsersOnline) { return `There are ${numUsersOnline} online now!`; } return &quot;Nobody's here. :(&quot;; } 복사 자바스크립트에서 if 같은 구조는 먼저 조건을 boolean으로 강제(형 변환)하고, 결과가 true인지 false인지에 따라 분기를 선택합니다. 0NaN&quot;&quot; (빈 문자열)0n (0의 bigint 버전)nullundefined 위의 값들은 false로 강제되고 이외의 값은 true로 강제됩니다. 어떤 값에 Boolean 함수를 사용하거나, 더 짧은 이중 불린 부정(!!)을 사용해서 값을 boolean으로 강제할 수 있습니다. 전자는 타입스크립트가 값을 boolean 타입으로 추론합니다. 반면 후자는 값을 좁은 리터럴 불린 타입인 true로 추론한다는 이점이 있습니다. ts // 둘 다 true가 됩니다. Boolean(&quot;hello&quot;); // 타입 - boolean, 값 - true !!&quot;world&quot;; // 타입 - true, 값 - true 복사 ts // 둘 다 true가 됩니다. Boolean(&quot;hello&quot;); // 타입 - boolean, 값 - true !!&quot;world&quot;; // 타입 - true, 값 - true 복사 특히 null이나 undefined 같은 값을 차단할 때 이를 많이 활용하곤 합니다. 예시로 printAll 함수에 활용해 보겠습니다. ts function printAll(strs: string | string[] | null) { if (strs &amp;&amp; typeof strs === &quot;object&quot;) { for (const s of strs) { console.log(s); } } else if (typeof strs === &quot;string&quot;) { console.log(strs); } } 복사 ts function printAll(strs: string | string[] | null) { if (strs &amp;&amp; typeof strs === &quot;object&quot;) { for (const s of strs) { console.log(s); } } else if (typeof strs === &quot;string&quot;) { console.log(strs); } } 복사 strs이 참 같은 값인지 확인하여 앞의 오류를 제거했습니다. 적어도 다음과 같은 두려운 오류가 발생하는 것을 방지해 줍니다. TypeError: null is not iterable 복사 TypeError: null is not iterable 복사 원시값에 대한 참 같은 값 검사는 오류가 발생하기 쉽다는 점을 명심하세요. 예를 들어 printAll 함수를 다음과 같이 작성할 수 있습니다. ts function printAll(strs: string | string[] | null) { // !!!!!!!!!!!!!! // 따라하지 마세요. // 예시일 뿐입니다. // !!!!!!!!!!!!!! if (strs) { if (typeof strs === &quot;object&quot;) { for (const s of strs) { console.log(s); } } else if (typeof strs === &quot;string&quot;) { console.log(strs); } } } 복사 ts function printAll(strs: string | string[] | null) { // !!!!!!!!!!!!!! // 따라하지 마세요. // 예시일 뿐입니다. // !!!!!!!!!!!!!! if (strs) { if (typeof strs === &quot;object&quot;) { for (const s of strs) { console.log(s); } } else if (typeof strs === &quot;string&quot;) { console.log(strs); } } } 복사 함수의 본문을 참 같은 값 확인으로 감쌌지만 여기에는 미묘한 단점이 존재합니다. 빈 문자열을 올바르게 처리하지 못합니다. 여기서 타입스크립트는 전혀 문제가 되지 않지만 자바스크립트에 익숙하지 않다면 주의할 필요가 있습니다. 타입스크립트는 버그를 초기에 잡는 데 도움이 될 수 있지만, 값을 가지고 아무것도 하지 않는 경우에는 지나치게 규범적일 뿐입니다. 원한다면 린터로 이러한 상황을 처리할 수 있습니다. 마지막으로 불린 부정(!)은 부정 분기를 걸러냅니다. ts function multiplyAll( values: number[] | undefined, factor: number ): number[] | undefined { if (!values) { return values; } else { return values.map((x) =&gt; x * factor); } } 복사 ts function multiplyAll( values: number[] | undefined, factor: number ): number[] | undefined { if (!values) { return values; } else { return values.map((x) =&gt; x * factor); } } 복사 "},{"title":"동등성으로 좁히기​","type":1,"pageTitle":"좁히기","url":"/docs-repository/docs/miscellaneous/typescript/좁히기#동등성으로-좁히기","content":"타입스크립트는 switch문과 ===, !==, ==, != 같은 동등성 검사를 이용해 타입을 좁힙니다. 예시: ts function example(x: string | number, y: string | boolean) { if (x === y) { // 이제 x나 y의 모든 문자열 메서드를 호출할 수 있습니다. x.toUpperCase(); // (method) String.toUpperCase(): string y.toLowerCase(); // (method) String.toLowerCase(): string } else { console.log(x); // (parameter) x: string | number console.log(y); // (parameter) y: string | boolean } } 복사 ts function example(x: string | number, y: string | boolean) { if (x === y) { // 이제 x나 y의 모든 문자열 메서드를 호출할 수 있습니다. x.toUpperCase(); // (method) String.toUpperCase(): string y.toLowerCase(); // (method) String.toLowerCase(): string } else { console.log(x); // (parameter) x: string | number console.log(y); // (parameter) y: string | boolean } } 복사 위의 예시에서 x와 y가 동일하다는 것을 확인할 때, 타입스크립트는 둘의 타입도 동일하다는 것을 압니다. x와 y의 유일한 공통 타입이 string이므로 타입스크립트는 첫 번째 분기의 x와 y가 string이라는 것을 압니다. 변수가 아닌 특정 리터럴 값에 대한 검사에서도 동일하게 작동합니다. 참 같은 값으로 좁히기 섹션에서 printAll 함수가 빈 문자열을 제대로 처리하지 않아서 오류가 발생하기 쉽다고 얘기했습니다. 다음과 같이 null을 차단하는 특정 검사를 수행하여 타입스크립트가 strs의 타입에서 null을 올바르게 제거할 수 있습니다. ts function printAll(strs: string | string[] | null) { if (strs !== null) { if (typeof strs === &quot;object&quot;) { for (const s of strs) { // (parameter) strs: string[] console.log(s); } } else if (typeof strs === &quot;string&quot;) { console.log(strs); // (parameter) strs: string } } } 복사 ts function printAll(strs: string | string[] | null) { if (strs !== null) { if (typeof strs === &quot;object&quot;) { for (const s of strs) { // (parameter) strs: string[] console.log(s); } } else if (typeof strs === &quot;string&quot;) { console.log(strs); // (parameter) strs: string } } } 복사 자바스크립트의 느슨한 동등성 검사인 ==와 !=로도 올바르게 좁힐 수 있습니다. 어떤 값을 == null로 확인하는 것은 null뿐만 아니라 undefined도 확인합니다. == undefined도 동일합니다. 값이 null이나 undefined인지 확인합니다. ts interface Container { value: number | null | undefined; } function multiplyValue(container: Container, factor: number) { // 타입에서 null과 undefined를 모두 제거합니다. if (container.value != null) { console.log(container.value); // (property) Container.value: number // 이제 container.value를 안전하게 곱할 수 있습니다. container.value *= factor; } } 복사 ts interface Container { value: number | null | undefined; } function multiplyValue(container: Container, factor: number) { // 타입에서 null과 undefined를 모두 제거합니다. if (container.value != null) { console.log(container.value); // (property) Container.value: number // 이제 container.value를 안전하게 곱할 수 있습니다. container.value *= factor; } } 복사 "},{"title":"in 연산자로 좁히기​","type":1,"pageTitle":"좁히기","url":"/docs-repository/docs/miscellaneous/typescript/좁히기#in-연산자로-좁히기","content":"자바스크립트에는 객체에 해당 이름을 가진 프로퍼티가 있는지 확인하는 in 연산자가 있습니다. 타입스크립트는 잠재적 타입을 좁히는 방법으로 이 연산자를 사용합니다. 예를 들어 &quot;value&quot; in x에서 &quot;value&quot;는 문자열 리터럴이고 x는 합집합 타입이라고 가정해 보겠습니다. true 분기는 선택적 또는 필수 value 프로퍼티를 가진 x 타입으로 좁히고, false 분기는 선택적 value 프로퍼티 또는 해당 프로퍼티가 없는 타입으로 좁힙니다. ts type Fish = { swim: () =&gt; void }; type Bird = { fly: () =&gt; void }; function move(animal: Fish | Bird) { if (&quot;swim&quot; in animal) { return animal.swim(); } return animal.fly(); } 복사 ts type Fish = { swim: () =&gt; void }; type Bird = { fly: () =&gt; void }; function move(animal: Fish | Bird) { if (&quot;swim&quot; in animal) { return animal.swim(); } return animal.fly(); } 복사 선택적 프로퍼티는 좁히기를 위해 양쪽에 존재합니다. 예를 들어 사람은 수영과 비행(올바른 장비를 사용한다면)이 모두 가능하므로 in 확인의 양쪽 모두에 나타나야 합니다. ts type Fish = { swim: () =&gt; void }; type Bird = { fly: () =&gt; void }; type Human = { swim?: () =&gt; void; fly?: () =&gt; void }; function move(animal: Fish | Bird | Human) { if (&quot;swim&quot; in animal) { animal; // (parameter) animal: Fish | Human } else { animal; // (parameter) animal: Bird | Human } } 복사 ts type Fish = { swim: () =&gt; void }; type Bird = { fly: () =&gt; void }; type Human = { swim?: () =&gt; void; fly?: () =&gt; void }; function move(animal: Fish | Bird | Human) { if (&quot;swim&quot; in animal) { animal; // (parameter) animal: Fish | Human } else { animal; // (parameter) animal: Bird | Human } } 복사 "},{"title":"instanceof로 좁히기​","type":1,"pageTitle":"좁히기","url":"/docs-repository/docs/miscellaneous/typescript/좁히기#instanceof로-좁히기","content":"자바스크립트에는 해당 값이 다른 값의 인스턴스인지 확인하는 연산자가 있습니다. 보다 구체적으로 자바스크립트의 x instanceof Foo는 x의 프로퍼티 체인에 Foo.prototype가 포함되는지 확인합니다. 나중에 클래스에서 자세히 다룰 것이지만 new로 만들어지는 대부분의 값에 이 연산자가 유용합니다. 예상했듯이 instanceof도 타입 가드이며 타입스크립트는 instanceof로 차단되는 분기를 좁힙니다. ts function logValue(x: Date | string) { if (x instanceof Date) { console.log(x.toUTCString()); // (parameter) x: Date } else { console.log(x.toUpperCase()); // (parameter) x: string } } 복사 ts function logValue(x: Date | string) { if (x instanceof Date) { console.log(x.toUTCString()); // (parameter) x: Date } else { console.log(x.toUpperCase()); // (parameter) x: string } } 복사 "},{"title":"할당​","type":1,"pageTitle":"좁히기","url":"/docs-repository/docs/miscellaneous/typescript/좁히기#할당","content":"앞에서 언급한 것처럼, 변수에 할당할 때 타입스크립트는 할당의 오른쪽을 보고 왼쪽을 적절하게 좁힙니다. ts let x = Math.random() &lt; 0.5 ? 10 : &quot;hello world!&quot;; // let x: string | number x = 1; console.log(x); // let x: number x = &quot;goodbye!&quot;; console.log(x); // let x: string 복사 ts let x = Math.random() &lt; 0.5 ? 10 : &quot;hello world!&quot;; // let x: string | number x = 1; console.log(x); // let x: number x = &quot;goodbye!&quot;; console.log(x); // let x: string 복사 각 할당이 유효한 것을 확인할 수 있습니다. 관찰된 x의 타입을 첫 할당 이후에 number로 바꿨음에도, 여전히 x에 string을 할당할 수 있습니다. 그 이유는 처음에 x의 선언된 타입이 string | number이기 때문입니다. 할당 가능 여부는 항상 선언된 타입으로 확인됩니다. x에 boolean을 할당하면 선언된 타입의 일부가 아니므로 오류가 발생합니다. ts let x = Math.random() &lt; 0.5 ? 10 : &quot;hello world!&quot;; // let x: string | number x = 1; console.log(x); // let x: number x = true; // 오류: Type 'boolean' is not assignable to type 'string | number'. console.log(x); // let x: string | number 복사 ts let x = Math.random() &lt; 0.5 ? 10 : &quot;hello world!&quot;; // let x: string | number x = 1; console.log(x); // let x: number x = true; // 오류: Type 'boolean' is not assignable to type 'string | number'. console.log(x); // let x: string | number 복사 "},{"title":"제어 흐름 분석​","type":1,"pageTitle":"좁히기","url":"/docs-repository/docs/miscellaneous/typescript/좁히기#제어-흐름-분석","content":"지금까지 몇 가지 예를 통해 타입스크립트가 특정 분기 내에서 어떻게 좁혀지는지 살펴봤습니다. 하지만 단순히 모든 변수에서 거슬러 올라가서 if, while, 조건문 등을 찾는 것이 아닙니다. 다음 예시를 통해 알아보겠습니다. ts function padLeft(padding: number | string, input: string) { if (typeof padding === &quot;number&quot;) { return &quot; &quot;.repeat(padding) + input; } return padding + input; } 복사 ts function padLeft(padding: number | string, input: string) { if (typeof padding === &quot;number&quot;) { return &quot; &quot;.repeat(padding) + input; } return padding + input; } 복사 padLeft는 첫 if 차단에서 반환됩니다. 타입스크립트는 이 코드를 분석해 padding이 number이면 본문의 나머지 부분(return padding + input;)에 도달할 수 없다는 것을 알 수 있습니다. 그 결과 해당 부분에서는 padding의 number 타입이 제거됩니다. 즉, string | number에서 string으로 좁힙니다. 도달 가능 여부에 기반하는 이러한 코드 분석을 제어 흐름 분석이라고 부릅니다. 타입스크립트는 타입 가드나 할당을 만날 때 이 흐름 분석을 사용해 타입을 좁힙니다. 변수를 분석할 때 제어 흐름이 분리되었다가 다시 병합될 수 있으며, 변수는 각 지점에서 다른 타입으로 관찰될 수 있습니다. ts function example() { let x: string | number | boolean; x = Math.random() &lt; 0.5; console.log(x); // let x: boolean if (Math.random() &lt; 0.5) { x = &quot;hello&quot;; console.log(x); // let x: string } else { x = 100; console.log(x); // let x: number } return x; // let x: string | number } 복사 ts function example() { let x: string | number | boolean; x = Math.random() &lt; 0.5; console.log(x); // let x: boolean if (Math.random() &lt; 0.5) { x = &quot;hello&quot;; console.log(x); // let x: string } else { x = 100; console.log(x); // let x: number } return x; // let x: string | number } 복사 "},{"title":"타입 단언 사용하기​","type":1,"pageTitle":"좁히기","url":"/docs-repository/docs/miscellaneous/typescript/좁히기#타입-단언-사용하기","content":"지금까지 좁히기를 위해 기존 자바스크립트 구문을 이용했지만 때로는 타입 변경을 직접적으로 제어하고 싶을 때가 있습니다. 사용자 정의 타입 가드를 사용하려면 다음과 같이 반환 타입이 타입 단언(type predicate)인 함수를 정의하면 됩니다. ts function isFish(pet: Fish | Bird): pet is Fish { return (pet as Fish).swim !== undefined; } 복사 ts function isFish(pet: Fish | Bird): pet is Fish { return (pet as Fish).swim !== undefined; } 복사 이 예시에서 pet is Fish가 타입 단언입니다. 단언은 parameterName is Type의 형식을 가집니다. 여기서 parameterName은 현재 함수 시그니처의 매개변수 이름이어야 합니다. isFish에 기존 타입과 호환되는 어떤 변수를 건네주면 타입스크립트는 해당 변수를 특정 타입으로 좁힙니다. ts // 이제 swim과 fly 호출이 모두 가능합니다. let pet = getSmallPet(); if (isFish(pet)) { pet.swim(); } else { pet.fly(); } 복사 ts // 이제 swim과 fly 호출이 모두 가능합니다. let pet = getSmallPet(); if (isFish(pet)) { pet.swim(); } else { pet.fly(); } 복사 타입스크립트는 if 분기 안에서 pet이 Fish라는 것을 압니다. 그리고 else 분기 안에서 pet이 Fish가 아니므로 Bird라는 것을 압니다. 다음과 같이 isFish 타입 가드를 이용해 Fish | Bird 배열을 필터링해서 Fish 배열을 얻는 것도 가능합니다. ts const zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()]; const underWater1: Fish[] = zoo.filter(isFish); // 위와 동일합니다. const underWater2: Fish[] = zoo.filter(isFish) as Fish[]; // 더 복잡한 예시를 위해 단언을 반복할 수 있습니다. const underWater3: Fish[] = zoo.filter((pet): pet is Fish =&gt; { if (pet.name === &quot;sharkey&quot;) return false; return isFish(pet); }); 복사 ts const zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()]; const underWater1: Fish[] = zoo.filter(isFish); // 위와 동일합니다. const underWater2: Fish[] = zoo.filter(isFish) as Fish[]; // 더 복잡한 예시를 위해 단언을 반복할 수 있습니다. const underWater3: Fish[] = zoo.filter((pet): pet is Fish =&gt; { if (pet.name === &quot;sharkey&quot;) return false; return isFish(pet); }); 복사 추가로 클래스는 this is Type을 사용해 타입을 좁힐 수 있습니다. "},{"title":"구별되는 합집합​","type":1,"pageTitle":"좁히기","url":"/docs-repository/docs/miscellaneous/typescript/좁히기#구별되는-합집합","content":"지금까지 살펴본 대부분의 예시는 string, boolean, number 같은 간단한 타입으로 단일 변수를 좁히는 데 중점을 두었습니다. 하지만 자바스크립트에서 복잡한 구조를 다루는 경우에는 이것으로 충분하지 않습니다. 예를 들어 원과 사각형 같은 모양을 인코딩한다고 가정해 보겠습니다. 원은 반지름을 추적하고 사각형은 측면 길이를 추적합니다. 어떤 모양을 다루고 있는지 알려주기 위해 kind라는 필드를 사용하겠습니다. 다음은 Shape을 정의하는 첫 번째 시도입니다. ts interface Shape { kind: &quot;circle&quot; | &quot;square&quot;; radius?: number; sideLength?: number; } 복사 ts interface Shape { kind: &quot;circle&quot; | &quot;square&quot;; radius?: number; sideLength?: number; } 복사 문자열 리터럴 타입 &quot;circle&quot;과 &quot;square&quot;의 합집합을 사용해 모양을 원형으로 처리해야 하는지, 사각형으로 처리해야 하는지 알려줍니다. string 대신 &quot;circle&quot; | &quot;square&quot;를 사용해 철자 오류 문제를 방지할 수 있습니다. ts function handleShape(shape: Shape) { // 철자가 틀렸습니다. if (shape.kind === &quot;rect&quot;) { // 오류: This condition will always return 'false' since the types '&quot;circle&quot; | &quot;square&quot;' and '&quot;rect&quot;' have no overlap. // ... } } 복사 ts function handleShape(shape: Shape) { // 철자가 틀렸습니다. if (shape.kind === &quot;rect&quot;) { // 오류: This condition will always return 'false' since the types '&quot;circle&quot; | &quot;square&quot;' and '&quot;rect&quot;' have no overlap. // ... } } 복사 원인지 사각형인지에 따라 올바른 논리를 적용하는 getArea 함수를 작성할 수 있습니다. 먼저 원을 처리해 보겠습니다. ts function getArea(shape: Shape) { return Math.PI * shape.radius ** 2; // 오류: Object is possibly 'undefined'. } 복사 ts function getArea(shape: Shape) { return Math.PI * shape.radius ** 2; // 오류: Object is possibly 'undefined'. } 복사 strictNullChecks가 설정되어 있으면 오류가 발생합니다. radius가 정의되지 않았을 수 있기 때문입니다. 그렇다면 kind 프로퍼티에 적절한 검사를 수행하면 어떨까요? ts function getArea(shape: Shape) { if (shape.kind === &quot;circle&quot;) { return Math.PI * shape.radius ** 2; // 오류: Object is possibly 'undefined'. } } 복사 ts function getArea(shape: Shape) { if (shape.kind === &quot;circle&quot;) { return Math.PI * shape.radius ** 2; // 오류: Object is possibly 'undefined'. } } 복사 타입스크립트는 여전히 여기서 무엇을 해야 하는지 모릅니다. 우리가 타입 검사기보다 값에 대해 더 많이 아는 지점에 도달했습니다. null이 아니라는 단언(shape.radius 뒤에 !)을 이용해 radius가 분명 존재한다고 알려주는 건 어떨까요? ts function getArea(shape: Shape) { if (shape.kind === &quot;circle&quot;) { return Math.PI * shape.radius! ** 2; } } 복사 ts function getArea(shape: Shape) { if (shape.kind === &quot;circle&quot;) { return Math.PI * shape.radius! ** 2; } } 복사 그러나 이상적인 방법은 아닙니다. 타입 검사기에게 shape.radius가 정의되어 있다고 null이 아니라는 단언(!)으로 말했습니다. 하지만 이러한 단언은 코드를 옮기면 오류가 발생하기 쉽습니다. 게다가 strictNullChecks가 설정되어 있지 않다면 실수로 해당 필드에 접근할 수 있습니다. 선택적 프로퍼티는 읽을 때 항상 존재한다고 가정하기 때문입니다. 분명 더 좋은 방법이 있을 것입니다. Shape 인코딩의 문제는 타입 검사기가 kind 프로퍼티로 radius나 sideLength의 존재 여부를 알 수 없다는 점입니다. 우리가 아는 것을 타입 검사기에게 전달해야 합니다. 이를 염두에 두고 Shape를 다시 정의해 보겠습니다. ts interface Circle { kind: &quot;circle&quot;; radius: number; } interface Square { kind: &quot;square&quot;; sideLength: number; } type Shape = Circle | Square; 복사 ts interface Circle { kind: &quot;circle&quot;; radius: number; } interface Square { kind: &quot;square&quot;; sideLength: number; } type Shape = Circle | Square; 복사 여기서는 kind 프로퍼티에 다른 값을 할당해서 Shape를 두 타입으로 적절히 구분했습니다. 그리고 radius와 sideLength는 각 타입에서 필수 프로퍼티로 선언했습니다. Shape의 radius에 접근을 시도하면 어떤 일이 생기는지 보겠습니다. ts function getArea(shape: Shape) { return Math.PI * shape.radius ** 2; // 오류: Property 'radius' does not exist on type 'Shape'. } 복사 ts function getArea(shape: Shape) { return Math.PI * shape.radius ** 2; // 오류: Property 'radius' does not exist on type 'Shape'. } 복사 첫 번째 Shape 정의와 동일하게 오류가 발생합니다. radius가 선택적일 때 (그리고 strictNullChecks가 설정되었을 때) 오류가 발생했습니다. 타입스크립트가 해당 프로퍼티의 존재 여부를 알 수 없기 때문입니다. 이제 Shape가 합집합이므로 타입스크립트는 shape가 Square일 수 있으며 Square는 radius을 가지고 있지 않다고 알려줍니다. 두 해석 모두 맞습니다. 하지만 Shape의 합집합 인코딩은 strictNullChecks 설정과 관계없이 오류를 일으킬 것입니다. 만약 kind 프로퍼티를 다시 확인하면 어떨까요? ts function getArea(shape: Shape) { if (shape.kind === &quot;circle&quot;) { // (parameter) shape: Circle return Math.PI * shape.radius ** 2; } } 복사 ts function getArea(shape: Shape) { if (shape.kind === &quot;circle&quot;) { // (parameter) shape: Circle return Math.PI * shape.radius ** 2; } } 복사 오류가 사라졌습니다. 합집합의 모든 타입에 리터럴 타입의 공통 프로퍼티가 존재한다면, 타입스크립트는 이를 구별되는 합집합으로 간주하고 합집합의 범위를 좁힐 수 있습니다. 예시에서는 kind가 공통 프로퍼티입니다. kind는 Shape의 구별되는 프로퍼티입니다. kind 프로퍼티가 &quot;circle&quot;인지 확인하는 것은 Shape에서 kind 프로퍼티가 &quot;circle&quot;이 아닌 모든 타입을 제거합니다. shape를 Circle 타입으로 좁힙니다. switch문에서도 동일한 검사가 작동합니다. 이제 null이 아니라는 단언(!) 같은 성가신 코드 없이 완전한 getArea을 작성할 수 있습니다. ts function getArea(shape: Shape) { switch (shape.kind) { case &quot;circle&quot;: // (parameter) shape: Circle return Math.PI * shape.radius ** 2; case &quot;square&quot;: // (parameter) shape: Square return shape.sideLength ** 2; } } 복사 ts function getArea(shape: Shape) { switch (shape.kind) { case &quot;circle&quot;: // (parameter) shape: Circle return Math.PI * shape.radius ** 2; case &quot;square&quot;: // (parameter) shape: Square return shape.sideLength ** 2; } } 복사 여기서 중요한 것은 Shape 인코딩입니다. Circle과 Square는 특정 kind 필드가 있는 별개의 타입이라는 올바른 정보를 타입스크립트에게 전달한 것이 결정적이었습니다. 일반 자바스크립트와 다르지 않으며 타입이 안전한 타입스크립트 코드를 작성할 수 있었습니다. 타입 시스템이 일을 올바르게 수행하고 switch문의 각 분기에서 타입을 파악할 수 있게 됩니다. 참고 위 예시에서 반환 키워드의 일부를 제거하면 오류가 발생할 것입니다. 타입 검사를 통해 switch문의 다른 절에 실수로 빠졌을 때 생기는 버그를 방지할 수 있습니다. 구별되는 합집합은 원과 사각형 예시에서 설명한 것 이상으로 유용합니다. 구별되는 합집합은 자바스크립트에서 모든 종류의 메시징 체계를 표현하는 데 좋습니다. 네트워크를 통해 메시지를 보낼 때(클라이언트/서버 통신), 상태 관리 프레임워크에서 변형을 인코딩할 때 구별되는 합집합을 활용할 수 있습니다. "},{"title":"never 타입​","type":1,"pageTitle":"좁히기","url":"/docs-repository/docs/miscellaneous/typescript/좁히기#never-타입","content":"좁히기를 할 때 모든 가능성을 제거하고 남는 것이 없도록 합집합의 옵션을 줄일 수 있습니다. 이 경우 타입스크립트는 never 타입을 이용해 존재해서는 안 되는 상태를 표현합니다. "},{"title":"철저한 검사​","type":1,"pageTitle":"좁히기","url":"/docs-repository/docs/miscellaneous/typescript/좁히기#철저한-검사","content":"never 타입은 모든 타입에 할당 가능합니다. 그러나 never에 할당 가능한 타입은 없습니다(never 자신 제외). 좁히기와 never를 활용해 switch문에서 철저한 검사(exhaustive checking)를 수행할 수 있습니다. 예를 들어 getArea 함수의 default에서 never에 shape를 할당하는 코드(오류가 발생함)를 작성할 수 있습니다. 해당 코드는 모든 가능한 케이스가 처리되지 않았을 때 실행됩니다. ts type Shape = Circle | Square; function getArea(shape: Shape) { switch (shape.kind) { case &quot;circle&quot;: return Math.PI * shape.radius ** 2; case &quot;square&quot;: return shape.sideLength ** 2; default: const _exhaustiveCheck: never = shape; return _exhaustiveCheck; } } 복사 ts type Shape = Circle | Square; function getArea(shape: Shape) { switch (shape.kind) { case &quot;circle&quot;: return Math.PI * shape.radius ** 2; case &quot;square&quot;: return shape.sideLength ** 2; default: const _exhaustiveCheck: never = shape; return _exhaustiveCheck; } } 복사 다음과 같이 새 요소를 Shape 합집합에 추가하면 타입스크립트 오류가 발생합니다. ts interface Triangle { kind: &quot;triangle&quot;; sideLength: number; } type Shape = Circle | Square | Triangle; function getArea(shape: Shape) { switch (shape.kind) { case &quot;circle&quot;: return Math.PI * shape.radius ** 2; case &quot;square&quot;: return shape.sideLength ** 2; default: const _exhaustiveCheck: never = shape; // 오류: Type 'Triangle' is not assignable to type 'never'. return _exhaustiveCheck; } } 복사 ts interface Triangle { kind: &quot;triangle&quot;; sideLength: number; } type Shape = Circle | Square | Triangle; function getArea(shape: Shape) { switch (shape.kind) { case &quot;circle&quot;: return Math.PI * shape.radius ** 2; case &quot;square&quot;: return shape.sideLength ** 2; default: const _exhaustiveCheck: never = shape; // 오류: Type 'Triangle' is not assignable to type 'never'. return _exhaustiveCheck; } } 복사 "},{"title":"객체 타입","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/typescript/객체-타입","content":"","keywords":""},{"title":"프로퍼티 수정자​","type":1,"pageTitle":"객체 타입","url":"/docs-repository/docs/miscellaneous/typescript/객체-타입#프로퍼티-수정자","content":"객체 타입의 각 프로퍼티는 타입, 선택 사항 여부, 쓰기 가능 여부와 같은 몇 가지 사항을 지정할 수 있습니다. "},{"title":"선택적 프로퍼티​","type":1,"pageTitle":"객체 타입","url":"/docs-repository/docs/miscellaneous/typescript/객체-타입#선택적-프로퍼티","content":"우리는 대부분 프로퍼티 세트가 존재할 수 있는 객체를 다룹니다. 이 경우 이름 끝에 물음표(?)를 추가하여 해당 프로퍼티를 선택 사항으로 표시할 수 있습니다. ts interface PaintOptions { shape: Shape; xPos?: number; yPos?: number; } function paintShape(opts: PaintOptions) { // ... } const shape = getShape(); paintShape({ shape }); paintShape({ shape, xPos: 100 }); paintShape({ shape, yPos: 100 }); paintShape({ shape, xPos: 100, yPos: 100 }); 복사 ts interface PaintOptions { shape: Shape; xPos?: number; yPos?: number; } function paintShape(opts: PaintOptions) { // ... } const shape = getShape(); paintShape({ shape }); paintShape({ shape, xPos: 100 }); paintShape({ shape, yPos: 100 }); paintShape({ shape, xPos: 100, yPos: 100 }); 복사 이 예시에서 xPos와 yPos는 선택 사항입니다. 둘 중 하나만 선택해도 되므로 위의 paintShape 호출은 모두 유효합니다. 모든 선택 사항은 해당 프로퍼티가 지정될 때 특정 타입을 가져야 합니다. strictNullChecks일 때, 타입스크립트는 해당 프로퍼티가 undefined일 수 있다고 알려줍니다. ts function paintShape(opts: PaintOptions) { let xPos = opts.xPos; // (property) PaintOptions.xPos?: number | undefined let yPos = opts.yPos; // (property) PaintOptions.yPos?: number | undefined // ... } 복사 ts function paintShape(opts: PaintOptions) { let xPos = opts.xPos; // (property) PaintOptions.xPos?: number | undefined let yPos = opts.yPos; // (property) PaintOptions.yPos?: number | undefined // ... } 복사 자바스크립트에서는 프로퍼티를 지정하지 않아도 접근이 가능하며 그 값은 undefined입니다. undefined를 다음과 같이 특별하게 다룰 수 있습니다. ts function paintShape(opts: PaintOptions) { let xPos = opts.xPos === undefined ? 0 : opts.xPos; // let xPos: number let yPos = opts.yPos === undefined ? 0 : opts.yPos; // let yPos: number // ... } 복사 ts function paintShape(opts: PaintOptions) { let xPos = opts.xPos === undefined ? 0 : opts.xPos; // let xPos: number let yPos = opts.yPos === undefined ? 0 : opts.yPos; // let yPos: number // ... } 복사 지정되지 않은 값에 기본값을 설정하는 패턴은 너무 일반적이어서 자바스크립트에는 이를 지원하는 문법이 있습니다. ts function paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) { console.log(&quot;x coordinate at&quot;, xPos); // (parameter) xPos: number console.log(&quot;y coordinate at&quot;, yPos); // (parameter) yPos: number // ... } 복사 ts function paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) { console.log(&quot;x coordinate at&quot;, xPos); // (parameter) xPos: number console.log(&quot;y coordinate at&quot;, yPos); // (parameter) yPos: number // ... } 복사 여기서는 paintShape의 매개변수에 구조 분해 패턴이 사용되며 xPos와 yPos에 기본값을 제공합니다. 이제 xPos와 yPos는 paintShape 본문 내에 존재하지만 paintShape 호출에서는 선택적입니다. 참고 현재로서는 구조 분해 패턴 내에 타입 주석을 배치할 수 있는 방법이 없습니다. 다음 문법은 자바스크립트에서 이미 다른 의미를 갖기 때문입니다. ts function draw({ shape: Shape, xPos: number = 100 /*...*/ }) { render(shape); // 오류: Cannot find name 'shape'. Did you mean 'Shape'? render(xPos); // 오류: Cannot find name 'xPos'. } 복사 ts function draw({ shape: Shape, xPos: number = 100 /*...*/ }) { render(shape); // 오류: Cannot find name 'shape'. Did you mean 'Shape'? render(xPos); // 오류: Cannot find name 'xPos'. } 복사 객체 구조 분해 패턴에서 shape: Shape는 shape 프로퍼티를 잡아 Shape라는 로컬 변수로 재정의하는 것을 의미합니다. 마찬가지로 xPos: number는 매개변수의 xPos 값에 기반한 number라는 변수를 생성합니다. 매핑 수정자를 사용하여 optional 속성을 제거할 수 있습니다. "},{"title":"readonly 프로퍼티​","type":1,"pageTitle":"객체 타입","url":"/docs-repository/docs/miscellaneous/typescript/객체-타입#readonly-프로퍼티","content":"타입스크립트에서 프로퍼티는 readonly로 표시할 수 있습니다. 런타임 동작은 바뀌지 않습니다. 하지만 readonly로 표시된 프로퍼티는 타임 검사에서 쓰기(write)가 불가능합니다. ts interface SomeType { readonly prop: string; } function doSomething(obj: SomeType) { // 'obj.prop'을 읽을 수 있습니다. console.log(`prop has the value '${obj.prop}'.`); // 하지만 다시 할당할 수는 없습니다. obj.prop = &quot;hello&quot;; // 오류: Cannot assign to 'prop' because it is a read-only property. } 복사 ts interface SomeType { readonly prop: string; } function doSomething(obj: SomeType) { // 'obj.prop'을 읽을 수 있습니다. console.log(`prop has the value '${obj.prop}'.`); // 하지만 다시 할당할 수는 없습니다. obj.prop = &quot;hello&quot;; // 오류: Cannot assign to 'prop' because it is a read-only property. } 복사 readonly 수정자를 사용한다고 해서 값이 완전히 불변인 것은 아닙니다. 내부 콘텐츠를 변경할 수 없다는 의미입니다. 즉, 프로퍼티 자체를 다시 쓰는 것이 불가능하다는 것입니다. ts interface Home { readonly resident: { name: string; age: number }; } function visitForBirthday(home: Home) { // 'home.resident'에서 프로퍼티를 읽고 갱신할 수 있습니다. console.log(`Happy birthday ${home.resident.name}!`); home.resident.age++; } function evict(home: Home) { // 하지만 Home의 resident 프로퍼티 자체에는 쓰기가 불가능합니다. home.resident = { // 오류: Cannot assign to 'resident' because it is a read-only property. name: &quot;Victor the Evictor&quot;, age: 42, }; } 복사 ts interface Home { readonly resident: { name: string; age: number }; } function visitForBirthday(home: Home) { // 'home.resident'에서 프로퍼티를 읽고 갱신할 수 있습니다. console.log(`Happy birthday ${home.resident.name}!`); home.resident.age++; } function evict(home: Home) { // 하지만 Home의 resident 프로퍼티 자체에는 쓰기가 불가능합니다. home.resident = { // 오류: Cannot assign to 'resident' because it is a read-only property. name: &quot;Victor the Evictor&quot;, age: 42, }; } 복사 readonly가 의미하는 바를 잘 이해해야 합니다. 타입스크립트를 개발 중에 객체를 어떻게 사용해야 하는지를 알릴 수 있습니다. 타입스크립트는 두 타입의 프로퍼티가 호환되는지 확인할 때 readonly를 고려하지 않습니다. 따라서 readonly는 별칭을 통해 변경될 수도 있습니다. ts interface Person { name: string; age: number; } interface ReadonlyPerson { readonly name: string; readonly age: number; } let writablePerson: Person = { name: &quot;Person McPersonface&quot;, age: 42, }; // 작동합니다. let readonlyPerson: ReadonlyPerson = writablePerson; console.log(readonlyPerson.age); // 42를 출력합니다. writablePerson.age++; console.log(readonlyPerson.age); // 43을 출력합니다. 복사 ts interface Person { name: string; age: number; } interface ReadonlyPerson { readonly name: string; readonly age: number; } let writablePerson: Person = { name: &quot;Person McPersonface&quot;, age: 42, }; // 작동합니다. let readonlyPerson: ReadonlyPerson = writablePerson; console.log(readonlyPerson.age); // 42를 출력합니다. writablePerson.age++; console.log(readonlyPerson.age); // 43을 출력합니다. 복사 매핑 수정자를 사용하여 readonly 속성을 제거할 수 있습니다. "},{"title":"색인 시그니처​","type":1,"pageTitle":"객체 타입","url":"/docs-repository/docs/miscellaneous/typescript/객체-타입#색인-시그니처","content":"타입 프로퍼티의 모든 이름을 미리 알지 못하지만 값의 모양은 알고 있는 경우가 있습니다. 이 경우 색인 시그니처를 사용하여 가능한 값 타입을 묘사할 수 있습니다. 예시: ts interface StringArray { [index: number]: string; } const myArray: StringArray = getStringArray(); const secondItem = myArray[1]; // const secondItem: string 복사 ts interface StringArray { [index: number]: string; } const myArray: StringArray = getStringArray(); const secondItem = myArray[1]; // const secondItem: string 복사 위의 StringArray 인터페이스에는 색인 시그니처가 있습니다. 이 색인 시그니처는 StringArray가 number로 색인되면 string을 반환한다고 명시합니다. 참고 색인 시그니처 프로퍼티의 타입은 문자열 또는 숫자여야 합니다. 두 가지 타입의 색인을 모두 지원할 수 있지만 숫자 색인에서 반환된 타입은 문자열 색인에서 반환된 타입의 하위 타입이어야 합니다. number로 색인을 만들 때, 자바스크립트가 실제로 객체로 색인을 만들기 전에 string으로 변환하기 때문입니다. 100(number)으로 색인을 만드는 것은 &quot;100&quot;(string)으로 색인을 만드는 것과 동일하므로 둘이 일관되어야 합니다. ts interface Animal { name: string; } interface Dog extends Animal { breed: string; } // 오류: 숫자형 문자열로 색인을 만들면 완전히 다른 타입의 Animal을 얻을 수 있습니다. interface NotOkay { [x: number]: Animal; // 오류: 'number' index type 'Animal' is not assignable to 'string' index type 'Dog'. [x: string]: Dog; } 복사 ts interface Animal { name: string; } interface Dog extends Animal { breed: string; } // 오류: 숫자형 문자열로 색인을 만들면 완전히 다른 타입의 Animal을 얻을 수 있습니다. interface NotOkay { [x: number]: Animal; // 오류: 'number' index type 'Animal' is not assignable to 'string' index type 'Dog'. [x: string]: Dog; } 복사 문자열 색인 시그니처는 '사전' 패턴을 묘사하는 강력한 방법이지만 모든 프로퍼티가 색인 시그니처의 반환 타입과 일치해야 합니다. 문자열 색인이 obj.property를 obj[&quot;property&quot;]로도 사용할 수 있다고 선언하기 때문입니다. 다음 예시에서는 name의 타입이 문자열 색인의 타입과 일치하지 않으므로 타입 검사기가 오류를 표시합니다. ts interface NumberDictionary { [index: string]: number; length: number; // 문제 없습니다. name: string; // 오류: Property 'name' of type 'string' is not assignable to 'string' index type 'number'. } 복사 ts interface NumberDictionary { [index: string]: number; length: number; // 문제 없습니다. name: string; // 오류: Property 'name' of type 'string' is not assignable to 'string' index type 'number'. } 복사 그러나 색인 시그니처가 프로퍼티 타입의 합집합인 경우 다른 타입의 프로퍼티가 허용됩니다. ts interface NumberOrStringDictionary { [index: string]: number | string; length: number; // length가 숫자이므로 문제 없습니다. name: string; // name이 문자열이므로 문제 없습니다. } 복사 ts interface NumberOrStringDictionary { [index: string]: number | string; length: number; // length가 숫자이므로 문제 없습니다. name: string; // name이 문자열이므로 문제 없습니다. } 복사 마지막으로 색인 시그니처를 readonly로 설정하여 색인에 할당하는 것을 방지할 수 있습니다. ts interface ReadonlyStringArray { readonly [index: number]: string; } let myArray: ReadonlyStringArray = getReadOnlyStringArray(); myArray[2] = &quot;Mallory&quot;; // 오류: Index signature in type 'ReadonlyStringArray' only permits reading. 복사 ts interface ReadonlyStringArray { readonly [index: number]: string; } let myArray: ReadonlyStringArray = getReadOnlyStringArray(); myArray[2] = &quot;Mallory&quot;; // 오류: Index signature in type 'ReadonlyStringArray' only permits reading. 복사 색인 시그니처가 readonly이므로 myArray[2]를 지정할 수 없습니다. "},{"title":"타입 확장하기​","type":1,"pageTitle":"객체 타입","url":"/docs-repository/docs/miscellaneous/typescript/객체-타입#타입-확장하기","content":"다른 타입의 보다 구체적인 타입을 만드는 것은 매우 일반적입니다. 예를 들어 미국에서 편지와 소포를 보낼 때 필요한 필드를 묘사하는 BasicAddress 타입이 있다고 가정해 보겠습니다. ts interface BasicAddress { name?: string; street: string; city: string; country: string; postalCode: string; } 복사 ts interface BasicAddress { name?: string; street: string; city: string; country: string; postalCode: string; } 복사 일부 상황에서는 이것만으로 충분하지만 주소에 연결된 단위 번호가 존재하는 경우가 있습니다. 그러면 다음과 같이 AddressWithUnit으로 묘사할 수 있습니다. ts interface AddressWithUnit { name?: string; unit: string; street: string; city: string; country: string; postalCode: string; } 복사 ts interface AddressWithUnit { name?: string; unit: string; street: string; city: string; country: string; postalCode: string; } 복사 AddressWithUnit의 문제는 BasicAddress의 모든 필드가 반복된다는 것입니다. 이는 변경 사항이 순전히 추가 사항이기 때문입니다. 대신 다음과 같이 기존 BasicAddress 타입을 확장하고 AddressWithUnit만의 새 필드를 추가할 수 있습니다. ts interface BasicAddress { name?: string; street: string; city: string; country: string; postalCode: string; } interface AddressWithUnit extends BasicAddress { unit: string; } 복사 ts interface BasicAddress { name?: string; street: string; city: string; country: string; postalCode: string; } interface AddressWithUnit extends BasicAddress { unit: string; } 복사 interface의 extends 키워드를 사용하면 다른 명명된 타입의 구성원을 효과적으로 복사하고 새 구성원을 추가할 수 있습니다. 이는 새로 작성해야 하는 타입 선언 보일러플레이트의 양을 줄입니다. 그리고 동일한 프로퍼티의 여러 다른 선언이 관련될 수 있다는 의도를 전달할 수 있습니다. 예를 들어 AddressWithUnit는 street 프로퍼티를 반복할 필요가 없습니다. 그리고 street가 BasicAddress에서 유래했기 때문에 두 타입이 어떤 식으로든 관련이 있음을 알 수 있습니다. interface는 복수의 타입에서 확장할 수도 있습니다. ts interface Colorful { color: string; } interface Circle { radius: number; } interface ColorfulCircle extends Colorful, Circle {} const cc: ColorfulCircle = { color: &quot;red&quot;, radius: 42, }; 복사 ts interface Colorful { color: string; } interface Circle { radius: number; } interface ColorfulCircle extends Colorful, Circle {} const cc: ColorfulCircle = { color: &quot;red&quot;, radius: 42, }; 복사 "},{"title":"교집합 타입​","type":1,"pageTitle":"객체 타입","url":"/docs-repository/docs/miscellaneous/typescript/객체-타입#교집합-타입","content":"interface를 사용하면 다른 타입을 확장하여 새로운 타입을 만들 수 있습니다. 타입스크립트에서는 기존 객체 타입을 결합할 때 주로 사용하는 교집합 타입도 제공합니다. 교집합 타입은 &amp; 연산자를 사용하여 정의됩니다. ts interface Colorful { color: string; } interface Circle { radius: number; } type ColorfulCircle = Colorful &amp; Circle; 복사 ts interface Colorful { color: string; } interface Circle { radius: number; } type ColorfulCircle = Colorful &amp; Circle; 복사 여기서는 Colorful과 Circle을 교차시켜 Colorful과 Circle의 모든 구성원이 포함된 새로운 타입을 만듭니다. ts function draw(circle: Colorful &amp; Circle) { console.log(`Color was ${circle.color}`); console.log(`Radius was ${circle.radius}`); } // 문제 없습니다. draw({ color: &quot;blue&quot;, radius: 42 }); // 오류가 발생합니다. draw({ color: &quot;red&quot;, raidus: 42 }); // 오류: Argument of type '{ color: string; raidus: number; }' is not assignable to parameter of type 'Colorful &amp; Circle'. // Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful &amp; Circle'. Did you mean to write 'radius'? 복사 ts function draw(circle: Colorful &amp; Circle) { console.log(`Color was ${circle.color}`); console.log(`Radius was ${circle.radius}`); } // 문제 없습니다. draw({ color: &quot;blue&quot;, radius: 42 }); // 오류가 발생합니다. draw({ color: &quot;red&quot;, raidus: 42 }); // 오류: Argument of type '{ color: string; raidus: number; }' is not assignable to parameter of type 'Colorful &amp; Circle'. // Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful &amp; Circle'. Did you mean to write 'radius'? 복사 "},{"title":"인터페이스 vs. 교집합​","type":1,"pageTitle":"객체 타입","url":"/docs-repository/docs/miscellaneous/typescript/객체-타입#인터페이스-vs-교집합","content":"우리는 유사하지만 미묘한 차이가 있는, 타입을 결합하는 두 가지 방법을 살펴보았습니다. 인터페이스에서는 extends절을 사용하여 다른 타입에서 확장할 수 있습니다. 교집합에서는 유사한 작업을 수행하고 이름을 타입 별칭으로 지정할 수 있습니다. 둘 사이의 주요한 차이점은 충돌을 처리하는 방법입니다. "},{"title":"제네릭 객체 타입​","type":1,"pageTitle":"객체 타입","url":"/docs-repository/docs/miscellaneous/typescript/객체-타입#제네릭-객체-타입","content":"모든 값을 담을 수 있는 Box 타입이 있다고 가정해 보겠습니다. string, number, Giraffe를 비롯해 뭐든지 담을 수 있습니다. ts interface Box { contents: any; } 복사 ts interface Box { contents: any; } 복사 현재 contents 프로퍼티의 타입은 any이고 작동하지만 나중에는 문제가 생길 수 있습니다. 대신 unknown을 사용할 수 있지만, contents의 타입을 이미 아는 경우에는 예방 검사를 수행하거나 오류가 발생하기 쉬운 타입 단언을 사용해야 합니다. ts interface Box { contents: unknown; } let x: Box = { contents: &quot;hello world&quot;, }; //'x.contents'를 확인할 수 있습니다. if (typeof x.contents === &quot;string&quot;) { console.log(x.contents.toLowerCase()); } // 또는 타입 단언을 사용할 수 있습니다. console.log((x.contents as string).toLowerCase()); 복사 ts interface Box { contents: unknown; } let x: Box = { contents: &quot;hello world&quot;, }; //'x.contents'를 확인할 수 있습니다. if (typeof x.contents === &quot;string&quot;) { console.log(x.contents.toLowerCase()); } // 또는 타입 단언을 사용할 수 있습니다. console.log((x.contents as string).toLowerCase()); 복사 안전한 타입 접근법 중 하나는 contents의 모든 타입에 대해 별개의 Box 타입으로 분류하는 것입니다. ts interface NumberBox { contents: number; } interface StringBox { contents: string; } interface BooleanBox { contents: boolean; } 복사 ts interface NumberBox { contents: number; } interface StringBox { contents: string; } interface BooleanBox { contents: boolean; } 복사 그러나 이 방법은 해당 타입으로 작동하는 별개의 함수 또는 함수의 오버로드를 정의해야 합니다. ts function setContents(box: StringBox, newContents: string): void; function setContents(box: NumberBox, newContents: number): void; function setContents(box: BooleanBox, newContents: boolean): void; function setContents(box: { contents: any }, newContents: any) { box.contents = newContents; } 복사 ts function setContents(box: StringBox, newContents: string): void; function setContents(box: NumberBox, newContents: number): void; function setContents(box: BooleanBox, newContents: boolean): void; function setContents(box: { contents: any }, newContents: any) { box.contents = newContents; } 복사 보일러플레이트가 너무 많습니다. 게다가 나중에 새로운 타입과 오버로드를 도입해야 할 수도 있습니다. box의 타입과 오버로드가 사실상 모두 동일하기 때문에 이 방법은 만족스럽지 않습니다. 대신 타입 매개변수를 선언하는 제네릭 Box 타입을 만들 수 있습니다. ts interface Box&lt;Type&gt; { contents: Type; } 복사 ts interface Box&lt;Type&gt; { contents: Type; } 복사 이를 'Type의 Box는 contents가 Type 타입을 가진 것'이라고 읽을 수 있습니다. 나중에 Box를 참조할 때 Type 대신에 타입 인수를 건네줘야 합니다. ts let box: Box&lt;string&gt;; 복사 ts let box: Box&lt;string&gt;; 복사 Box를 실제 타입에 대한 템플릿으로 생각할 수 있습니다. 여기서 Type은 다른 타입으로 대체될 플레이스홀더입니다. 타입스크립트가 Box&lt;string&gt;를 보면 Box&lt;Type&gt;의 모든 Type 인스턴스를 string으로 대체하고 { contents: string }으로 작업하게 됩니다. 즉, Box&lt;string&gt;과 이전 StringBox는 동일하게 작동합니다. ts interface Box&lt;Type&gt; { contents: Type; } interface StringBox { contents: string; } let boxA: Box&lt;string&gt; = { contents: &quot;hello&quot; }; boxA.contents; // (property) Box&lt;string&gt;.contents: string let boxB: StringBox = { contents: &quot;world&quot; }; boxB.contents; // (property) StringBox.contents: string 복사 ts interface Box&lt;Type&gt; { contents: Type; } interface StringBox { contents: string; } let boxA: Box&lt;string&gt; = { contents: &quot;hello&quot; }; boxA.contents; // (property) Box&lt;string&gt;.contents: string let boxB: StringBox = { contents: &quot;world&quot; }; boxB.contents; // (property) StringBox.contents: string 복사 Box는 Type을 어떤 것으로든 대체할 수 있으므로 재사용이 가능합니다. 새로운 타입의 Box가 필요할 때 새로운 Box 타입을 선언할 필요가 전혀 없습니다. (원한다면 그렇게 할 수 있습니다.) ts interface Box&lt;Type&gt; { contents: Type; } interface Apple { // .... } // { contents: Apple }과 동일합니다. type AppleBox = Box&lt;Apple&gt;; 복사 ts interface Box&lt;Type&gt; { contents: Type; } interface Apple { // .... } // { contents: Apple }과 동일합니다. type AppleBox = Box&lt;Apple&gt;; 복사 이는 제네릭 함수를 사용하여 오버로드를 완전히 피할 수 있다는 것을 의미합니다. ts function setContents&lt;Type&gt;(box: Box&lt;Type&gt;, newContents: Type) { box.contents = newContents; } 복사 ts function setContents&lt;Type&gt;(box: Box&lt;Type&gt;, newContents: Type) { box.contents = newContents; } 복사 타입 별칭에도 제네릭을 사용할 수 있습니다. 다음과 같이 새로운 Box&lt;Type&gt; 인터페이스를 정의할 수 있습니다. ts interface Box&lt;Type&gt; { contents: Type; } 복사 ts interface Box&lt;Type&gt; { contents: Type; } 복사 대신 다음과 같이 타입 별칭을 사용할 수도 있습니다. ts type Box&lt;Type&gt; = { contents: Type; }; 복사 ts type Box&lt;Type&gt; = { contents: Type; }; 복사 타입 별칭은 인터페이스와 달리 객체 타입 이상을 묘사할 수 있습니다. 따라서 타입 별칭을 사용하여 다른 종류의 제네릭 도우미 타입을 작성할 수 있습니다. ts type OrNull&lt;Type&gt; = Type | null; type OneOrMany&lt;Type&gt; = Type | Type[]; type OneOrManyOrNull&lt;Type&gt; = OrNull&lt;OneOrMany&lt;Type&gt;&gt;; // type OneOrManyOrNull&lt;Type&gt; = OneOrMany&lt;Type&gt; | null type OneOrManyOrNullStrings = OneOrManyOrNull&lt;string&gt;; // type OneOrManyOrNullStrings = OneOrMany&lt;string&gt; | null 복사 ts type OrNull&lt;Type&gt; = Type | null; type OneOrMany&lt;Type&gt; = Type | Type[]; type OneOrManyOrNull&lt;Type&gt; = OrNull&lt;OneOrMany&lt;Type&gt;&gt;; // type OneOrManyOrNull&lt;Type&gt; = OneOrMany&lt;Type&gt; | null type OneOrManyOrNullStrings = OneOrManyOrNull&lt;string&gt;; // type OneOrManyOrNullStrings = OneOrMany&lt;string&gt; | null 복사 잠시 후에 다시 타입 별칭으로 돌아오겠습니다. "},{"title":"Array 타입​","type":1,"pageTitle":"객체 타입","url":"/docs-repository/docs/miscellaneous/typescript/객체-타입#array-타입","content":"제네릭 객체 타입은 포함된 요소의 타입과 독립적으로 작동하는 일종의 컨테니어 타입인 경우가 많습니다. 이는 데이터 구조가 서로 다른 데이터 타입에서 재사용할 수 있으므로 이상적입니다. 사실 이 핸드북 전체에서 Array 타입을 사용했습니다. number[]나 string[] 같은 타입은 Array&lt;number&gt;와 Array&lt;string&gt;의 줄임말일 뿐입니다. ts function doSomething(value: Array&lt;string&gt;) { // ... } let myArray: string[] = [&quot;hello&quot;, &quot;world&quot;]; // 둘 중 하나를 사용할 수 있습니다. doSomething(myArray); doSomething(new Array(&quot;hello&quot;, &quot;world&quot;)); 복사 ts function doSomething(value: Array&lt;string&gt;) { // ... } let myArray: string[] = [&quot;hello&quot;, &quot;world&quot;]; // 둘 중 하나를 사용할 수 있습니다. doSomething(myArray); doSomething(new Array(&quot;hello&quot;, &quot;world&quot;)); 복사 위의 Box 타입과 마찬가지로 Array 자체는 제네릭 타입입니다. ts interface Array&lt;Type&gt; { /** * 배열의 길이를 가져오거나 설정합니다. */ length: number; /** * 배열의 마지막 요소를 제거하고 반환합니다. */ pop(): Type | undefined; /** * 배열에 새로운 요소를 추가하고 배열의 새로운 길이를 반환합니다. */ push(...items: Type[]): number; // ... } 복사 ts interface Array&lt;Type&gt; { /** * 배열의 길이를 가져오거나 설정합니다. */ length: number; /** * 배열의 마지막 요소를 제거하고 반환합니다. */ pop(): Type | undefined; /** * 배열에 새로운 요소를 추가하고 배열의 새로운 길이를 반환합니다. */ push(...items: Type[]): number; // ... } 복사 모던 자바스크립트는 Map&lt;K, V&gt;, Set&lt;T&gt;, Promise&lt;T&gt; 같은 제네릭 데이터 구조도 제공합니다. Map, Set, Promise의 동작 방식 덕분에 모든 타입과 함께 사용할 수 있습니다. "},{"title":"ReadonlyArray 타입​","type":1,"pageTitle":"객체 타입","url":"/docs-repository/docs/miscellaneous/typescript/객체-타입#readonlyarray-타입","content":"ReadonlyArray는 변경하면 안 되는 배열을 묘사하는 특별한 타입입니다. ts function doStuff(values: ReadonlyArray&lt;string&gt;) { // values를 읽을 수 있습니다. const copy = values.slice(); console.log(`The first value is ${values[0]}`); // 하지만 values를 변경하는 것은 불가능합니다. values.push(&quot;hello!&quot;); // 오류: Property 'push' does not exist on type 'readonly string[]'. } 복사 ts function doStuff(values: ReadonlyArray&lt;string&gt;) { // values를 읽을 수 있습니다. const copy = values.slice(); console.log(`The first value is ${values[0]}`); // 하지만 values를 변경하는 것은 불가능합니다. values.push(&quot;hello!&quot;); // 오류: Property 'push' does not exist on type 'readonly string[]'. } 복사 프로퍼티의 readonly 수정자와 마찬가지로 주로 의도를 알리는 데 사용합니다. ReadonlyArray를 반환하는 함수를 보면, 반환되는 배열의 내용을 변경할 수 없음을 알 수 있습니다. 그리고 ReadonlyArray를 소비하는 함수를 보면, 해당 함수에 어떤 배열을 전달해도 배열의 내용이 변경되는 것을 걱정하지 않아도 됩니다. Array와 달리 ReadonlyArray 생성자는 없습니다. ts new ReadonlyArray(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;); // 오류: 'ReadonlyArray' only refers to a type, but is being used as a value here. 복사 ts new ReadonlyArray(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;); // 오류: 'ReadonlyArray' only refers to a type, but is being used as a value here. 복사 대신 ReadonlyArray에 일반 Array를 할당할 수 있습니다. ts const roArray: ReadonlyArray&lt;string&gt; = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; 복사 ts const roArray: ReadonlyArray&lt;string&gt; = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; 복사 타입스크립트가 Array&lt;Type&gt;의 약칭으로 Type[]을 제공하는 것처럼, ReadonlyArray&lt;Type&gt;의 약칭으로 readonly Type[]을 제공합니다. ts function doStuff(values: readonly string[]) { // values를 읽을 수 있습니다. const copy = values.slice(); console.log(`The first value is ${values[0]}`); // 하지만 values를 변경하는 것은 불가능합니다. values.push(&quot;hello!&quot;); // 오류: Property 'push' does not exist on type 'readonly string[]'. } 복사 ts function doStuff(values: readonly string[]) { // values를 읽을 수 있습니다. const copy = values.slice(); console.log(`The first value is ${values[0]}`); // 하지만 values를 변경하는 것은 불가능합니다. values.push(&quot;hello!&quot;); // 오류: Property 'push' does not exist on type 'readonly string[]'. } 복사 마지막으로 readonly 프로퍼티 수정자와 달리, Array를 ReadonlyArray에 할당하는 것은 가능하지만 그 반대는 불가능합니다. ts let x: readonly string[] = []; let y: string[] = []; x = y; y = x; // 오류: The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'. 복사 ts let x: readonly string[] = []; let y: string[] = []; x = y; y = x; // 오류: The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'. 복사 "},{"title":"튜플 타입​","type":1,"pageTitle":"객체 타입","url":"/docs-repository/docs/miscellaneous/typescript/객체-타입#튜플-타입","content":"튜플 타입은 포함된 요소의 개수와 특정 위치에 포함된 타입을 정확하게 아는 일종의 Array 타입입니다. ts type StringNumberPair = [string, number]; 복사 ts type StringNumberPair = [string, number]; 복사 StringNumberPair는 string과 number로 이루어진 튜플 타입입니다. ReadonlyArray처럼 런타임에는 표현되지 않지만 타입스크립트에게는 의미를 갖습니다. 타입 시스템에서 StringNumberPair는 0 색인에 string이 있고 1 색인에 number가 있는 배열을 묘사합니다. ts function doSomething(pair: [string, number]) { const a = pair[0]; // const a: string const b = pair[1]; // const b: number // ... } doSomething([&quot;hello&quot;, 42]); 복사 ts function doSomething(pair: [string, number]) { const a = pair[0]; // const a: string const b = pair[1]; // const b: number // ... } doSomething([&quot;hello&quot;, 42]); 복사 요소 개수를 초과하여 색인을 생성하려고 하면 오류가 발생합니다. ts function doSomething(pair: [string, number]) { // ... const c = pair[2]; // 오류: Tuple type '[string, number]' of length '2' has no element at index '2'. } 복사 ts function doSomething(pair: [string, number]) { // ... const c = pair[2]; // 오류: Tuple type '[string, number]' of length '2' has no element at index '2'. } 복사 자바스크립트의 배열 구조 분해를 사용하여 튜플을 구조 분해할 수 있습니다. ts function doSomething(stringHash: [string, number]) { const [inputString, hash] = stringHash; console.log(inputString); // const inputString: string console.log(hash); // const hash: number } 복사 ts function doSomething(stringHash: [string, number]) { const [inputString, hash] = stringHash; console.log(inputString); // const inputString: string console.log(hash); // const hash: number } 복사 참고 튜플 유형은 각 요소의 의미가 '명백한' 컨벤션 기반 API에서 유용합니다. 변수를 구조 분해할 때 변수의 이름을 원하는 대로 지정할 수 있는 유연성이 생깁니다. 위의 예시에서 0과 1 요소의 이름을 원하는 대로 지정할 수 있습니다. 그러나 모든 사용자가 컨벤션에 대해 동일한 관점을 갖지 않을 수 있습니다. 따라서 설명적인 프로퍼티 이름이 있는 객체를 사용하는 것이 API에 더 나은지 고려해 볼 필요가 있습니다. 길이 검사를 제외하면, 간단한 튜플 타입은 Array에서 특정 색인에 프로퍼티를 선언하고 숫자 리터럴 타입으로 length를 선언한 것과 동일합니다. ts interface StringNumberPair { // 특수 프로퍼티 length: 2; 0: string; 1: number; // 기타 Array&lt;string | number&gt; 멤버들... slice(start?: number, end?: number): Array&lt;string | number&gt;; } 복사 ts interface StringNumberPair { // 특수 프로퍼티 length: 2; 0: string; 1: number; // 기타 Array&lt;string | number&gt; 멤버들... slice(start?: number, end?: number): Array&lt;string | number&gt;; } 복사 튜플은 물음표(요소의 타입 뒤에 ?)를 사용하여 선택적 프로퍼티를 가질 수 있습니다. 선택적 튜플 요소는 마지막에만 올 수 있으며 length 타입에도 영향을 미칩니다. ts type Either2dOr3d = [number, number, number?]; function setCoordinate(coord: Either2dOr3d) { const [x, y, z] = coord; // const z: number | undefined console.log(`Provided coordinates had ${coord.length} dimensions`); // (property) length: 2 | 3 } 복사 ts type Either2dOr3d = [number, number, number?]; function setCoordinate(coord: Either2dOr3d) { const [x, y, z] = coord; // const z: number | undefined console.log(`Provided coordinates had ${coord.length} dimensions`); // (property) length: 2 | 3 } 복사 튜플은 배열이나 튜플 타입이어야 하는 나머지 요소도 가질 수 있습니다. ts type StringNumberBooleans = [string, number, ...boolean[]]; type StringBooleansNumber = [string, ...boolean[], number]; type BooleansStringNumber = [...boolean[], string, number]; 복사 ts type StringNumberBooleans = [string, number, ...boolean[]]; type StringBooleansNumber = [string, ...boolean[], number]; type BooleansStringNumber = [...boolean[], string, number]; 복사 StringNumberBooleans은 처음 두 요소가 각각 string과 number이고, 그 뒤에는 원하는 만큼의 boolean이 올 수 있는 튜플을 묘사합니다.StringBooleansNumber는 첫 요소가 string이고, 그 뒤에는 원하는 만큼의 boolean이 오고, 마지막은 number로 끝나는 튜플을 묘사합니다.BooleansStringNumber는 처음에 원하는 만큼의 boolean이 오고, 그 뒤에는 string과 number가 오는 튜플을 묘사합니다. 나머지 요소가 있는 튜플에서는 길이를 지정하지 않습니다. 묘사된 요소의 집합이 여러 위치에 있을 뿐입니다. ts const a: StringNumberBooleans = [&quot;hello&quot;, 1]; const b: StringNumberBooleans = [&quot;beautiful&quot;, 2, true]; const c: StringNumberBooleans = [&quot;world&quot;, 3, true, false, true, false, true]; 복사 ts const a: StringNumberBooleans = [&quot;hello&quot;, 1]; const b: StringNumberBooleans = [&quot;beautiful&quot;, 2, true]; const c: StringNumberBooleans = [&quot;world&quot;, 3, true, false, true, false, true]; 복사 선택적 요소와 나머지 요소가 어디서 유용할까요? 타입스크립트가 매개변수 목록과 튜플을 일치시킬 때 좋습니다. 튜플 타입은 다음과 같이 나머지 매개변수와 인수에 사용될 수 있습니다. ts function readButtonInput(...args: [string, number, ...boolean[]]) { const [name, version, ...input] = args; // ... } 복사 ts function readButtonInput(...args: [string, number, ...boolean[]]) { const [name, version, ...input] = args; // ... } 복사 이는 기본적으로 다음과 동일합니다. ts function readButtonInput(name: string, version: number, ...input: boolean[]) { // ... } 복사 ts function readButtonInput(name: string, version: number, ...input: boolean[]) { // ... } 복사 나머지 매개변수를 사용하여 가변 개수의 인수를 사용하고 최소 개수의 요소가 필요하지만 중간 변수를 도입하고 싶지 않을 때 편리합니다. "},{"title":"readonly 튜플 타입​","type":1,"pageTitle":"객체 타입","url":"/docs-repository/docs/miscellaneous/typescript/객체-타입#readonly-튜플-타입","content":"튜플 타입에는 readonly 변형이 있습니다. 배열 약칭 문법과 동일하게 앞에 readonly 수정자를 붙이면 됩니다. ts function doSomething(pair: readonly [string, number]) { // ... } 복사 ts function doSomething(pair: readonly [string, number]) { // ... } 복사 예상할 수 있듯이, readonly 튜플의 프로퍼티에 쓰기는 타입스크립트에서 허용되지 않습니다. ts function doSomething(pair: readonly [string, number]) { pair[0] = &quot;hello!&quot;; // 오류: Cannot assign to '0' because it is a read-only property. } 복사 ts function doSomething(pair: readonly [string, number]) { pair[0] = &quot;hello!&quot;; // 오류: Cannot assign to '0' because it is a read-only property. } 복사 튜플은 생성한 뒤에는 수정하지 않는 경우가 대부분이므로 가능하면 readonly 튜플로 만드는 것이 좋습니다. 이는 const 단언이 있는 배열 리터럴은 readonly 튜플 타입으로 추론된다는 점을 고려할 때 중요합니다. ts let point = [3, 4] as const; function distanceFromOrigin([x, y]: [number, number]) { return Math.sqrt(x ** 2 + y ** 2); } distanceFromOrigin(point); // 오류: Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'. // The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'. 복사 ts let point = [3, 4] as const; function distanceFromOrigin([x, y]: [number, number]) { return Math.sqrt(x ** 2 + y ** 2); } distanceFromOrigin(point); // 오류: Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'. // The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'. 복사 여기서 distanceFromOrigin은 요소를 수정하지 않지만 변경 가능한 튜플을 기대합니다. point의 타입은 readonly [3, 4]로 추론되므로 [number, number]와 호환되지 않습니다. point의 요소가 변경되지 않는다는 것을 보장하지 못하기 때문입니다. "},{"title":"인터페이스","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/인터페이스","content":"","keywords":""},{"title":"인터페이스​","type":1,"pageTitle":"인터페이스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/인터페이스#인터페이스-1","content":""},{"title":"내장 원시 타입​","type":1,"pageTitle":"인터페이스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/인터페이스#내장-원시-타입","content":"boolean, string, number, undefined, null, any, unknown, never, void, bigint, symbol "},{"title":"일반적인 내장 JS 객체​","type":1,"pageTitle":"인터페이스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/인터페이스#일반적인-내장-js-객체","content":"Date, Error, Array, Map, Set, Regexp, Promise "},{"title":"타입 리터럴​","type":1,"pageTitle":"인터페이스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/인터페이스#타입-리터럴","content":"객체: ts { field: string } 복사 ts { field: string } 복사 함수: ts (arg: number) =&gt; string 복사 ts (arg: number) =&gt; string 복사 배열: ts string[] or Array&lt;string&gt; 복사 ts string[] or Array&lt;string&gt; 복사 튜플: ts [string, number] 복사 ts [string, number] 복사 "},{"title":"사용을 피해야 하는 객체​","type":1,"pageTitle":"인터페이스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/인터페이스#사용을-피해야-하는-객체","content":"Object, String, Number, Boolean "},{"title":"일반 문법​","type":1,"pageTitle":"인터페이스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/인터페이스#일반-문법","content":"ts // 선택적으로 기존 인터페이스나 타입에서 프로퍼티를 가져옵니다. interface JSONResponse extends Response, HTTPAble { version: number; // 편집기에 표시하기 위해 첨부된 JSDoc 주석 /** 바이트 단위 */ payloadSize: number; // 이 프로퍼티는 객체에 없을 수 있습니다. outOfStock?: boolean; // 이것은 함수인 프로퍼티를 묘사하는 두 가지 방법입니다. update: (retryTimes: number) =&gt; void; update(retryTimes: number): void; // ()로 이 객체를 호출할 수 있습니다. // 참고로 JS의 함수는 호출 가능한 객체입니다. (): JSONResponse; // 이 인터페이스가 묘사하는 객체에 new를 사용할 수 있습니다. new(s: string): JSONResponse; // 묘사되지 않은 모든 프로퍼티가 이미 존재하는 것으로 간주되며 모든 프로퍼티는 숫자여야 합니다. [key: string]: number; // 변경 불가능한 프로퍼티라는 것을 타입스크립트에게 알립니다. readonly body: string; } 복사 ts // 선택적으로 기존 인터페이스나 타입에서 프로퍼티를 가져옵니다. interface JSONResponse extends Response, HTTPAble { version: number; // 편집기에 표시하기 위해 첨부된 JSDoc 주석 /** 바이트 단위 */ payloadSize: number; // 이 프로퍼티는 객체에 없을 수 있습니다. outOfStock?: boolean; // 이것은 함수인 프로퍼티를 묘사하는 두 가지 방법입니다. update: (retryTimes: number) =&gt; void; update(retryTimes: number): void; // ()로 이 객체를 호출할 수 있습니다. // 참고로 JS의 함수는 호출 가능한 객체입니다. (): JSONResponse; // 이 인터페이스가 묘사하는 객체에 new를 사용할 수 있습니다. new(s: string): JSONResponse; // 묘사되지 않은 모든 프로퍼티가 이미 존재하는 것으로 간주되며 모든 프로퍼티는 숫자여야 합니다. [key: string]: number; // 변경 불가능한 프로퍼티라는 것을 타입스크립트에게 알립니다. readonly body: string; } 복사 "},{"title":"제네릭​","type":1,"pageTitle":"인터페이스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/인터페이스#제네릭","content":"인터페이스에서 변경 가능한 타입을 선언합니다. ts interface APICall&lt;Response&gt; { data: Response; } 복사 ts interface APICall&lt;Response&gt; { data: Response; } 복사 사용법: ts const api: APICall&lt;ArtworkCall&gt; = ... api.data; // Artwork 복사 ts const api: APICall&lt;ArtworkCall&gt; = ... api.data; // Artwork 복사 extends 키워드를 사용해 제네릭 매개변수에 허용되는 타입을 제한할 수 있습니다. ts // 타입에 제약을 설정합니다. status 프로퍼티가 있는 타입만 사용할 수 있습니다. interface APICall&lt;Response extends { status: number }&gt; { data: Response; } const api: APICall&lt;ArtworkCall&gt; = ... api.data.status; 복사 ts // 타입에 제약을 설정합니다. status 프로퍼티가 있는 타입만 사용할 수 있습니다. interface APICall&lt;Response extends { status: number }&gt; { data: Response; } const api: APICall&lt;ArtworkCall&gt; = ... api.data.status; 복사 "},{"title":"오버로딩​","type":1,"pageTitle":"인터페이스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/인터페이스#오버로딩","content":"호출 가능한 인터페이스는 다양한 매개변수 세트에 대해 여러 정의를 가질 수 있습니다. ts interface Expect { (matcher: boolean): string; (matcher: string): boolean; } 복사 ts interface Expect { (matcher: boolean): string; (matcher: string): boolean; } 복사 "},{"title":"get과 set​","type":1,"pageTitle":"인터페이스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/인터페이스#get과-set","content":"객체에는 사용자 지정 획득자 또는 설정자가 있을 수 있습니다. ts interface Ruler { get size(): number; set size(value: number | string); } 복사 ts interface Ruler { get size(): number; set size(value: number | string); } 복사 사용법: ts const r: Ruler = ... r.size = 12; r.size = &quot;36&quot;; 복사 ts const r: Ruler = ... r.size = 12; r.size = &quot;36&quot;; 복사 "},{"title":"병합을 통한 확장​","type":1,"pageTitle":"인터페이스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/인터페이스#병합을-통한-확장","content":"인터페이스는 병합됩니다. 인터페이스를 여러 번 선언하면 타입 정의에 새 필드가 추가됩니다. ts interface APICall { data: Response; } interface APICall { error?: Error; } 복사 ts interface APICall { data: Response; } interface APICall { error?: Error; } 복사 "},{"title":"클래스 적합성​","type":1,"pageTitle":"인터페이스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/인터페이스#클래스-적합성","content":"implements로 클래스가 해당 인터페이스를 준수하는지 확인할 수 있습니다. ts interface Syncable { sync(): void } class Account implements Syncable { ... } 복사 ts interface Syncable { sync(): void } class Account implements Syncable { ... } 복사 "},{"title":"제어 흐름 분석","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/제어-흐름-분석","content":"","keywords":""},{"title":"if문​","type":1,"pageTitle":"제어 흐름 분석","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/제어-흐름-분석#if문","content":"대부분의 좁히기는 if문 내부의 표현식을 사용합니다. 표현식에서 여러 타입 연산자는 새 스코프 내에서 좁힙니다. 원시값을 위한 typeof​ ts const input = getUserInput(); // input: string | number if (typeof input === &quot;string&quot;) { // input: string } 복사 ts const input = getUserInput(); // input: string | number if (typeof input === &quot;string&quot;) { // input: string } 복사 in을 이용한 객체의 프로퍼티​ ts const input = getUserInput(); // input: string | { error: ... } if (&quot;error&quot; in input) { // input: { error: ... } } 복사 ts const input = getUserInput(); // input: string | { error: ... } if (&quot;error&quot; in input) { // input: { error: ... } } 복사 클래스를 위한 instanceof​ ts const input = getUserInput(); // input: number | number[] if (input instanceof Array) { // input: number[] } 복사 ts const input = getUserInput(); // input: number | number[] if (input instanceof Array) { // input: number[] } 복사 모든 타입을 위한 타입 가드 함수​ ts const input = getUserInput(); // input: number | number[] if (Array.isArray(input)) { // input: number[] } 복사 ts const input = getUserInput(); // input: number | number[] if (Array.isArray(input)) { // input: number[] } 복사 "},{"title":"표현식​","type":1,"pageTitle":"제어 흐름 분석","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/제어-흐름-분석#표현식","content":"불린 연산을 수행할 때 동일한 코드 줄에서도 좁히기가 발생합니다. ts const input = getUserInput(); // input: string | number[] const inputLength = (typeof input === &quot;string&quot; &amp;&amp; input.length) || input; // input: string 복사 ts const input = getUserInput(); // input: string | number[] const inputLength = (typeof input === &quot;string&quot; &amp;&amp; input.length) || input; // input: string 복사 "},{"title":"구별되는 합집합​","type":1,"pageTitle":"제어 흐름 분석","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/제어-흐름-분석#구별되는-합집합","content":"ts type Responses = | { status: 200, data: any } | { status: 301, to: string } | { status: 400, error: Error } 복사 ts type Responses = | { status: 200, data: any } | { status: 301, to: string } | { status: 400, error: Error } 복사 합집합의 모든 요소는 status라는 동일한 프로퍼티 이름을 가지고 있으며 CFA는 이를 구별할 수 있습니다. 사용법: ts const res = getResponse(); // res: Responses switch (res.status) { case 200: return res.data; case 301: return redirect(res.to); case 400: return res.error; } 복사 ts const res = getResponse(); // res: Responses switch (res.status) { case 200: return res.data; case 301: return redirect(res.to); case 400: return res.error; } 복사 "},{"title":"타입 가드​","type":1,"pageTitle":"제어 흐름 분석","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/제어-흐름-분석#타입-가드","content":"true이면 새 스코프에 대한 CFA 변경을 설명하는 반환 타입을 가진 함수입니다. ts function isErrorResponse(obj: Response): obj is APIErrorResponse { return obj instanceof APIErrorResponse; } 복사 ts function isErrorResponse(obj: Response): obj is APIErrorResponse { return obj instanceof APIErrorResponse; } 복사 반환 타입 위치에 있는 obj is APIErrorResponse는 단언을 설명합니다. 사용법: ts const res = getResponse(); // res: Responses | APIErrorResponse if (isErrorResponse(res)) { // res: APIErrorResponse } 복사 ts const res = getResponse(); // res: Responses | APIErrorResponse if (isErrorResponse(res)) { // res: APIErrorResponse } 복사 "},{"title":"단언 함수​","type":1,"pageTitle":"제어 흐름 분석","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/제어-흐름-분석#단언-함수","content":"CFA를 설명하는 함수는 false를 반환하는 대신 오류를 던지기 때문에 현재 스코프에 영향을 줍니다. ts function assertResponse(obj: any): asserts obj is SuccessResponse { if (!(obj instanceof SuccessResponse)) { throw new Error(&quot;Not a success!&quot;); } } 복사 ts function assertResponse(obj: any): asserts obj is SuccessResponse { if (!(obj instanceof SuccessResponse)) { throw new Error(&quot;Not a success!&quot;); } } 복사 사용법: ts const res = getResponse(); // res: SuccessResponse | ErrorResponse assertResponse(res); // res: SuccessResponse 복사 ts const res = getResponse(); // res: SuccessResponse | ErrorResponse assertResponse(res); // res: SuccessResponse 복사 단언 함수는 현재 스코프를 변경하거나 오류를 던집니다. "},{"title":"할당​","type":1,"pageTitle":"제어 흐름 분석","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/제어-흐름-분석#할당","content":""},{"title":"as const로 타입 좁히기​","type":1,"pageTitle":"제어 흐름 분석","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/제어-흐름-분석#as-const로-타입-좁히기","content":"객체의 하위 필드는 변경 가능한 것으로 처리됩니다. 할당 동안에는 하위 필드의 타입이 리터럴이 아닌 버전으로 확대됩니다. 접두사 as const는 모든 타입을 리터럴 버전으로 잠급니다. ts const data1 = { name: &quot;Zagreus&quot; }; typeof data1 = { name: string }; const data2 = { name: &quot;Zagreus&quot; } as const; typeof data2 = { name: &quot;Zagreus&quot; }; 복사 ts const data1 = { name: &quot;Zagreus&quot; }; typeof data1 = { name: string }; const data2 = { name: &quot;Zagreus&quot; } as const; typeof data2 = { name: &quot;Zagreus&quot; }; 복사 "},{"title":"관련 변수 추적하기​","type":1,"pageTitle":"제어 흐름 분석","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/제어-흐름-분석#관련-변수-추적하기","content":"ts const res = getResponse(); const isSuccessResponse = res instanceof SuccessResponse; if (isSuccessResponse) { // res: SuccessResponse } 복사 ts const res = getResponse(); const isSuccessResponse = res instanceof SuccessResponse; if (isSuccessResponse) { // res: SuccessResponse } 복사 "},{"title":"재할당에 의한 타입 갱신​","type":1,"pageTitle":"제어 흐름 분석","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/제어-흐름-분석#재할당에-의한-타입-갱신","content":"ts let data: string | number = ... // data: string | number data = &quot;Hello&quot;; // data: string 복사 ts let data: string | number = ... // data: string | number data = &quot;Hello&quot;; // data: string 복사 "},{"title":"클래스","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/클래스","content":"","keywords":""},{"title":"클래스​","type":1,"pageTitle":"클래스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/클래스#클래스-1","content":""},{"title":"클래스 인스턴스 만들기​","type":1,"pageTitle":"클래스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/클래스#클래스-인스턴스-만들기","content":"ts class ABC { ... } const abc = new ABC(); 복사 ts class ABC { ... } const abc = new ABC(); 복사 new ABC의 매개변수는 생성자 함수에서 가져옵니다. "},{"title":"private x vs #private​","type":1,"pageTitle":"클래스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/클래스#private-x-vs-private","content":"접두사 private은 타입 전용 추가 요소이며 런타임에는 영향을 주지 않습니다. 다음 예시에서는 클래스 외부의 코드가 item에 접근할 수 있습니다. ts class Bag { private item: any; } 복사 ts class Bag { private item: any; } 복사 #private는 런타임에서 비공개입니다. 클래스 내부에서만 접근할 수 있도록 자바스크립트 엔진이 강제합니다. ts class Bag { #item: any } 복사 ts class Bag { #item: any } 복사 "},{"title":"클래스의 this​","type":1,"pageTitle":"클래스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/클래스#클래스의-this","content":"함수 내부의 this 값은 함수가 호출되는 방식에 따라 다릅니다. 다른 언어에서처럼 this가 항상 클래스의 인스턴스인 것은 아닙니다. 문제가 생겼을 때는 this 매개변수, bind 함수, 화살표 함수를 활용할 수 있습니다. "},{"title":"타입과 값​","type":1,"pageTitle":"클래스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/클래스#타입과-값","content":"클래스는 타입이나 값으로 사용될 수 있습니다. ts const a: Bag = new Bag(); // 앞의 Bag은 타입이고 뒤의 Bag은 값입니다. 복사 ts const a: Bag = new Bag(); // 앞의 Bag은 타입이고 뒤의 Bag은 값입니다. 복사 따라서 다음과 같이 하지 않도록 주의하세요. ts class C implements Bag {} 복사 ts class C implements Bag {} 복사 "},{"title":"일반 문법​","type":1,"pageTitle":"클래스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/클래스#일반-문법","content":"ts // 이 클래스는 Account의 하위 클래스입니다. // 이 클래스는 인터페이스 또는 타입 집합인 Updatable과 Serializable을 준수합니다. class User extends Account implements Updatable, Serializable { id: string; // 필드 displayName?: boolean; // 선택적 필드 name!: string; // 분명히 존재한다고 말하는 필드 #attributes: Map&lt;any, any&gt;; // 비공개 필드 roles = [&quot;user&quot;]; // 기본값이 있는 필드 readonly createdAt = new Date() // 기본값이 있는 읽기 전용 필드 // new에서 호출되는 코드 constructor(id: string, email: string) { super(id); // 'strict: true'이면 이 코드는 올바르게 설정되었는지 확인하기 위해 필드에 대해 검사됩니다. this.email = email; ... } // 클래스 메서드 및 화살표 함수 필드를 묘사하는 방법 setName(name: string) { this.name = name } verifyName = (name: string) =&gt; { ... } // 2개의 오버로드 정의가 있는 함수 sync(): Promise&lt;{ ... }&gt;; sync(cb: ((result: string) =&gt; void)): void; sync(cb?: ((result: string) =&gt; void)): void | Promise&lt;{ ... }&gt; { ... } // 획득자와 설정자 get accountID() {} set accountID(value: string) {} // private 접근은 이 클래스에서만 가능하고, protected는 하위 클래스를 허용합니다. 타입 검사에서만 사용되며 기본값은 public입니다. private makeRequest() { ... } protected handleRequest() { ... } // 정적 필드와 메서드 static #usetCount = 0; static registerUser(user: User) { ... } // 정적 변수를 설정하기 위한 정적 블록으로 this는 정적 클래스를 나타냅니다. static { this.#userCount = -1 } }; 복사 ts // 이 클래스는 Account의 하위 클래스입니다. // 이 클래스는 인터페이스 또는 타입 집합인 Updatable과 Serializable을 준수합니다. class User extends Account implements Updatable, Serializable { id: string; // 필드 displayName?: boolean; // 선택적 필드 name!: string; // 분명히 존재한다고 말하는 필드 #attributes: Map&lt;any, any&gt;; // 비공개 필드 roles = [&quot;user&quot;]; // 기본값이 있는 필드 readonly createdAt = new Date() // 기본값이 있는 읽기 전용 필드 // new에서 호출되는 코드 constructor(id: string, email: string) { super(id); // 'strict: true'이면 이 코드는 올바르게 설정되었는지 확인하기 위해 필드에 대해 검사됩니다. this.email = email; ... } // 클래스 메서드 및 화살표 함수 필드를 묘사하는 방법 setName(name: string) { this.name = name } verifyName = (name: string) =&gt; { ... } // 2개의 오버로드 정의가 있는 함수 sync(): Promise&lt;{ ... }&gt;; sync(cb: ((result: string) =&gt; void)): void; sync(cb?: ((result: string) =&gt; void)): void | Promise&lt;{ ... }&gt; { ... } // 획득자와 설정자 get accountID() {} set accountID(value: string) {} // private 접근은 이 클래스에서만 가능하고, protected는 하위 클래스를 허용합니다. 타입 검사에서만 사용되며 기본값은 public입니다. private makeRequest() { ... } protected handleRequest() { ... } // 정적 필드와 메서드 static #usetCount = 0; static registerUser(user: User) { ... } // 정적 변수를 설정하기 위한 정적 블록으로 this는 정적 클래스를 나타냅니다. static { this.#userCount = -1 } }; 복사 "},{"title":"제네릭​","type":1,"pageTitle":"클래스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/클래스#제네릭","content":"클래스 메소드에서 변경할 수 있는 타입을 선언합니다. ts // Type은 클래스 타입 매개변수입니다. class Box&lt;Type&gt; { contents: Type; // Type은 이곳에서 사용됩니다. constructor(value: Type) { this.contents = value; } } const stringBox = new Box(&quot;a package&quot;); 복사 ts // Type은 클래스 타입 매개변수입니다. class Box&lt;Type&gt; { contents: Type; // Type은 이곳에서 사용됩니다. constructor(value: Type) { this.contents = value; } } const stringBox = new Box(&quot;a package&quot;); 복사  다음 기능들은 현재 문법으로는 자바스크립트에 적용되지 않는 타입스크립트만의 언어 확장입니다. "},{"title":"매개변수 프로퍼티​","type":1,"pageTitle":"클래스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/클래스#매개변수-프로퍼티","content":"인스턴스 필드를 입력 매개변수로 자동 설정합니다. 클래스에 대한 타입스크립트만의 확장입니다. ts class Location { constructor(public x: number, public y: number) {} } const loc = new Location(20, 40); loc.x // 20 loc.y // 40 복사 ts class Location { constructor(public x: number, public y: number) {} } const loc = new Location(20, 40); loc.x // 20 loc.y // 40 복사 "},{"title":"추상 클래스​","type":1,"pageTitle":"클래스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/클래스#추상-클래스","content":"구현은 불가능하지만 상속의 대상이 될 수 있는 클래스입니다. 클래스의 요소로 선언될 수도 있습니다. ts abstract class Animal { abstract getName(): string; printName() { console.log(&quot;Hello, &quot; + this.getName()); } } class Dog extends Animal { getName(): { ... } } 복사 ts abstract class Animal { abstract getName(): string; printName() { console.log(&quot;Hello, &quot; + this.getName()); } } class Dog extends Animal { getName(): { ... } } 복사 "},{"title":"데코레이터와 프로퍼티​","type":1,"pageTitle":"클래스","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/클래스#데코레이터와-프로퍼티","content":"클래스, 클래스 메서드, 접근자, 프로퍼티, 메서드의 매개변수에 데코레이터를 사용할 수 있습니다. ts import { Syncable, triggersSync, preferCache, required } from &quot;mylib&quot;; @Syncable class User { @triggersSync() save() { ... } @preferCache(false) get displayName() { ... } update(@required info: Partial&lt;User&gt;) { ... } } 복사 ts import { Syncable, triggersSync, preferCache, required } from &quot;mylib&quot;; @Syncable class User { @triggersSync() save() { ... } @preferCache(false) get displayName() { ... } update(@required info: Partial&lt;User&gt;) { ... } } 복사 "},{"title":"소개","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/yup","content":"소개 엽(Yup)은 런타임 값 파싱과 유효성 검사를 위한 스키마 빌더입니다. 스키마를 정의하거나, 일치하도록 값을 변환하거나, 기존 값의 타입을 단언할 수 있습니다. 엽 스키마는 표현력이 매우 뛰어나므로 복잡하고 상호 의존적인 유효성 검사나 값 변환을 모델링할 수 있습니다. 핵심 기능: 단순하면서도 복잡한 데이터 모델을 모델링할 수 있는 간결하면서도 표현력이 풍부한 스키마 인터페이스강력한 타입스크립트 지원 - 스키마에서 정적 타입을 유추하거나 스키마가 타입을 올바르게 구현하는지 확인내장된 비동기 유효성 검사. 서버 측, 클라이언트 측 유효성 검사를 동등하게 모델링확장 가능성 - 고유한 타입 안전 메서드 및 스키마 추가 가능풍부한 오류 세부 정보와 간편한 디버깅","keywords":""},{"title":"타입","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입","content":"","keywords":""},{"title":"타입​","type":1,"pageTitle":"타입","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입#타입-1","content":""},{"title":"타입 vs 인터페이스​","type":1,"pageTitle":"타입","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입#타입-vs-인터페이스","content":"인터페이스는 객체의 모양만 묘사인터페이스는 여러 번 선언해서 확장 가능성능이 중요한 유형에서는 인터페이스 비교 검사가 더 빠를 수 있음 "},{"title":"타입을 변수처럼 생각하기​","type":1,"pageTitle":"타입","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입#타입을-변수처럼-생각하기","content":"다른 스코프에서 동일한 이름을 갖는 변수를 선언하는 방법과 마찬가지로 타입도 유사한 의미론을 갖습니다. "},{"title":"유틸리티 타입 이용하기​","type":1,"pageTitle":"타입","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입#유틸리티-타입-이용하기","content":"타입스크립트에는 타입 시스템에서 일반적인 작업을 수행하는 데 도움이 되는 많은 전역 타입이 포함되어 있습니다. 자세한 내용은 사이트의 문서를 확인하세요. "},{"title":"객체 리터럴 문법​","type":1,"pageTitle":"타입","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입#객체-리터럴-문법","content":"ts type JSONResponse = { version: number; // 필드 /** 바이트 단위 */ // 첨부 문서 payloadSize: number; // outOfStock?: boolean; // 선택적 update: (retryTimes: number) =&gt; void; // 화살표 함수 필드 update(retryTimes: number): void; // 함수 (): JSONResponse; // 타입은 호출 가능 [key : string]: number; // 모든 색인 허용 new (s: string): JSONResponse; // new 사용 가능 readonly body : string; // 읽기 전용 프로퍼티 } 복사 ts type JSONResponse = { version: number; // 필드 /** 바이트 단위 */ // 첨부 문서 payloadSize: number; // outOfStock?: boolean; // 선택적 update: (retryTimes: number) =&gt; void; // 화살표 함수 필드 update(retryTimes: number): void; // 함수 (): JSONResponse; // 타입은 호출 가능 [key : string]: number; // 모든 색인 허용 new (s: string): JSONResponse; // new 사용 가능 readonly body : string; // 읽기 전용 프로퍼티 } 복사 자세한 내용은 인터페이스 커닝 페이퍼를 참고하세요. "},{"title":"원시 타입​","type":1,"pageTitle":"타입","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입#원시-타입","content":"주로 문서화에 유용합니다. ts type SanitizedInput = string; type MissingNo = 404; 복사 ts type SanitizedInput = string; type MissingNo = 404; 복사 "},{"title":"객체 리터럴 타입​","type":1,"pageTitle":"타입","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입#객체-리터럴-타입","content":"ts type Location = { x: number; y: number; } 복사 ts type Location = { x: number; y: number; } 복사 "},{"title":"튜플 타입​","type":1,"pageTitle":"타입","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입#튜플-타입","content":"튜플은 특정 색인에 고정된 타입이 있는 특별한 배열입니다. ts type Data = [ location: Location, timestamp: string ] 복사 ts type Data = [ location: Location, timestamp: string ] 복사 "},{"title":"합집합 타입​","type":1,"pageTitle":"타입","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입#합집합-타입","content":"고정된 문자열 목록과 같이 여러 옵션을 가지는 타입을 묘사합니다. ts type Size = &quot;small&quot; | &quot;medium&quot; | &quot;large&quot;; 복사 ts type Size = &quot;small&quot; | &quot;medium&quot; | &quot;large&quot;; 복사 "},{"title":"교집합 타입​","type":1,"pageTitle":"타입","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입#교집합-타입","content":"타입을 병합·확장하는 방법입니다. ts type Location = { x: number } &amp; { y: number }; // { x: number, y: number }; 복사 ts type Location = { x: number } &amp; { y: number }; // { x: number, y: number }; 복사 "},{"title":"타입 인덱싱​","type":1,"pageTitle":"타입","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입#타입-인덱싱","content":"타입의 하위 집합에서 추출하고 이름을 지정하는 방법입니다. ts type Response = { data: { ... } }; type Data = Response[&quot;data&quot;]; // { ... } 복사 ts type Response = { data: { ... } }; type Data = Response[&quot;data&quot;]; // { ... } 복사 "},{"title":"값에서 타입 가져오기​","type":1,"pageTitle":"타입","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입#값에서-타입-가져오기","content":"typeof 연산자를 이용해 기존 자바스크립트 런타임 값의 타입을 재사용합니다. ts const data = { ... }; type Data = typeof data; 복사 ts const data = { ... }; type Data = typeof data; 복사 "},{"title":"함수 반환에서 타입 가져오기​","type":1,"pageTitle":"타입","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입#함수-반환에서-타입-가져오기","content":"함수의 반환값을 타입으로 재사용합니다. ts const createFixtures = () =&gt; { ... }; type Fixtures = ReturnType&lt;typeof createFixtures&gt;; function test(fixture: Fixtures) {} 복사 ts const createFixtures = () =&gt; { ... }; type Fixtures = ReturnType&lt;typeof createFixtures&gt;; function test(fixture: Fixtures) {} 복사 "},{"title":"모듈에서 타입 가져오기​","type":1,"pageTitle":"타입","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입#모듈에서-타입-가져오기","content":"ts const data: import(&quot;./data&quot;).data 복사 ts const data: import(&quot;./data&quot;).data 복사  다음 기능들은 기존 자바스크립트 코드를 설명하는 라이브러리를 만드는 데 유용하며, 대부분의 타입스크립트 앱에서는 사용할 일이 거의 없습니다. "},{"title":"매핑된 타입​","type":1,"pageTitle":"타입","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입#매핑된-타입","content":"입력 타입이 새 타입의 구조를 변경 가능하게 만듭니다. ts type Artist = { name: string, bio: string }; type Subscriber&lt;Type&gt; = { // 타입 제네릭 매개변수 Type의 필드를 순회합니다. [Property in keyof Type]: // 매개변수가 기존 타입인 함수로 타입을 설정합니다. (newValue: Type[Property]) =&gt; void }; type ArtistSub = Subscriber&lt;Artist&gt;; // { name: (nv: string) =&gt; void, // bio: (nv: string) =&gt; void } 복사 ts type Artist = { name: string, bio: string }; type Subscriber&lt;Type&gt; = { // 타입 제네릭 매개변수 Type의 필드를 순회합니다. [Property in keyof Type]: // 매개변수가 기존 타입인 함수로 타입을 설정합니다. (newValue: Type[Property]) =&gt; void }; type ArtistSub = Subscriber&lt;Artist&gt;; // { name: (nv: string) =&gt; void, // bio: (nv: string) =&gt; void } 복사 "},{"title":"조건부 타입​","type":1,"pageTitle":"타입","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입#조건부-타입","content":"타입 시스템 내에서 if문처럼 작동합니다. 제네릭을 통해 생성된 다음 타입 합집합의 옵션 수를 줄이는 데 많이 사용됩니다. ts type HasFourLegs&lt;Animal&gt; = Animal extends { legs: 4 } ? Animal : never; type Animals = Bird | Dog | Ant | Wolf; type FourLegs = HasFourLegs&lt;Animals&gt;; // Dog | Wolf 복사 ts type HasFourLegs&lt;Animal&gt; = Animal extends { legs: 4 } ? Animal : never; type Animals = Bird | Dog | Ant | Wolf; type FourLegs = HasFourLegs&lt;Animals&gt;; // Dog | Wolf 복사 "},{"title":"템플릿 합집합 타입​","type":1,"pageTitle":"타입","url":"/docs-repository/docs/miscellaneous/typescript/커닝-페이퍼/타입#템플릿-합집합-타입","content":"템플릿 문자열을 사용해 타입 시스템 내에서 텍스트를 결합하고 조작할 수 있습니다. ts type SupportedLangs = &quot;en&quot; | &quot;pt&quot; | &quot;zh&quot;; type FooterLocaleIDs = &quot;header&quot; | &quot;footer&quot;; type AllLocaleIDs = `${SupportedLangs}_${FooterLocaleIDs}_id`; // &quot;en_header_id&quot; | &quot;en_footer_id&quot; // | &quot;pt_header_id&quot; | &quot;pt_footer_id&quot; // | &quot;zh_header_id&quot; | &quot;zh_footer_id&quot; 복사 ts type SupportedLangs = &quot;en&quot; | &quot;pt&quot; | &quot;zh&quot;; type FooterLocaleIDs = &quot;header&quot; | &quot;footer&quot;; type AllLocaleIDs = `${SupportedLangs}_${FooterLocaleIDs}_id`; // &quot;en_header_id&quot; | &quot;en_footer_id&quot; // | &quot;pt_header_id&quot; | &quot;pt_footer_id&quot; // | &quot;zh_header_id&quot; | &quot;zh_footer_id&quot; 복사 "},{"title":"API","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/yup/api","content":"","keywords":""},{"title":"yup​","type":1,"pageTitle":"API","url":"/docs-repository/docs/miscellaneous/yup/api#yup","content":""},{"title":"ref(path: string, options: { contextPrefix: string }): Ref​","type":1,"pageTitle":"API","url":"/docs-repository/docs/miscellaneous/yup/api#refpath-string-options--contextprefix-string--ref","content":"다른 형제나 형제 하위 필드에 대한 참조를 만듭니다. 참조는 유효성 검사나 캐스트 시간에 이행되고 지정된 경우 지원됩니다. ref를 사용하는 필드보다 ref 값이 먼저 이행되도록 적절한 순서로 평가됩니다. 순환 종속성에 주의해야 합니다. typescript import { ref, object, string } from 'yup'; let schema = object({ baz: ref('foo.bar'), foo: object({ bar: string(), }), x: ref('$x'), }); schema.cast({ foo: { bar: 'boom' } }, { context: { x: 5 } }); // =&gt; { baz: 'boom', x: 5, foo: { bar: 'boom' } } 복사 typescript import { ref, object, string } from 'yup'; let schema = object({ baz: ref('foo.bar'), foo: object({ bar: string(), }), x: ref('$x'), }); schema.cast({ foo: { bar: 'boom' } }, { context: { x: 5 } }); // =&gt; { baz: 'boom', x: 5, foo: { bar: 'boom' } } 복사 "},{"title":"Schema​","type":1,"pageTitle":"API","url":"/docs-repository/docs/miscellaneous/yup/api#schema","content":""},{"title":"Schema.when(keys: string | string[], builder: object | (values: any[], schema) => Schema): Schema​","type":1,"pageTitle":"API","url":"/docs-repository/docs/miscellaneous/yup/api#schemawhenkeys-string--string-builder-object--values-any-schema--schema-schema","content":"형제 또는 형제 자식 필드를 기반으로 스키마를 조정합니다. is에 값 또는 일치자 함수를, then에 true일 때의 스키마를, otherwise에 false일 때의 스키마를 가진 객체 리터럴을 인수로 받습니다. is 조건은 일치 연산자(===)를 사용합니다. 동등 연산자(==)를 사용하려면 다음과 같은 함수를 건네줍니다. typescript is: (value) =&gt; value == true; 복사 typescript is: (value) =&gt; value == true; 복사 또한 프로퍼티 앞에 $를 붙여 입력 값 대신 validate() 또는 cast에서 전달된 context에 종속되는 프로퍼티를 지정할 수도 있습니다. 다음 예시에서는 복수의 when 조건을 추가합니다. typescript let schema = object({ isBig: boolean(), count: number() .when('isBig', { is: true, // '(val) =&gt; val == true'와 동일 then: (schema) =&gt; schema.min(5), otherwise: (schema) =&gt; schema.min(0), }) .when('$other', ([other], schema) =&gt; other === 4 ? schema.max(6) : schema ), }); await schema.validate(value, { context: { other: 4 } }); 복사 typescript let schema = object({ isBig: boolean(), count: number() .when('isBig', { is: true, // '(val) =&gt; val == true'와 동일 then: (schema) =&gt; schema.min(5), otherwise: (schema) =&gt; schema.min(0), }) .when('$other', ([other], schema) =&gt; other === 4 ? schema.max(6) : schema ), }); await schema.validate(value, { context: { other: 4 } }); 복사 둘 이상의 종속 키를 지정할 수도 있습니다. 이 경우 각 값은 인수로 확산됩니다. typescript let schema = object({ isSpecial: boolean(), isBig: boolean(), count: number().when(['isBig', 'isSpecial'], { is: true, // '(isBig, isSpecial) =&gt; isBig &amp;&amp; isSpecial'와 동일 then: (schema) =&gt; schema.min(5), otherwise: (schema) =&gt; schema.min(0), }), }); await schema.validate({ isBig: true, isSpecial: true, count: 10, }); 복사 typescript let schema = object({ isSpecial: boolean(), isBig: boolean(), count: number().when(['isBig', 'isSpecial'], { is: true, // '(isBig, isSpecial) =&gt; isBig &amp;&amp; isSpecial'와 동일 then: (schema) =&gt; schema.min(5), otherwise: (schema) =&gt; schema.min(0), }), }); await schema.validate({ isBig: true, isSpecial: true, count: 10, }); 복사 또는 현재 스키마에 제공된 각 키에 대한 값 배열로 호출되는 스키마를 반환하는 함수를 제공할 수 있습니다. typescript let schema = yup.object({ isBig: yup.boolean(), count: yup.number().when('isBig', ([isBig], schema) =&gt; { return isBig ? schema.min(5) : schema.min(0); }), }); await schema.validate({ isBig: false, count: 4 }); 복사 typescript let schema = yup.object({ isBig: yup.boolean(), count: yup.number().when('isBig', ([isBig], schema) =&gt; { return isBig ? schema.min(5) : schema.min(0); }), }); await schema.validate({ isBig: false, count: 4 }); 복사 "},{"title":"Schema.test(name: string, message: string | function | any, test: function): Schema​","type":1,"pageTitle":"API","url":"/docs-repository/docs/miscellaneous/yup/api#schematestname-string-message-string--function--any-test-function-schema","content":"유효성 검사 체인에 테스트 함수를 추가합니다. 테스트는 객체가 캐스트된 후에 실행됩니다. 많은 타입에 내장된 테스트가 있지만, 원한다면 사용자 정의 테스트를 쉽게 만들 수 있습니다. 비동기 사용자 정의 유효성 검사를 허용하기 위해 모든 테스트가 비동기로 실행되거나 동기로 실행됩니다. 따라서 테스트 실행 순서는 보장되지 않습니다. 모든 테스트는 name, 오류 message를 제공해야 합니다. 그리고 현재 value가 유효하고 false이면 true를 반환하는 유효성 검사 함수나 ValidationError를 제공해야 합니다. 테스트를 비동기화하려면 true 또는 false 또는 ValidationError를 이행하는 프라미스를 반환합니다. message 인수의 경우 ${param} 문법을 사용하여 지정된 경우 특정 값을 보간하는 문자열을 제공할 수 있습니다. 기본적으로 모든 테스트 메시지에는 중첩된 스키마에서 중요한 path 값이 전달됩니다. test 함수는 현재 value와 함께 호출됩니다. 고급 유효성 검사를 원한다면 대체 시그니처를 사용하여 더 많은 옵션을 제공할 수 있습니다. typescript let jimmySchema = string().test( 'is-jimmy', '${path} is not Jimmy', (value, context) =&gt; value === 'jimmy' ); // 프라미스를 반환하여 비동기로 만듭니다. let asyncJimmySchema = string() .label('First name') .test( 'is-jimmy', ({ label }) =&gt; `${label} is not Jimmy`, // 메시지는 함수 형태도 가능합니다. async (value, testContext) =&gt; (await fetch('/is-jimmy/' + value)).responseText === 'true' ); await schema.isValid('jimmy'); // =&gt; true await schema.isValid('john'); // =&gt; false 복사 typescript let jimmySchema = string().test( 'is-jimmy', '${path} is not Jimmy', (value, context) =&gt; value === 'jimmy' ); // 프라미스를 반환하여 비동기로 만듭니다. let asyncJimmySchema = string() .label('First name') .test( 'is-jimmy', ({ label }) =&gt; `${label} is not Jimmy`, // 메시지는 함수 형태도 가능합니다. async (value, testContext) =&gt; (await fetch('/is-jimmy/' + value)).responseText === 'true' ); await schema.isValid('jimmy'); // =&gt; true await schema.isValid('john'); // =&gt; false 복사 테스트 함수는 유용한 메타데이터와 함수를 노출하는 두 번째 인수로 특수한 컨텍스트 값으로 호출됩니다. 화살표가 아닌 함수의 경우 테스트 컨텍스트가 함수 this로도 설정됩니다. 화살표 함수에서는 this로 접근할 수 없다는 점을 주의합니다. testContext.path - 현재 유효성 검사의 문자열 경로testContext.schema - 테스트가 실행 중인 이행된 스키마 객체testContext.options - validate() 또는 isValid()가 호출된 options 객체testContext.parent - 중첩된 스키마의 경우 부모 객체의 값testContext.originalValue - 테스트 중인 원래 값testContext.createError(Object: { path: String, message: String, params: Object }) - 유효성 검사 오류를 생성하고 반환합니다. path, params 또는 오류 message를 동적으로 설정하는 데 유용합니다. 생략하면 현재 경로나 기본 메시지가 사용됩니다. "},{"title":"소개","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js","content":"소개 넥스트(Next.js)는 리액트 프레임워크로 하이브리드 정적 &amp; 서버 렌더링, 타입스크립트 지원, 스마트 번들링, 경로 미리 가져오기를 지원합니다. 별도의 설정이 필요 없습니다.","keywords":""},{"title":"사용자 정의 페이지 확장자","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/api-레퍼런스/next-config-js/커스텀-페이지-확장자","content":"","keywords":""},{"title":"pages 디렉터리에 페이지가 아닌 파일 포함하기​","type":1,"pageTitle":"사용자 정의 페이지 확장자","url":"/docs-repository/docs/next-js/api-레퍼런스/next-config-js/커스텀-페이지-확장자#pages-디렉터리에-페이지가-아닌-파일-포함하기","content":"pages 디렉터리의 컴포넌트에서 사용하는 테스트 파일, 생성된 파일, 기타 파일을 함께 배치하려면 확장명에 page와 같은 접두사를 붙일 수 있습니다. next.config.js을 열고 pageExtensions 설정을 추가합니다. js module.exports = { pageExtensions: ['page.tsx', 'page.ts', 'page.jsx', 'page.js'], }; 복사 js module.exports = { pageExtensions: ['page.tsx', 'page.ts', 'page.jsx', 'page.js'], }; 복사 그런 다음 .page를 포함하는 파일 확장자를 갖도록 페이지 이름을 바꿉니다. (예: MyPage.tsx을 MyPage.page.tsx로 바꿈) 참고 _document.js, _app.js, middleware.js를 비롯해 pages/api/에 있는 파일의 이름도 변경해야 합니다. 이 설정이 없으면 넥스트는 pages 디렉터리의 모든 tsx, ts, jsx, js 파일을 페이지나 API 경로로 간주합니다. 그래서 서비스 거부 공격(DoS)에 취약한 의도하지 않은 경로를 노출하거나 프로덕션 빌드 시 다음과 같은 오류가 발생할 수 있습니다. Build error occurred Error: Build optimization failed: found pages without a React Component as default export in pages/MyPage.generated pages/MyPage.test See https://nextjs.org/docs/messages/page-without-valid-component for more info. 복사 Build error occurred Error: Build optimization failed: found pages without a React Component as default export in pages/MyPage.generated pages/MyPage.test See https://nextjs.org/docs/messages/page-without-valid-component for more info. 복사 "},{"title":"getStaticProps","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/api-레퍼런스/데이터-가져오기/get-static-props","content":"","keywords":""},{"title":"컨텍스트 매개변수​","type":1,"pageTitle":"getStaticProps","url":"/docs-repository/docs/next-js/api-레퍼런스/데이터-가져오기/get-static-props#컨텍스트-매개변수","content":"context 매개변수는 다음의 키가 포함된 객체입니다. params에는 동적 경로를 사용하는 페이지의 경로 매개변수가 포함됩니다. 예를 들어 페이지 이름이 [id].js인 경우 params는 { id: ... }입니다. 이것은 getStaticPaths와 함께 사용해야 합니다.페이지가 미리보기 모드이면 preview가 true이며 이외에는 undefined입니다.previewData에는 setPreviewData에서 설정한 미리보기 데이터가 포함됩니다.locale에는 활성 로케일이 포함됩니다. (활성화된 경우)locales에는 지원되는 모든 로케일이 포함됩니다. (활성화된 경우)defaultLocale에는 설정된 기본 로케일이 포함됩니다. (활성화된 경우) "},{"title":"process.cwd()를 사용해 파일 읽기​","type":1,"pageTitle":"getStaticProps","url":"/docs-repository/docs/next-js/api-레퍼런스/데이터-가져오기/get-static-props#processcwd를-사용해-파일-읽기","content":"파일은 getStaticProps의 파일 시스템에서 직접 읽을 수 있습니다. 파일을 읽으려면 파일의 전체 경로를 가져와야 합니다. 넥스트는 코드를 별도의 디렉터리로 컴파일하므로 __dirname을 사용할 수 없습니다. 여기에서 반환되는 경로는 실제 페이지 디렉터리와 다릅니다. 넥스트가 실행되는 디렉터리를 제공하는 process.cwd()를 대신 사용하면 됩니다. jsx import { promises as fs } from 'fs' import path from 'path' // posts는 빌드 타임에 getStaticProps()에 의해 채워집니다. function Blog({ posts }) { return ( &lt;ul&gt; {posts.map((post) =&gt; ( &lt;li&gt; &lt;h3&gt;{post.filename}&lt;/h3&gt; &lt;p&gt;{post.content}&lt;/p&gt; &lt;/li&gt; ))} &lt;/ul&gt; ) } // 이 함수는 서버 측에서 빌드 타임에 호출됩니다. // 클라이언트 측에서는 호출되지 않으므로 // 직접 데이터베이스 쿼리를 수행할 수도 있습니다. export async function getStaticProps() { const postsDirectory = path.join(process.cwd(), 'posts') const filenames = await fs.readdir(postsDirectory) const posts = filenames.map(async (filename) =&gt; { const filePath = path.join(postsDirectory, filename) const fileContents = await fs.readFile(filePath, 'utf8') // 보통은 여기서 콘텐츠를 파싱하거나 변환합니다. // 예를 들어 마크다운을 HTML로 변환할 수 있습니다. return { filename, content: fileContents, } }) // { props: { posts } }를 반환합니다. // Blog 컴포넌트는 빌드 타임에 프롭으로 posts를 받습니다. return { props: { posts: await Promise.all(posts), }, } } export default Blog 복사 jsx import { promises as fs } from 'fs' import path from 'path' // posts는 빌드 타임에 getStaticProps()에 의해 채워집니다. function Blog({ posts }) { return ( &lt;ul&gt; {posts.map((post) =&gt; ( &lt;li&gt; &lt;h3&gt;{post.filename}&lt;/h3&gt; &lt;p&gt;{post.content}&lt;/p&gt; &lt;/li&gt; ))} &lt;/ul&gt; ) } // 이 함수는 서버 측에서 빌드 타임에 호출됩니다. // 클라이언트 측에서는 호출되지 않으므로 // 직접 데이터베이스 쿼리를 수행할 수도 있습니다. export async function getStaticProps() { const postsDirectory = path.join(process.cwd(), 'posts') const filenames = await fs.readdir(postsDirectory) const posts = filenames.map(async (filename) =&gt; { const filePath = path.join(postsDirectory, filename) const fileContents = await fs.readFile(filePath, 'utf8') // 보통은 여기서 콘텐츠를 파싱하거나 변환합니다. // 예를 들어 마크다운을 HTML로 변환할 수 있습니다. return { filename, content: fileContents, } }) // { props: { posts } }를 반환합니다. // Blog 컴포넌트는 빌드 타임에 프롭으로 posts를 받습니다. return { props: { posts: await Promise.all(posts), }, } } export default Blog 복사 다른 내용은 원문을 확인하세요. "},{"title":"문서","type":0,"sectionRef":"#","url":"/docs-repository/docs/miscellaneous/yup/doc","content":"","keywords":""},{"title":"시작하기​","type":1,"pageTitle":"문서","url":"/docs-repository/docs/miscellaneous/yup/doc#시작하기","content":"스키마는 파싱 작업(변환)과 입력 값에 대한 단언(테스트)으로 구성됩니다. 입력 값의 유효성을 검사하여 파싱하고 설정된 단언문 집합을 실행합니다. 메서드를 체이닝하여 스키마를 구축합니다. typescript import { object, string, number, date, InferType } from 'yup'; let userSchema = object({ name: string().required(), age: number().required().positive().integer(), email: string().email(), website: string().url().nullable(), createdOn: date().default(() =&gt; new Date()), }); // 파싱하고 단언문에 대한 유효성 검사를 실시합니다. const user = await userSchema.validate(await fetchUser()); type User = InferType&lt;typeof userSchema&gt;; /* { name: string; age: number; email?: string | undefined website?: string | null | undefined createdOn: Date }*/ 복사 typescript import { object, string, number, date, InferType } from 'yup'; let userSchema = object({ name: string().required(), age: number().required().positive().integer(), email: string().email(), website: string().url().nullable(), createdOn: date().default(() =&gt; new Date()), }); // 파싱하고 단언문에 대한 유효성 검사를 실시합니다. const user = await userSchema.validate(await fetchUser()); type User = InferType&lt;typeof userSchema&gt;; /* { name: string; age: number; email?: string | undefined website?: string | null | undefined createdOn: Date }*/ 복사 스키마를 사용하여 입력 값을 올바른 타입으로 강제 변환하거나 캐스팅(cast)하고, 선택적으로 추가 단언문 없이 해당 값을 보다 구체적인 값으로 변환합니다. typescript // 값을 올바른 타입으로 강제로 변환하는 것을 시도합니다. const parsedUser = userSchema.cast({ name: 'jimmy', age: '24', createdOn: '2014-09-23T19:25:25Z', }); // ✅ { name: 'jimmy', age: 24, createdOn: Date } 복사 typescript // 값을 올바른 타입으로 강제로 변환하는 것을 시도합니다. const parsedUser = userSchema.cast({ name: 'jimmy', age: '24', createdOn: '2014-09-23T19:25:25Z', }); // ✅ { name: 'jimmy', age: 24, createdOn: Date } 복사 입력 값이 이미 파싱된 상태라면 입력 값의 유효성을 엄격하게 확인하고 파싱 논리 실행 비용을 아낄 수 있습니다. typescript // ❌ 유효성 검사 오류 &quot;age is not a number&quot; const parsedUser = await userSchema.validate( { name: 'jimmy', age: '24', }, { strict: true } ); 복사 typescript // ❌ 유효성 검사 오류 &quot;age is not a number&quot; const parsedUser = await userSchema.validate( { name: 'jimmy', age: '24', }, { strict: true } ); 복사 "},{"title":"스키마 기본​","type":1,"pageTitle":"문서","url":"/docs-repository/docs/miscellaneous/yup/doc#스키마-기본","content":"스키마 정의는 입력을 원하는 모양과 타입으로 조작하는 변환 파싱, 파싱된 데이터에 대한 단언문을 만드는 테스트로 구성됩니다. 스키마는 또한 오류 메시지를 개선하거나, 스키마를 동적으로 사용하는 도구를 빌드하거나, 스키마를 다른 형식으로 직렬화하는 데 사용할 수 있는, 스키마 자체에 대한 세부 정보인 메타데이터를 저장합니다. 유연성을 위해 특정 요구 사항에 맞게 파싱과 단언문을 별도로 실행하는 것도 가능합니다. "},{"title":"파싱: 변환​","type":1,"pageTitle":"문서","url":"/docs-repository/docs/miscellaneous/yup/doc#파싱-변환","content":"각 내장 타입은 JSON과 같은 직렬화된 데이터를 파싱할 때 편리한 기본 타입 파싱을 구현합니다. 또한 타입은 가능한 타입별 변환을 구현합니다. typescript const num = number().cast('1'); // 1 const obj = object({ firstName: string().lowercase().trim(), }) .camelCase() .cast('{&quot;first_name&quot;: &quot;jAnE &quot;}'); // { firstName: 'jane' } 복사 typescript const num = number().cast('1'); // 1 const obj = object({ firstName: string().lowercase().trim(), }) .camelCase() .cast('{&quot;first_name&quot;: &quot;jAnE &quot;}'); // { firstName: 'jane' } 복사 사용자 정의 변환을 추가하는 것도 가능합니다. typescript const reversedString = string() .transform((currentValue) =&gt; currentValue.split('').reverse().join('')) .cast('dlrow olleh'); // &quot;hello world&quot; 복사 typescript const reversedString = string() .transform((currentValue) =&gt; currentValue.split('').reverse().join('')) .cast('dlrow olleh'); // &quot;hello world&quot; 복사 변환은 이전 변환의 값이 다음 변환으로 파이프되는 파이프라인을 형성합니다. 최종 값이 undefined이면 엽은 설정된 스키마 기본값을 적용합니다. 주의 값은 변환 함수에서 유효한 타입으로 보장되지 않습니다. 이전 변환이 실패했을 수 있습니다. 예를 들어 숫자 변환은 입력 값으로 NaN이나 숫자를 받을 수 있습니다. "},{"title":"유효성 검사: 테스트​","type":1,"pageTitle":"문서","url":"/docs-repository/docs/miscellaneous/yup/doc#유효성-검사-테스트","content":"엽은 입력 값에 대한 단언문, 즉 테스트를 강력하게 지원합니다. 테스트는 입력이 어떤 기준을 준수한다고 단언합니다. 테스트는 입력(또는 해당 타입)을 변경하지 않는다는 점에서 변환과 구별되며, 일반적으로 불가능하지는 않더라도 정적 타입으로 표현하기 어려운 검사를 위해 예약됩니다. typescript string() .min(3, 'must be at least 3 characters long') .email('must be a valid email') .validate('no'); // ValidationError 복사 typescript string() .min(3, 'must be at least 3 characters long') .email('must be a valid email') .validate('no'); // ValidationError 복사 변환과 마찬가지로 테스트를 즉석에서 사용자 정의할 수 있습니다. typescript const jamesSchema = string().test( 'is-james', (d) =&gt; `${d.path} is not James`, (value) =&gt; value == null || value === 'James' ); jamesSchema.validateSync('James'); // &quot;James&quot; jamesSchema.validateSync('Jane'); // ValidationError &quot;this is not James&quot; 복사 typescript const jamesSchema = string().test( 'is-james', (d) =&gt; `${d.path} is not James`, (value) =&gt; value == null || value === 'James' ); jamesSchema.validateSync('James'); // &quot;James&quot; jamesSchema.validateSync('Jane'); // ValidationError &quot;this is not James&quot; 복사 참고 변환과 달리 사용자 정의 테스트의 value는 올바른 타입(이 경우 선택적 문자열)이 보장됩니다. 이 값은 스키마에 따라 undefined나 null이 될 수 있으며, 변환이 존재 관련 단언을 하지 않는 한 존재하지 않는 값에 대해 true를 반환할 수 있습니다. 오류 사용자 정의하기​ 가장 간단한 경우, 테스트 함수는 검사의 통과 여부에 따라 true나 false를 반환합니다. 테스트가 실패하면 엽은 해당 테스트에 대한 (기본) 메시지와 함께 ValidationError를 던집니다. ValidationErrors에는 테스트 이름, 호출된 인수 (존재하는 경우), 중첩 유효성 검사의 경우에는 실패한 필드의 경로 등 테스트에 대한 많은 메타데이터가 포함되어 있습니다. 오류 메시지는 스키마 실패 방식을 사용자 정의하기 위해 즉석에서 만드는 것도 가능합니다. typescript const order = object({ no: number().required(). sku: string().test({ name: 'is-sku', skipAbsent: true, test(value, ctx) { if (!value.startsWith('s-')) { return ctx.createError({ message: 'SKU missing correct prefix' }) } if (!value.endsWith('-42a')) { return ctx.createError({ message: 'SKU missing correct suffix' }) } if (value.length &lt; 10) { return ctx.createError({ message: 'SKU is not the right length' }) } return true } }) }) order.validate({ no: 1234, sku: 's-1a45-14a' }) 복사 typescript const order = object({ no: number().required(). sku: string().test({ name: 'is-sku', skipAbsent: true, test(value, ctx) { if (!value.startsWith('s-')) { return ctx.createError({ message: 'SKU missing correct prefix' }) } if (!value.endsWith('-42a')) { return ctx.createError({ message: 'SKU missing correct suffix' }) } if (value.length &lt; 10) { return ctx.createError({ message: 'SKU is not the right length' }) } return true } }) }) order.validate({ no: 1234, sku: 's-1a45-14a' }) 복사 "},{"title":"합성 및 재사용​","type":1,"pageTitle":"문서","url":"/docs-repository/docs/miscellaneous/yup/doc#합성-및-재사용","content":"스키마는 변경할 수 없으며 각 메서드 호출은 새 스키마 개체를 반환합니다. 다른 인스턴스 변경에 대한 걱정 없이 재사용하고 전달할 수 있습니다. typescript const optionalString = string().optional(); const definedString = optionalString.defined(); const value = undefined; optionalString.isValid(value); // true definedString.isValid(value); // false 복사 typescript const optionalString = string().optional(); const definedString = optionalString.defined(); const value = undefined; optionalString.isValid(value); // true definedString.isValid(value); // false 복사 "},{"title":"타입스크립트 통합​","type":1,"pageTitle":"문서","url":"/docs-repository/docs/miscellaneous/yup/doc#타입스크립트-통합","content":"엽 스키마는 정적 타입스크립트 인터페이스를 생성합니다. InferType을 사용해 해당 인터페이스를 추출할 수 있습니다. typescript import * as yup from 'yup'; const personSchema = yup.object({ firstName: yup.string().defined(), nickName: yup.string().default('').nullable(), sex: yup .mixed() .oneOf(['male', 'female', 'other'] as const) .defined(), email: yup.string().nullable().email(), birthDate: yup.date().nullable().min(new Date(1900, 0, 1)), }); interface Person extends yup.InferType&lt;typeof personSchema&gt; { // 타입 대신 인터페이스를 사용하는 것이 일반적으로 더 나은 편집기 피드백을 제공합니다. } 복사 typescript import * as yup from 'yup'; const personSchema = yup.object({ firstName: yup.string().defined(), nickName: yup.string().default('').nullable(), sex: yup .mixed() .oneOf(['male', 'female', 'other'] as const) .defined(), email: yup.string().nullable().email(), birthDate: yup.date().nullable().min(new Date(1900, 0, 1)), }); interface Person extends yup.InferType&lt;typeof personSchema&gt; { // 타입 대신 인터페이스를 사용하는 것이 일반적으로 더 나은 편집기 피드백을 제공합니다. } 복사 "},{"title":"스키마 기본값​","type":1,"pageTitle":"문서","url":"/docs-repository/docs/miscellaneous/yup/doc#스키마-기본값","content":"캐스팅이 undefined 출력 값을 생성할 때 스키마의 기본값이 사용됩니다. 따라서 기본값을 설정하면 스키마의 출력 타입에 영향을 미치며 기본적으로 defined()로 표시합니다. typescript import { string } from 'yup'; const value: string = string().default('hi').validate(undefined); // vs const value: string | undefined = string().validate(undefined); 복사 typescript import { string } from 'yup'; const value: string = string().default('hi').validate(undefined); // vs const value: string | undefined = string().validate(undefined); 복사 "},{"title":"스키마가 기존 타입과 일치하는지 확인하기​","type":1,"pageTitle":"문서","url":"/docs-repository/docs/miscellaneous/yup/doc#스키마가-기존-타입과-일치하는지-확인하기","content":"어떤 경우에는 타입스크립트 타입이 이미 존재하며 스키마가 호환 가능한 타입을 생성하는지 확인하고 싶을 수 있습니다. typescript import { object, number, string, ObjectSchema } from 'yup'; interface Person { name: string; age?: number; sex: 'male' | 'female' | 'other' | null; } // 스키마가 유효한 사용자를 생성하지 않으면 컴파일 타임에 타입 오류가 발생합니다. const schema: ObjectSchema&lt;Person&gt; = object({ name: string().defined(), age: number().optional(), sex: string&lt;'male' | 'female' | 'other'&gt;().nullable().defined(); }); // ❌ 오류: // &quot;Type 'number | undefined' is not assignable to type 'string'.&quot; const badSchema: ObjectSchema&lt;Person&gt; = object({ name: number(), }); 복사 typescript import { object, number, string, ObjectSchema } from 'yup'; interface Person { name: string; age?: number; sex: 'male' | 'female' | 'other' | null; } // 스키마가 유효한 사용자를 생성하지 않으면 컴파일 타임에 타입 오류가 발생합니다. const schema: ObjectSchema&lt;Person&gt; = object({ name: string().defined(), age: number().optional(), sex: string&lt;'male' | 'female' | 'other'&gt;().nullable().defined(); }); // ❌ 오류: // &quot;Type 'number | undefined' is not assignable to type 'string'.&quot; const badSchema: ObjectSchema&lt;Person&gt; = object({ name: number(), }); 복사 "},{"title":"새로운 메서드로 내장 스키마 확장하기​","type":1,"pageTitle":"문서","url":"/docs-repository/docs/miscellaneous/yup/doc#새로운-메서드로-내장-스키마-확장하기","content":"원한다면 타입스크립트의 인터페이스 병합 작동을 사용하여 스키마 타입을 확장할 수 있습니다. 타입 확장은 globals.d.ts와 같은 주변 타입 정의 파일에 있어야 합니다. 앱 코드에서 엽 타입을 실제로 확장하는 것을 잊지 말아야 합니다. 주의 병합은 제네릭을 포함하여 타입 정의가 정확히 동일한 경우에만 작동합니다. 각 타입에 대한 엽 소스 코드를 참조하여 올바르게 정의하고 있는지 확인해야 합니다. globals.d.ts typescript declare module 'yup' { interface StringSchema&lt;TType, TContext, TDefault, TFlags&gt; { append(appendStr: string): this; } } 복사 globals.d.ts typescript declare module 'yup' { interface StringSchema&lt;TType, TContext, TDefault, TFlags&gt; { append(appendStr: string): this; } } 복사 app.ts typescript import { addMethod, string } from 'yup'; addMethod(string, 'append', function append(appendStr: string) { return this.transform((value) =&gt; `${value}${appendStr}`); }); string().append('~~~~').cast('hi'); // 'hi~~~~' 복사 app.ts typescript import { addMethod, string } from 'yup'; addMethod(string, 'append', function append(appendStr: string) { return this.transform((value) =&gt; `${value}${appendStr}`); }); string().append('~~~~').cast('hi'); // 'hi~~~~' 복사 "},{"title":"타입스크립트 설정​","type":1,"pageTitle":"문서","url":"/docs-repository/docs/miscellaneous/yup/doc#타입스크립트-설정","content":"형식 추론이 작동하려면 strictNullChecks 컴파일러 옵션이 활성화되어 있어야 합니다. 또한 기능적으로 더 나은 타입을 위해 strictFunctionTypes을 false로 설정하는 것이 좋습니다. 이렇게 하면 전반적인 건전성이 감소하지만 타입스크립트는 이미 메서드와 생성자에 대한 이 검사를 비활성화합니다. (TS 문서 참고) 참고 이 기능을 개발하는 동안 DOM의 일부를 포함하여 본질적으로 안전하지 않은 클래스 계층 구조를 많이 발견했습니다. 따라서 이 설정은 메서드 문법이 아닌 함수 문법으로 작성된 함수에만 적용됩니다. 이득은 다양할 수 있지만, 이 검사가 실제 버그를 많이 방지하지는 못하면서 앱에서 번거로운 명시적 타입 캐스팅의 양을 증가시키는 것으로 보입니다. "},{"title":"오류 메시지 사용자 정의하기​","type":1,"pageTitle":"문서","url":"/docs-repository/docs/miscellaneous/yup/doc#오류-메시지-사용자-정의하기","content":"기본 오류 메시지는 유효성 검사 테스트에 제공된 메시지가 없을 때 사용자 정의할 수 있습니다. 사용자 정의 사전에 메시지가 누락된 경우 오류 메시지는 기본적으로 엽의 것으로 표시됩니다. typescript import { setLocale } from 'yup'; setLocale({ mixed: { default: 'Não é válido', }, number: { min: 'Deve ser maior que ${min}', }, }); // 이제 사용자 정의 사전을 정의한 후에 엽 스키마를 사용한다. let schema = yup.object().shape({ name: yup.string(), age: yup.number().min(18), }); try { await schema.validate({ name: 'jimmy', age: 11 }); } catch (err) { err.name; // =&gt; 'ValidationError' err.errors; // =&gt; ['Deve ser maior que 18'] } 복사 typescript import { setLocale } from 'yup'; setLocale({ mixed: { default: 'Não é válido', }, number: { min: 'Deve ser maior que ${min}', }, }); // 이제 사용자 정의 사전을 정의한 후에 엽 스키마를 사용한다. let schema = yup.object().shape({ name: yup.string(), age: yup.number().min(18), }); try { await schema.validate({ name: 'jimmy', age: 11 }); } catch (err) { err.name; // =&gt; 'ValidationError' err.errors; // =&gt; ['Deve ser maior que 18'] } 복사 "},{"title":"현지화 및 i18n​","type":1,"pageTitle":"문서","url":"/docs-repository/docs/miscellaneous/yup/doc#현지화-및-i18n","content":"엽은 다국어를 지원합니다. setLocale 함수는 번역 키와 값으로 오류 객체를 생성하는 데 사용하는 함수를 인수로 받습니다. 생성된 오류 객체를 원하는 i18n 라이브러리에 넣을 수 있습니다. typescript import { setLocale } from 'yup'; setLocale({ // 값이 없는 메시지에 대한 일정한 번역 키를 사용합니다. mixed: { default: 'field_invalid', }, // 함수를 사용하여 스키마에서 값을 포함한 오류 객체를 생성합니다. number: { min: ({ min }) =&gt; ({ key: 'field_too_short', values: { min } }), max: ({ max }) =&gt; ({ key: 'field_too_big', values: { max } }), }, }); // ... let schema = yup.object().shape({ name: yup.string(), age: yup.number().min(18), }); try { await schema.validate({ name: 'jimmy', age: 11 }); } catch (err) { messages = err.errors.map((err) =&gt; i18next.t(err.key)); } 복사 typescript import { setLocale } from 'yup'; setLocale({ // 값이 없는 메시지에 대한 일정한 번역 키를 사용합니다. mixed: { default: 'field_invalid', }, // 함수를 사용하여 스키마에서 값을 포함한 오류 객체를 생성합니다. number: { min: ({ min }) =&gt; ({ key: 'field_too_short', values: { min } }), max: ({ max }) =&gt; ({ key: 'field_too_big', values: { max } }), }, }); // ... let schema = yup.object().shape({ name: yup.string(), age: yup.number().min(18), }); try { await schema.validate({ name: 'jimmy', age: 11 }); } catch (err) { messages = err.errors.map((err) =&gt; i18next.t(err.key)); } 복사 "},{"title":"동적 API 경로","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/api-경로/동적-api-경로","content":"","keywords":""},{"title":"색인 경로와 동적 API 경로​","type":1,"pageTitle":"동적 API 경로","url":"/docs-repository/docs/next-js/문서/api-경로/동적-api-경로#색인-경로와-동적-api-경로","content":"매우 일반적인 RESTful 패턴은 경로를 다음과 같이 설정하는 것입니다. GET api/posts - 페이지가 매겨진 게시물 목록을 얻음GET api/posts/12345- 아이디가 12345인 게시물을 얻음 이를 두 가지 방법으로 모델링할 수 있습니다. 옵션 1: /api/posts.js/api/posts/[postId].js 옵션 2: /api/posts/index.js/api/posts/[postId].js 두 옵션은 동일합니다. /api/posts/[postId].js만을 사용하는 것은 유효하지 않습니다. 동적 경로(아래의 모든 경로 잡기 포함)에는 어떤 상황에서도 undefined 상태가 없고 GET api/posts는 /api/posts/[postId].js와 일치하지 않기 때문입니다. "},{"title":"모든 API 경로 잡기​","type":1,"pageTitle":"동적 API 경로","url":"/docs-repository/docs/next-js/문서/api-경로/동적-api-경로#모든-api-경로-잡기","content":"API 경로는 대괄호 안에 점 세 개(...)를 추가해 모든 경로를 잡도록 확장할 수 있습니다. 예를 들어 pages/api/post/[...slug].js는 /api/post/a뿐만 아니라 /api/post/a/b, /api/post/a/b/c 등을 일치시킵니다. 참고 slug 대신 [...param]와 같은 다른 이름을 사용할 수 있습니다. 일치하는 매개변수는 페이지에 쿼리 매개변수(예시에서는 slug)로 전송되며, 항상 배열이므로 경로 api/post/a의 query 객체는 다음과 같습니다. json { &quot;slug&quot;: [&quot;a&quot;] } 복사 json { &quot;slug&quot;: [&quot;a&quot;] } 복사 그리고 api/post/a/b와 같은 경로에는 다음과 같이 새 매개변수가 배열에 추가됩니다. json { &quot;slug&quot;: [&quot;a&quot;, &quot;b&quot;] } 복사 json { &quot;slug&quot;: [&quot;a&quot;, &quot;b&quot;] } 복사 pages/api/post/[...slug].js에 대한 API 경로는 다음과 같이 작성할 수 있습니다. js export default function handler(req, res) { const { slug } = req.query; res.end(`Post: ${slug.join(', ')}`); } 복사 js export default function handler(req, res) { const { slug } = req.query; res.end(`Post: ${slug.join(', ')}`); } 복사 이제 /api/post/a/b/c에 대한 요청은 Post: a, b, c로 응답합니다. "},{"title":"선택적으로 모든 API 경로 잡기​","type":1,"pageTitle":"동적 API 경로","url":"/docs-repository/docs/next-js/문서/api-경로/동적-api-경로#선택적으로-모든-api-경로-잡기","content":"'모든 경로 잡기'는 이중 대괄호에 매개변수를 넣어서([[...slug]]) 선택적으로 만들 수 있습니다. 예를 들어 pages/api/post/[[...slug]].js는 /api/post, /api/post/a, /api/post/a/b를 일치시킵니다. '선택적으로 모든 경로 잡기'의 주요 차이점은 매개변수가 없는 경로도 일치한다는 점입니다. /api/post가 그 예입니다. query 객체는 다음과 같습니다. json { } // '/api/post'를 얻습니다. (빈 객체) { &quot;slug&quot;: [&quot;a&quot;] } // '/api/post/a'를 얻습니다. (단일 요소를 가진 배열) { &quot;slug&quot;: [&quot;a&quot;, &quot;b&quot;] } // '/api/post/a/b'를 얻습니다. (여러 요소를 가진 배열) 복사 json { } // '/api/post'를 얻습니다. (빈 객체) { &quot;slug&quot;: [&quot;a&quot;] } // '/api/post/a'를 얻습니다. (단일 요소를 가진 배열) { &quot;slug&quot;: [&quot;a&quot;, &quot;b&quot;] } // '/api/post/a/b'를 얻습니다. (여러 요소를 가진 배열) 복사 "},{"title":"주의 사항​","type":1,"pageTitle":"동적 API 경로","url":"/docs-repository/docs/next-js/문서/api-경로/동적-api-경로#주의-사항","content":"미리 정의된 API 경로는 동적 API 경로보다 우선하며 동적 API 경로는 모든 API 경로를 잡습니다. 예시: pages/api/post/create.js는 /api/post/create를 일치시킴pages/api/post/[pid].js는 /api/post/1, /api/post/abc를 일치시킴. /api/post/create는 일치시키지 않음pages/api/post/[...slug].js는 /api/post/1/2, /api/post/a/b/c를 일치시킴. /api/post/create, /api/post/abc는 일치시키지 않음 "},{"title":"API 경로","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/api-경로/소개","content":"","keywords":""},{"title":"유스 케이스​","type":1,"pageTitle":"API 경로","url":"/docs-repository/docs/next-js/문서/api-경로/소개#유스-케이스","content":"새 프로젝트의 경우에는 API 경로를 사용하여 전체 API를 만들 수 있습니다. 기존 API가 있는 경우에는 API 경로를 통해 API에 호출을 전달할 필요가 없습니다. 기타 유스 케이스는 다음과 같습니다. 외부 서비스의 URL 마스킹하기(예시: /api/secret 대신 https://company.com/secret-url)서버에서 환경 변수를 사용하여 외부 서비스에 안전하게 접근하기 "},{"title":"주의 사항​","type":1,"pageTitle":"API 경로","url":"/docs-repository/docs/next-js/문서/api-경로/소개#주의-사항","content":"API 경로는 CORS 헤더를 지정하지 않습니다. 즉 기본값이 same-origin only입니다. 요청 핸들러를 CORS 미들웨어로 래핑하여 이 작동을 사용자 정의하는 것이 가능합니다.API 경로는 next export와 함께 사용할 수 없습니다. "},{"title":"요청 헬퍼","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/api-경로/요청-헬퍼","content":"요청 헬퍼 API 경로는 들어오는 요청(req)을 분석하는 내장 요청 헬퍼를 제공합니다. req.cookies - 요청에 의해 전송된 쿠키가 포함된 객체입니다. 기본값은 {}입니다.req.query - 쿼리 문자열을 포함하는 객체입니다. 기본값은 {}입니다.req.body - content-type에 의해 분석된 본문을 포함하는 객체입니다. 본문이 전송되지 않은 경우 null입니다.","keywords":""},{"title":"넥스트의 작동 방식","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/기본-개념/넥스트의-작동-방식","content":"","keywords":""},{"title":"개발과 프로덕션 환경​","type":1,"pageTitle":"넥스트의 작동 방식","url":"/docs-repository/docs/next-js/문서/기본-개념/넥스트의-작동-방식#개발과-프로덕션-환경","content":"환경은 코드가 실행되는 컨텍스트(context)입니다. 개발하는 동안에는 로컬 시스템에서 앱을 빌드하고 실행합니다. 프로덕션(production)으로 가는 것은 앱을 배포하고 사용자가 사용할 수 있도록 준비하는 과정입니다. 넥스트는 앱의 개발과 프로덕션 단계를 위한 기능을 제공합니다. 개발 단계에서 넥스트는 개발자와 앱 구축 경험을 최적화합니다. 타입스크립트 및 ESLint 통합, 빠른 새로고침 등과 같은 기능을 통해 개발자 경험을 향상시킵니다.프로덕션 단계에서 넥스트는 최종 사용자와 앱 사용 경험을 최적화합니다. 코드를 변환하여 성능과 접근성을 높이는 것을 목표로 한다. 환경마다 고려 사항과 목표가 다르기 때문에 앱을 개발에서 프로덕션으로 옮기려면 해야 할 일이 많습니다. 예를 들어 앱 코드는 컴파일, 번들링, 축소, 코드 분할이 필요합니다. "},{"title":"컴파일​","type":1,"pageTitle":"넥스트의 작동 방식","url":"/docs-repository/docs/next-js/문서/기본-개념/넥스트의-작동-방식#컴파일","content":"개발자는 JSX, 타입스크립트, 최신 버전의 자바스크립트와 같이 개발자에게 더 친숙한 언어로 코드를 작성합니다. 이러한 언어는 개발자의 효율성과 자신감을 향상시키지만 브라우저가 이를 이해하려면 자바스크립트로 컴파일해야 합니다. 컴파일(Compiling)은 한 언어로 된 코드를 다른 언어 또는 해당 언어의 다른 버전으로 출력하는 과정을 의미합니다.  넥스트에서 컴파일은 코드를 편집할 때 개발 단계에서 발생합니다. 그리고 프로덕션을 위해 앱을 준비하는 빌드 단계에서도 발생합니다. "},{"title":"축소​","type":1,"pageTitle":"넥스트의 작동 방식","url":"/docs-repository/docs/next-js/문서/기본-개념/넥스트의-작동-방식#축소","content":"개발자는 사람의 가독성에 최적화된 코드를 작성합니다. 이 코드에는 주석, 공백, 들여쓰기, 여러 줄과 같이 코드를 실행하는 데 필요하지 않은 추가 정보가 포함됩니다. 축소(Minifying)는 코드의 기능을 변경하지 않고 불필요한 코드 서식과 주석을 제거하는 과정입니다. 목표는 파일 크기를 줄여 응용 프로그램의 성능을 향상시키는 것입니다.  넥스트에서 자바스크립트와 CSS 파일은 프로덕션을 위해 자동으로 축소됩니다. "},{"title":"번들링​","type":1,"pageTitle":"넥스트의 작동 방식","url":"/docs-repository/docs/next-js/문서/기본-개념/넥스트의-작동-방식#번들링","content":"개발자는 앱을 더 큰 부분의 앱을 구축하는 데 사용할 수 있는 모듈, 컴포넌트, 기능으로 나눕니다. 이러한 내부 모듈과 외부의 서드 파티 패키지를 내보내고 가져오면 파일 종속성을 가지는 복잡한 웹이 만들어집니다. 번들링(Bundling)은 웹 종속성을 해결하고 파일(또는 모듈)을 브라우저에 최적화된 번들로 병합(패키징)하는 과정입니다. 이를 통해 사용자가 웹 페이지를 방문할 때 요청하는 파일의 수를 줄일 수 있습니다.  "},{"title":"코드 분할​","type":1,"pageTitle":"넥스트의 작동 방식","url":"/docs-repository/docs/next-js/문서/기본-개념/넥스트의-작동-방식#코드-분할","content":"개발자는 일반적으로 앱을 다른 URL에서 액세스할 수 있는 여러 페이지로 분할합니다. 이러한 각 페이지는 앱에 대한 고유한 진입점(entry point)이 됩니다. 코드 분할(Code Splitting)은 앱 번들을 각 진입점에 필요한 더 작은 청크(chunk)로 분할하는 과정입니다. 이를 통해 해당 페이지를 실행하는 데 필요한 코드만 로드하여 앱의 초기 로드 시간을 개선합니다.  넥스트는 코드 분할을 기본적으로 지원합니다. 디렉터리 내의 각 파일 pages/는 빌드 단계에서 자동으로 자체 자바스크립트 번들로 코드 분할됩니다. 더 나아가 넥스트는 다음의 기능을 지원합니다. 페이지 간에 공유되는 모든 코드는 추가 탐색 시 동일한 코드를 다시 다운로드하지 않도록 다른 번들로 분할됩니다.초기 페이지 로드 후에 넥스트는 사용자가 탐색할 가능성이 있는 다른 페이지의 코드를 미리 로드할 수 있습니다.동적 가져오기는 처음에 로드되는 코드를 수동으로 분할하는 또 다른 방법입니다. "},{"title":"빌드 타임과 런타임​","type":1,"pageTitle":"넥스트의 작동 방식","url":"/docs-repository/docs/next-js/문서/기본-개념/넥스트의-작동-방식#빌드-타임과-런타임","content":"빌드 타임(빌드 단계)은 프로덕션용 앱 코드를 준비하는 일련의 단계입니다. 앱을 빌드할 때 넥스트는 코드를 프로덕션에 최적화된 파일로 변환하여 서버에 배포하고 사용자가 사용할 수 있게 됩니다. 이러한 파일에는 다음이 포함됩니다. 정적으로 생성된 페이지용 HTML 파일서버에서 페이지를 렌더링하기 위한 자바스크립트 코드클라이언트에서 페이지를 대화형으로 만들기 위한 자바스크립트 코드CSS 파일 런타임(요청 타임)은 앱이 빌드되고 배포된 후, 사용자의 요청에 대한 응답으로 앱이 실행되는 때를 의미합니다. "},{"title":"클라이언트와 서버​","type":1,"pageTitle":"넥스트의 작동 방식","url":"/docs-repository/docs/next-js/문서/기본-개념/넥스트의-작동-방식#클라이언트와-서버","content":"웹 앱의 맥락에서 클라이언트는 앱 코드에 대한 요청을 서버에 보내는 사용자 장치의 브라우저를 의미합니다. 클라이언트는 서버에서 받은 응답을 사용자가 상호 작용할 수 있는 인터페이스로 바꿉니다. 서버는 앱 코드를 저장하고, 클라이언트로부터 요청을 수신하고, 일부 계산을 수행하고, 적절한 응답을 다시 보내는 데이터 센터의 컴퓨터를 의미합니다.  "},{"title":"렌더링​","type":1,"pageTitle":"넥스트의 작동 방식","url":"/docs-repository/docs/next-js/문서/기본-개념/넥스트의-작동-방식#렌더링","content":"리액트에서 작성한 코드를 UI의 HTML 표현으로 변환하는 데 반드시 필요한 과정이 있습니다. 바로 렌더링(rendering)입니다. 렌더링은 서버나 클라이언트에서 수행될 수 있습니다. 빌드에서 미리 렌더링하거나, 런타임의 모든 요청에서 렌더링이 발생할 수 있습니다. 넥스트에서는 서버 측 렌더링(Server-Side Rendering, SSR), 정적 사이트 생성(Static Site Generation, SSG), 클라이언트 측 렌더링(Client-Side Rendering, CSR)의 세 가지 유형의 렌더링 방법을 사용할 수 있습니다. "},{"title":"사전 렌더링​","type":1,"pageTitle":"넥스트의 작동 방식","url":"/docs-repository/docs/next-js/문서/기본-개념/넥스트의-작동-방식#사전-렌더링","content":"SSR과 SSG은 결과가 클라이언트로 전송되기 전에 외부 데이터를 가져오고 리액트 컴포넌트를 HTML로 변환하기 때문에 사전 렌더링(Pre-Rendering)이라고도 부릅니다. "},{"title":"CSR vs 사전 렌더링​","type":1,"pageTitle":"넥스트의 작동 방식","url":"/docs-repository/docs/next-js/문서/기본-개념/넥스트의-작동-방식#csr-vs-사전-렌더링","content":"표준 리액트 앱에서 브라우저는 서버로부터 UI를 만드는 자바스크립트의 지시와 빈 HTML 껍데기를 받습니다. 초기 렌더링 작업이 사용자의 장치에서 발생하기 때문에 이것을 CSR이라고 합니다.  참고 리액트의 useEffect()나 useSWR과 같은 데이터 가져오기 훅으로 데이터를 가져와서 넥스트 앱의 특정 컴포넌트에 대해 CSR을 사용할 수 있습니다. 이와 반대로 넥스트는 기본적으로 모든 페이지를 미리 렌더링합니다. 사전 렌더링은 HTML이 사용자 장치에서 자바스크립트로 모두 수행되는 대신 서버에서 미리 생성된다는 것을 의미합니다. 완전히 클라이언트 측에서 렌더링되는 앱의 경우, 렌더링 작업이 완료되기 전에는 사용자에게 빈 페이지가 표시됩니다. 반면 사전 렌더링된 앱에서는 사용자가 다음과 같이 만들어진 HTML을 볼 수 있습니다.  사전 렌더링은 SSR와 SSG라는 두 가지 유형으로 나뉩니다. "},{"title":"SSR​","type":1,"pageTitle":"넥스트의 작동 방식","url":"/docs-repository/docs/next-js/문서/기본-개념/넥스트의-작동-방식#ssr","content":"SSR을 사용하면 각 요청에 대한 페이지의 HTML이 서버에서 생성됩니다. 페이지를 상호작용형으로 만들기 위해 생성된 HTML, JSON 데이터, 자바스크립트 지시가 클라이언트로 전송됩니다. 클라이언트에서 HTML은 빠른 비상호작용형 페이지를 표시하는 데 사용되는 반면 리액트는 JSON 데이터와 자바스크립트 지시를 사용하여 컴포넌트를 상호작용(예: 버튼에 이벤트 핸들러 연결)이 가능하게 만듭니다. 이 과정을 수화(hydration)라고 부릅니다. 넥스트에서는 getServerSideProps를 사용하여 SSR로 페이지를 만들 수 있습니다. "},{"title":"SSG​","type":1,"pageTitle":"넥스트의 작동 방식","url":"/docs-repository/docs/next-js/문서/기본-개념/넥스트의-작동-방식#ssg","content":"SSG를 사용하면 HTML이 서버에서 생성되지만 SSR과 달리 런타임에는 서버가 없습니다. 대신 앱이 배포될 때 빌드에서 콘텐츠가 한 번 생성되고 HTML이 CDN에 저장되서 각 요청에 재사용됩니다. 넥스트에서는 getStaticProps를 사용하여 SSG로 페이지를 만들 수 있습니다. 참고 증분형 정적 재생성을 사용하여 사이트를 구축한 후에 정적 페이지를 생성하거나 갱신할 수 있습니다. 즉 데이터가 변경되더라도 전체 사이트를 다시 만들 필요가 없습니다. 넥스트의 장점은 SSG, SSR, SCR에 관계없이 페이지별로 유스 케이스에 가장 적합한 렌더링 방법을 선택할 수 있다는 것입니다. 특정 유스 케이스에 적합한 렌더링 방법에 대한 자세한 내용은 데이터 가져오기에서 확인하세요. "},{"title":"네트워크​","type":1,"pageTitle":"넥스트의 작동 방식","url":"/docs-repository/docs/next-js/문서/기본-개념/넥스트의-작동-방식#네트워크","content":"앱이 네트워크에 배포된 후에 앱 코드가 어디에 저장되고 실행되는지 알 필요가 있습니다. 넥스트 앱의 경우에는 앱 코드를 오리진 서버, CDN(Content Delivery Network), 에지(Edge)에 배포할 수 있습니다. "},{"title":"오리진 서버​","type":1,"pageTitle":"넥스트의 작동 방식","url":"/docs-repository/docs/next-js/문서/기본-개념/넥스트의-작동-방식#오리진-서버","content":"서버는 앱 코드의 원본 버전을 저장하고 실행하는 메인 컴퓨터를 의미합니다. CDN 서버나 에지 서버와 같이 앱 코드가 배포될 수 있는 다른 장소와 구별하기 위해 오리진(origin)이라는 용어를 사용합니다. 오리진 서버는 요청을 받으면 응답을 보내기 전에 몇 가지 계산을 수행합니다. 이 계산 작업의 결과는 CDN으로 이동될 수 있습니다. "},{"title":"CDN​","type":1,"pageTitle":"넥스트의 작동 방식","url":"/docs-repository/docs/next-js/문서/기본-개념/넥스트의-작동-방식#cdn","content":"CDN은 전 세계 여러 위치에 정적 콘텐츠(예: HTML 및 이미지 파일)를 저장하고 클라이언트와 원본 서버 사이에 배치됩니다. 새 요청이 들어오면 사용자와 가장 가까운 CDN 위치에서 캐시된 결과로 응답할 수 있습니다.  이렇게 하면 각 요청에 대해 계산을 수행할 필요가 없기 때문에 오리진의 부하가 줄어듭니다. 또한 응답이 지리적으로 더 가까운 위치에서 제공되기 때문에 사용자가 더 빠르게 작업할 수 있습니다. 넥스트에서는 사전 렌더링을 미리 수행할 수 있습니다. 그리고 CDN은 작업의 정적 결과를 저장하는 데 적합하므로 콘텐츠 전달이 빨라집니다. "},{"title":"에지​","type":1,"pageTitle":"넥스트의 작동 방식","url":"/docs-repository/docs/next-js/문서/기본-개념/넥스트의-작동-방식#에지","content":"에지(edge)는 사용자에게 가장 가까운 네트워크의 프린지(fringe)에 대한 일반화된 개념입니다. CDN은 네트워크의 가장자리(에지)에 정적 콘텐츠를 저장하기 때문에 에지의 일부로 볼 수 있습니다. CDN과 유사하게 에지 서버는 전 세계 여러 위치에 배포됩니다. 그러나 정적 콘텐츠를 저장하는 CDN과 달리 일부 에지 서버는 코드를 실행할 수 있습니다. 즉 사용자에게 더 가까운 에지에서 캐싱과 코드 실행을 모두 수행할 수 있습니다. 에지에서 코드를 실행하면 전통적으로 클라이언트 측 또는 서버 측에서 수행되었던 작업 중 일부를 에지로 이동할 수 있습니다(예시 참고). 이렇게 하면 클라이언트로 전송되는 코드의 양이 줄어들고 사용자 요청의 일부가 원본 서버로 완전히 돌아갈 필요가 없으므로 앱의 성능이 향상되어 대기 시간이 줄어듭니다. 넥스트에서는 미들웨어를 사용하여 에지에서 코드를 실행할 수 있습니다. 곧 리액트 서버 컴포넌트로도 가능해질 예정입니다. "},{"title":"응답 헬퍼","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/api-경로/응답-헬퍼","content":"","keywords":""},{"title":"응답의 상태 코드 설정하기​","type":1,"pageTitle":"응답 헬퍼","url":"/docs-repository/docs/next-js/문서/api-경로/응답-헬퍼#응답의-상태-코드-설정하기","content":"클라이언트에 응답을 다시 보낼 때 응답의 상태 코드를 설정할 수 있습니다. 다음 예시에서는 응답의 상태 코드를 200(OK)으로 설정하고 message 프로퍼티의 값이 Hello from Next.js!인 JSON 응답을 반환합니다. js export default function handler(req, res) { res.status(200).json({ message: 'Hello from Next.js!' }); } 복사 js export default function handler(req, res) { res.status(200).json({ message: 'Hello from Next.js!' }); } 복사 "},{"title":"JSON 응답 보내기​","type":1,"pageTitle":"응답 헬퍼","url":"/docs-repository/docs/next-js/문서/api-경로/응답-헬퍼#json-응답-보내기","content":"클라이언트에 응답을 다시 보낼 때 JSON 응답을 보낼 수 있습니다. JSON 응답은 직렬화 가능한 객체여야 합니다. 실제 앱에서는 요청된 엔드포인트의 결과에 따른 요청 상태를 클라이언트에 전달할 수도 있습니다. 다음 예시에서는 상태 코드 200(OK)과 비동기 작업의 결과가 포함된 JSON 응답을 보냅니다. 오류 처리를 위해 try...catch문에 포함되어 있으며 적절한 상태 코드와 오류 메시지가 잡아서 클라이언트로 다시 전송합니다. js export default async function handler(req, res) { try { const result = await someAsyncOperation(); res.status(200).json({ result }); } catch (err) { res.status(500).json({ error: 'failed to load data' }); } } 복사 js export default async function handler(req, res) { try { const result = await someAsyncOperation(); res.status(200).json({ result }); } catch (err) { res.status(500).json({ error: 'failed to load data' }); } } 복사 "},{"title":"HTTP 응답 보내기​","type":1,"pageTitle":"응답 헬퍼","url":"/docs-repository/docs/next-js/문서/api-경로/응답-헬퍼#http-응답-보내기","content":"HTTP 응답을 보내는 것은 JSON 응답을 보낼 때와 같은 방식으로 작동합니다. 차이점은 응답 본문이 string, object, Buffer가 될 수 있다는 것입니다. 다음 예시에서는 상태 코드 200(OK)과 비동기 작업의 결과가 포함된 HTTP 응답을 보냅니다. js export default async function handler(req, res) { try { const result = await someAsyncOperation(); res.status(200).send({ result }); } catch (err) { res.status(500).send({ error: 'failed to fetch data' }); } } 복사 js export default async function handler(req, res) { try { const result = await someAsyncOperation(); res.status(200).send({ result }); } catch (err) { res.status(500).send({ error: 'failed to fetch data' }); } } 복사 "},{"title":"지정된 경로나 URL로 리디렉션​","type":1,"pageTitle":"응답 헬퍼","url":"/docs-repository/docs/next-js/문서/api-경로/응답-헬퍼#지정된-경로나-url로-리디렉션","content":"클라이언트가 폼을 제출한 후에 지정된 경로나 URL로 리디렉션할 수 있습니다. 다음 예시는 폼이 성공적으로 제출된 경우 클라이언트를 / 경로로 리디렉션합니다. js export default async function handler(req, res) { const { name, message } = req.body; try { await handleFormInputAsync({ name, message }); res.redirect(307, '/'); } catch (err) { res.status(500).send({ error: 'failed to fetch data' }); } } 복사 js export default async function handler(req, res) { const { name, message } = req.body; try { await handleFormInputAsync({ name, message }); res.redirect(307, '/'); } catch (err) { res.status(500).send({ error: 'failed to fetch data' }); } } 복사 "},{"title":"타입스크립트의 타입 추가하기​","type":1,"pageTitle":"응답 헬퍼","url":"/docs-repository/docs/next-js/문서/api-경로/응답-헬퍼#타입스크립트의-타입-추가하기","content":"next에서 NextApiRequest와 NextApiResponse 타입을 가져와 응답 핸들러를 보다 타입에 안전하게 만들 수 있습니다. 또한 응답 데이터의 타입을 지정할 수도 있습니다. ts import type { NextApiRequest, NextApiResponse } from 'next'; type ResponseData = { message: string; }; export default function handler( req: NextApiRequest, res: NextApiResponse&lt;ResponseData&gt; ) { res.status(200).json({ message: 'Hello from Next.js!' }); } 복사 ts import type { NextApiRequest, NextApiResponse } from 'next'; type ResponseData = { message: string; }; export default function handler( req: NextApiRequest, res: NextApiResponse&lt;ResponseData&gt; ) { res.status(200).json({ message: 'Hello from Next.js!' }); } 복사 타입을 사용하는 더 많은 예시를 보려면 타입스크립트 문서를 확인하세요. "},{"title":"사전 렌더링과 데이터 가져오기","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/기본-개념/사전-렌더링과-데이터-가져오기","content":"","keywords":""},{"title":"사전 렌더링​","type":1,"pageTitle":"사전 렌더링과 데이터 가져오기","url":"/docs-repository/docs/next-js/문서/기본-개념/사전-렌더링과-데이터-가져오기#사전-렌더링","content":"기본적으로 넥스트는 모든 페이지를 미리 렌더링합니다. 넥스트는 클라이언트 측 자바스크립트로 모든 작업을 수행하는 대신 각 페이지에 대해 미리 HTML을 생성합니다. 사전 렌더링은 더 나은 성능과 SEO를 제공합니다. 생성된 각 HTML은 해당 페이지에 필요한 최소한의 자바스크립트 코드와 연결됩니다. 브라우저에서 페이지를 로드하면 해당 자바스크립트 코드가 실행되고 페이지가 완전히 상호작용이 가능하게 만들어집니다. 이 과정을 수화(hydration)라고 합니다. 다음 그림들은 사전 렌더링이 있을 때와 없을 때를 설명합니다.   "},{"title":"두 가지 형태의 사전 렌더링​","type":1,"pageTitle":"사전 렌더링과 데이터 가져오기","url":"/docs-repository/docs/next-js/문서/기본-개념/사전-렌더링과-데이터-가져오기#두-가지-형태의-사전-렌더링","content":"넥스트에는 정적 생성(Static Generation)과 SSR(Server-Side Rendering)의 두 가지 사전 렌더링 방식이 있습니다. 둘의 차이점은 페이지에 대한 HTML을 생성하는 시점입니다. 정적 생성은 빌드 시점에서 HTML을 생성하는 사전 렌더링 방식입니다. 사전 렌더링된 HTML은 각 요청에서 재사용됩니다.SSR은 각 요청에 대해 HTML을 생성하는 사전 렌더링 방식입니다.   참고 npm run dev나 yarn dev로 실행하는 개발 모드에서는 정적 생성 페이지를 비롯한 모든 페이지가 각 요청에 대해 사전 렌더링됩니다. "},{"title":"페이지 단위 기준​","type":1,"pageTitle":"사전 렌더링과 데이터 가져오기","url":"/docs-repository/docs/next-js/문서/기본-개념/사전-렌더링과-데이터-가져오기#페이지-단위-기준","content":"넥스트를 사용하면 각 페이지에 사용할 사전 렌더링 방식을 선택할 수 있습니다. 대부분의 페이지에는 정적 생성을 사용하고 일부 페이지에는 SSR을 사용하여 하이브리드 넥스트 앱을 만들 수 있습니다. "},{"title":"정적 생성과 SSR은 언제 사용해야 하나요​","type":1,"pageTitle":"사전 렌더링과 데이터 가져오기","url":"/docs-repository/docs/next-js/문서/기본-개념/사전-렌더링과-데이터-가져오기#정적-생성과-ssr은-언제-사용해야-하나요","content":"정적 생성을 사용하면 페이지를 한 번만 만들고 CDN에서 제공할 수 있으므로 모든 요청에 대해 서버가 페이지를 렌더링하도록 하는 것보다 훨씬 빠릅니다. 따라서 가능하면 정적 생성을 사용하는 것이 좋습니다. 다음을 포함하여 다양한 유형의 페이지에 대해 정적 생성을 사용할 수 있습니다 . 마케팅 페이지블로그 게시물전자상거래 제품 목록도움말 및 문서 &quot;사용자의 요청에 앞서 해당 페이지를 미리 렌더링할 수 있나요?&quot;라는 질문에 대한 대답이 &quot;예&quot;인 경우에는 정적 생성을 선택합니다. 반면 사용자의 요청보다 먼저 페이지를 미리 렌더링할 수 없다면 정적 생성은 좋은 생각이 아닙니다. 페이지에 자주 갱신되는 데이터가 표시되고 요청마다 페이지 콘텐츠가 변경된다면 SSR을 사용할 수 있습니다. 속도는 느려지지만 미리 렌더링된 페이지는 항상 최신 상태로 유지됩니다. 또는 사전 렌더링을 건너뛰고 클라이언트 측 자바스크립트(CSR)를 사용하여 자주 갱신되는 데이터를 채울 수 있습니다. "},{"title":"데이터가 없는 정적 생성과 데이터가 있는 정적 생성​","type":1,"pageTitle":"사전 렌더링과 데이터 가져오기","url":"/docs-repository/docs/next-js/문서/기본-개념/사전-렌더링과-데이터-가져오기#데이터가-없는-정적-생성과-데이터가-있는-정적-생성","content":"정적 생성은 데이터 유무에 관계없이 수행할 수 있습니다. 외부 데이터를 가져올 필요가 없는 페이지는 앱이 프로덕션용으로 빌드될 때 자동으로 정적으로 생성됩니다.  그러나 일부 페이지의 경우에는 먼저 외부 데이터를 가져오고 HTML을 렌더링해야 합니다. 빌드 타임에 파일 시스템에 접근하거나, 외부 API를 가져오거나, 데이터베이스를 쿼리해야 할 수도 있습니다. 넥스트는 데이터가 있는 정적 생성을 기본으로 지원합니다.  "},{"title":"getStaticProps를 이용한 데이터가 있는 정적 생성​","type":1,"pageTitle":"사전 렌더링과 데이터 가져오기","url":"/docs-repository/docs/next-js/문서/기본-개념/사전-렌더링과-데이터-가져오기#getstaticprops를-이용한-데이터가-있는-정적-생성","content":"넥스트에서 페이지 컴포넌트를 내보낼 때 getStaticProps라는 async 함수를 내보낼 수 있습니다. 이 함수를 내보내면 다음과 같이 됩니다. getStaticProps가 프로덕션의 빌드 타임에 실행됨함수 내부에서 외부 데이터를 가져와서 페이지에 프롭으로 전달할 수 있음 jsx export default function Home(props) { ... } export async function getStaticProps() { // 파일 시스템, API, DB 등에서 외부 데이터를 가져옵니다. const data = ... // props 키의 값은 Home 컴포넌트로 전달될 것입니다. return { props: ... } } 복사 jsx export default function Home(props) { ... } export async function getStaticProps() { // 파일 시스템, API, DB 등에서 외부 데이터를 가져옵니다. const data = ... // props 키의 값은 Home 컴포넌트로 전달될 것입니다. return { props: ... } } 복사 기본적으로 getStaticProps는 넥스트에게 다음과 같이 지시하는 것입니다. &quot;이 페이지에는 데이터 종속성이 있습니다. 따라서 빌드 타임에 이 페이지를 사전 렌더링할 때 이 문제를 먼저 해결해야 합니다.&quot; 참고 개발 모드에서는 getStaticProps가 각 요청마다 실행됩니다. "},{"title":"외부 API나 데이터베이스 쿼리로 데이터 가져오기​","type":1,"pageTitle":"사전 렌더링과 데이터 가져오기","url":"/docs-repository/docs/next-js/문서/기본-개념/사전-렌더링과-데이터-가져오기#외부-api나-데이터베이스-쿼리로-데이터-가져오기","content":"파일 시스템은 물론, 외부 API 엔드포인트와 같은 다른 소스에서 데이터를 가져올 수 있습니다. jsx export async function getSortedPostsData() { const res = await fetch('..'); return res.json(); } 복사 jsx export async function getSortedPostsData() { const res = await fetch('..'); return res.json(); } 복사 참고 넥스트는 클라이언트와 서버 모두에서 fetch()을 폴리필합니다. 별도로 가져올 필요가 없습니다. 데이터베이스를 직접 쿼리할 수도 있습니다. jsx import someDatabaseSDK from 'someDatabaseSDK' const databaseClient = someDatabaseSDK.createClient(...) export async function getSortedPostsData() { return databaseClient.query('SELECT posts...') } 복사 jsx import someDatabaseSDK from 'someDatabaseSDK' const databaseClient = someDatabaseSDK.createClient(...) export async function getSortedPostsData() { return databaseClient.query('SELECT posts...') } 복사 이것은 getStaticProps가 서버 측에서만 실행되기 때문에 가능한 것입니다. getStaticProps는 클라이언트 측에서 실행되지 않습니다. 브라우저용 JS 번들에 포함조차 되지 않습니다. 따라서 데이터베이스 쿼리와 같은 코드를 브라우저로 보내지 않고도 직접 작성할 수 있습니다. "},{"title":"개발 vs 프로덕션​","type":1,"pageTitle":"사전 렌더링과 데이터 가져오기","url":"/docs-repository/docs/next-js/문서/기본-개념/사전-렌더링과-데이터-가져오기#개발-vs-프로덕션","content":"npm run dev나 yarn dev로 실행되는 개발에서는 getStaticProps가 요청마다 실행됩니다.프로덕션에서는 getStaticProps가 빌드 타임에 실행됩니다. 이 작동은 getStaticPaths에서 반환되는 fallback 키를 이용해 개선될 수 있습니다. getStaticProps는 빌드 타임에 실행되므로 쿼리 매개변수나 HTTP 헤더와 같이 요청 타임에만 사용할 수 있는 데이터는 사용할 수 없습니다. "},{"title":"페이지에서만 사용 가능​","type":1,"pageTitle":"사전 렌더링과 데이터 가져오기","url":"/docs-repository/docs/next-js/문서/기본-개념/사전-렌더링과-데이터-가져오기#페이지에서만-사용-가능","content":"getStaticProps는 페이지에서만 내보낼 수 있습니다. 페이지가 아닌 파일에서는 내보낼 수 없습니다. 이런 제한이 있는 이유 중 하나는 페이지가 렌더링되기 전에 리액트에 필요한 모든 데이터가 준비되어야 하기 때문입니다. "},{"title":"요청 타임에 데이터를 가져와야 하는 경우​","type":1,"pageTitle":"사전 렌더링과 데이터 가져오기","url":"/docs-repository/docs/next-js/문서/기본-개념/사전-렌더링과-데이터-가져오기#요청-타임에-데이터를-가져와야-하는-경우","content":"사용자의 요청에 앞서 페이지를 미리 렌더링할 수 없는 경우에는 정적 생성이 부적절합니다. 페이지에 자주 갱신되는 데이터가 표시되고 요청마다 페이지 콘텐츠가 변경되는 경우가 존재할 수 있습니다. 이때는 SSR을 사용하거나 사전 렌더링을 건너뛸 수 있습니다. "},{"title":"요청 타임에 데이터 가져오기​","type":1,"pageTitle":"사전 렌더링과 데이터 가져오기","url":"/docs-repository/docs/next-js/문서/기본-개념/사전-렌더링과-데이터-가져오기#요청-타임에-데이터-가져오기","content":"빌드 타임이 아닌 요청 타임에 데이터를 가져와야 하는 경우에는 SSR을 이용할 수 있습니다.  SSR을 이용하려면 페이지에서 getStaticProps 대신 getServerSideProps을 내보내야 합니다. "},{"title":"getServerSideProps 사용하기​","type":1,"pageTitle":"사전 렌더링과 데이터 가져오기","url":"/docs-repository/docs/next-js/문서/기본-개념/사전-렌더링과-데이터-가져오기#getserversideprops-사용하기","content":"다음은 getServerSideProps의 시작 코드입니다. jsx export async function getServerSideProps(context) { return { props: { // 컴포넌트에게 전달될 프롭 }, }; } 복사 jsx export async function getServerSideProps(context) { return { props: { // 컴포넌트에게 전달될 프롭 }, }; } 복사 getServerSideProps는 요청 타임에 호출되기 때문에 해당 매개변수 context에는 요청 관련 매개변수가 포함됩니다. 요청 타임에 데이터를 가져와야 하는 페이지를 사전 렌더링해야 하는 경우에만 getServerSideProps을 사용해야 합니다. getServerSideProps의 첫 바이트까지의 시간(TTFB)은 getStaticProps보다 느릴 것입니다. 서버가 매 요청마다 결과를 계산해야 하고 별도의 설정 없이는 CDN에서 결과를 캐시할 수 없기 때문입니다. "},{"title":"CSR​","type":1,"pageTitle":"사전 렌더링과 데이터 가져오기","url":"/docs-repository/docs/next-js/문서/기본-개념/사전-렌더링과-데이터-가져오기#csr","content":"데이터를 미리 렌더링할 필요가 없다면 CSR이라고 불리는 다음의 전략을 사용할 수 있습니다. 페이지에서 외부 데이터가 필요하지 않은 부분을 정적으로 생성(사전 렌더링)함페이지가 로드되면 자바스크립트를 사용하여 클라이언트에서 외부 데이터를 가져오고 나머지 부분을 채움  이 접근 방식의 적절한 예시로는 사용자 대시보드 페이지가 있습니다. 대시보드는 사용자별 비공개 페이지이므로 SEO와 관련이 없으며 페이지를 미리 렌더링 할 필요가 없습니다. 데이터는 자주 갱신되므로 요청 타임의 데이터 가져오기가 필요합니다. "},{"title":"SWR​","type":1,"pageTitle":"사전 렌더링과 데이터 가져오기","url":"/docs-repository/docs/next-js/문서/기본-개념/사전-렌더링과-데이터-가져오기#swr","content":"넥스트 뒤에 있는 팀은 데이터 가져오기를 위한 리액트 훅, SWR을 만들었습니다. 클라이언트 측에서 데이터를 가져오는 경우에 적극 권장합니다. 캐싱, 재검증, 포커스 추적, 일정 시간마다 다시 가져오기 등을 처리합니다. 다음은 간단한 사용 예시입니다. jsx import useSWR from 'swr'; function Profile() { const { data, error } = useSWR('/api/user', fetch); if (error) return &lt;div&gt;failed to load&lt;/div&gt;; if (!data) return &lt;div&gt;loading...&lt;/div&gt;; return &lt;div&gt;hello {data.name}!&lt;/div&gt;; } 복사 jsx import useSWR from 'swr'; function Profile() { const { data, error } = useSWR('/api/user', fetch); if (error) return &lt;div&gt;failed to load&lt;/div&gt;; if (!data) return &lt;div&gt;loading...&lt;/div&gt;; return &lt;div&gt;hello {data.name}!&lt;/div&gt;; } 복사 자세한 내용은 SWR에서 확인하세요. "},{"title":"글꼴 최적화","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/기본-기능/글꼴-최적화","content":"","keywords":""},{"title":"사용법​","type":1,"pageTitle":"글꼴 최적화","url":"/docs-repository/docs/next-js/문서/기본-기능/글꼴-최적화#사용법","content":"넥스트 앱에 웹 글꼴를 추가하려면 사용자 정의 Document에 글꼴를 추가합니다. jsx // pages/_document.js import Document, { Html, Head, Main, NextScript } from 'next/document'; class MyDocument extends Document { render() { return ( &lt;Html&gt; &lt;Head&gt; &lt;link href=&quot;https://fonts.googleapis.com/css2?family=Inter&amp;display=optional&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/Head&gt; &lt;body&gt; &lt;Main /&gt; &lt;NextScript /&gt; &lt;/body&gt; &lt;/Html&gt; ); } } export default MyDocument; 복사 jsx // pages/_document.js import Document, { Html, Head, Main, NextScript } from 'next/document'; class MyDocument extends Document { render() { return ( &lt;Html&gt; &lt;Head&gt; &lt;link href=&quot;https://fonts.googleapis.com/css2?family=Inter&amp;display=optional&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/Head&gt; &lt;body&gt; &lt;Main /&gt; &lt;NextScript /&gt; &lt;/body&gt; &lt;/Html&gt; ); } } export default MyDocument; 복사 next/head에 글꼴를 추가하는 것은 특정 페이지에만 적용되고 스트리밍 아키텍처에서는 작동하지 않기 때문에 권장하지 않습니다. 자동 웹 글꼴 최적화는 현재 구글 글꼴와 Typekit을 지원하며 곧 다른 글꼴 공급자도 지원할 예정입니다. 또한 로딩 전략과 font-display 값에 대한 제어 기능을 추가할 계획입니다. 자세한 내용은 Google 글꼴 표시를 참조합니다. 참고 글꼴 최적화는 현재 자체 호스팅 글꼴을 지원하지 않습니다. "},{"title":"최적화 비활성화하기​","type":1,"pageTitle":"글꼴 최적화","url":"/docs-repository/docs/next-js/문서/기본-기능/글꼴-최적화#최적화-비활성화하기","content":"넥스트가 글꼴을 최적화하는 것을 원하지 않으면 비활성화할 수 있습니다. next.config.js js module.exports = { optimizeFonts: false, }; 복사 next.config.js js module.exports = { optimizeFonts: false, }; 복사 "},{"title":"getServerSideProps","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-server-side-props","content":"","keywords":""},{"title":"실행 시기​","type":1,"pageTitle":"getServerSideProps","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-server-side-props#실행-시기","content":"getServerSideProps는 서버 측에서만 실행되고 브라우저에서는 실행되지 않습니다. 페이지에서 getServerSideProps를 사용하면 다음의 작업이 수행됩니다. 해당 페이지를 직접 요청하면 getServerSideProps가 요청 타임에 실행됩니다. 해당 페이지는 반환된 프롭으로 미리 렌더링됩니다.next/link나 next/router를 통해 클라이언트 측 페이지 전환에서 해당 페이지를 요청하면, 넥스트가 getServerSideProps을 실행하는 API 요청을 서버에 보냅니다. getServerSideProps는 페이지를 렌더링하는 데 사용할 JSON을 반환합니다. 이 모든 작업은 넥스트에서 자동으로 처리되므로 getServerSideProps 정의 외에는 추가 작업을 수행할 필요가 없습니다. next-code-elimination 도구를 사용하여 넥스트가 클라이언트 측 번들에서 제거하는 것들을 확인할 수 있습니다. getServerSideProps는 페이지에서만 내보낼 수 있습니다. 페이지가 아닌 파일에서는 내보낼 수 없습니다. getServerSideProps를 독립된 함수로 내보내야 한다는 점을 유의해야 합니다. getServerSideProps를 페이지 컴포넌트의 프로퍼티로 추가하면 작동하지 않습니다. getServerSideProps API 레퍼런스는 getServerSideProps에서 사용할 수 있는 모든 매개변수와 프롭을 다룹니다. "},{"title":"사용 시기​","type":1,"pageTitle":"getServerSideProps","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-server-side-props#사용-시기","content":"요청 타임에 데이터를 가져와야 하는 페이지를 렌더링해야 하는 경우에만 getServerSideProps를 사용합니다. 이는 요청의 데이터나 프로퍼티의 근본적 특성 때문일 수 있습니다. 그 예로는 authorization 헤더 또는 지리적 위치가 있습니다. getServerSideProps를 사용하는 페이지는 요청 타임에 서버 측에서 렌더링되며 캐시 제어 헤더가 설정된 경우에만 캐시됩니다. 요청에서 데이터를 렌더링할 필요가 없는 경우에는 클라이언트 측이나 getStaticProps에서 데이터를 가져오는 것을 고려할 필요가 있습니다. "},{"title":"내부에서 API 경로를 사용하는 것은 비효율적​","type":1,"pageTitle":"getServerSideProps","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-server-side-props#내부에서-api-경로를-사용하는-것은-비효율적","content":"서버에서 데이터를 가져올 때 API 경로를 사용하고 싶다면 getServerSideProps에서 해당 API 경로를 호출하면 됩니다. 하지만 이는 getServerSideProps와 서버에서 실행되는 API 경로를 둘 다 요청하는 비효율적인 접근 방식입니다. API 경로는 CMS에서 일부 데이터를 가져오는 데 사용됩니다. 그러면 해당 API 경로가 getServerSideProps에서 직접 호출됩니다. 이 방식은 추가 호출이 발생하여 성능이 저하됩니다. 대신 API 경로 내부에서 사용되는 논리를 getServerSideProps로 직접 옮기는 것이 좋습니다. 이는 getServerSideProps 내부에서 직접 CMS, 데이터베이스, 기타 API를 호출하는 것을 의미합니다. "},{"title":"클라이언트 측에서 데이터 가져오기​","type":1,"pageTitle":"getServerSideProps","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-server-side-props#클라이언트-측에서-데이터-가져오기","content":"페이지에 자주 갱신되는 데이터가 포함되어 있고 데이터를 미리 렌더링할 필요가 없는 경우에는 클라이언트 측에서 데이터를 가져올 수 있습니다. 이에 대한 예로는 사용자별 데이터가 있습니다. 먼저 데이터가 없는 페이지를 즉시 표시합니다. 페이지의 일부는 정적 생성을 사용하여 미리 렌더링할 수 있습니다. 누락된 데이터에 대한 로딩 상태를 표시할 수 있습니다.그런 다음 클라이언트 측에서 데이터를 가져와 준비가 되면 표시합니다. 이 접근 방식은 사용자 대시보드 페이지에 적합합니다. 대시보드는 사용자별 비공개 페이지이므로 SEO는 관련이 없으며 페이지를 미리 렌더링할 필요가 없습니다. 데이터가 자주 갱신되므로 요청 타임에 데이터 가져오기를 해야 합니다. "},{"title":"요청 타임에 데이터 가져오기​","type":1,"pageTitle":"getServerSideProps","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-server-side-props#요청-타임에-데이터-가져오기","content":"다음 예시는 요청 타임에 데이터를 가져오고 결과를 미리 렌더링하는 방법을 보여줍니다. jsx function Page({ data }) { // data를 렌더링합니다... } // 이 함수는 매 요청마다 호출됩니다. export async function getServerSideProps() { // 외부 API에서 data를 가져옵니다. const res = await fetch(`https://.../data`); const data = await res.json(); // data를 페이지에 프롭으로 전달합니다. return { props: { data } }; } export default Page; 복사 jsx function Page({ data }) { // data를 렌더링합니다... } // 이 함수는 매 요청마다 호출됩니다. export async function getServerSideProps() { // 외부 API에서 data를 가져옵니다. const res = await fetch(`https://.../data`); const data = await res.json(); // data를 페이지에 프롭으로 전달합니다. return { props: { data } }; } export default Page; 복사 "},{"title":"SSR을 사용한 캐싱​","type":1,"pageTitle":"getServerSideProps","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-server-side-props#ssr을-사용한-캐싱","content":"getServerSideProps 내부의 캐싱 헤더(Cache-Control)를 사용하여 동적 응답을 캐시할 수 있습니다. 예를 들어 stale-while-revalidate을 이용할 수 있습니다. jsx // 이 값은 10초 동안 최신입니다. (s-maxage=10) // 요청이 다음 10초 이내에 반복되면, 이전 캐시 값은 여전히 최신일 것입니다. // 요청이 59초 이전에 반복되면 캐시 값은 오래되었지만 렌더링됩니다. // // 백그라운드에서는 캐시를 새 값으로 채우는 재검증 요청이 수행됩니다. // 페이지를 새로고침하면 새 값을 보게 됩니다. export async function getServerSideProps({ req, res }) { res.setHeader( 'Cache-Control', 'public, s-maxage=10, stale-while-revalidate=59' ); return { props: {}, }; } 복사 jsx // 이 값은 10초 동안 최신입니다. (s-maxage=10) // 요청이 다음 10초 이내에 반복되면, 이전 캐시 값은 여전히 최신일 것입니다. // 요청이 59초 이전에 반복되면 캐시 값은 오래되었지만 렌더링됩니다. // // 백그라운드에서는 캐시를 새 값으로 채우는 재검증 요청이 수행됩니다. // 페이지를 새로고침하면 새 값을 보게 됩니다. export async function getServerSideProps({ req, res }) { res.setHeader( 'Cache-Control', 'public, s-maxage=10, stale-while-revalidate=59' ); return { props: {}, }; } 복사 캐싱에서 자세한 내용을 확인하세요. "},{"title":"오류 페이지 렌더링​","type":1,"pageTitle":"getServerSideProps","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-server-side-props#오류-페이지-렌더링","content":"getServerSideProps 내부에서 오류가 발생하면 pages/500.js 파일이 표시됩니다. 해당 파일을 만드는 방법은 500 페이지 문서를 확인하세요. 개발 중에는 이 파일이 사용되지 않고 대신 개발 오버레이가 표시됩니다. "},{"title":"내장 CSS 지원","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/기본-기능/내장-css-지원","content":"","keywords":""},{"title":"전역 스타일시트 추가하기​","type":1,"pageTitle":"내장 CSS 지원","url":"/docs-repository/docs/next-js/문서/기본-기능/내장-css-지원#전역-스타일시트-추가하기","content":"앱에 스타일시트를 추가하려면 pages/_app.js 내부에서 CSS 파일을 가져옵니다. 예를 들어 다음과 같이 styles.css라는 스타일시트가 있다고 가정해 보겠습니다. css body { font-family: 'SF Pro Text', 'SF Pro Icons', 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif; padding: 20px 20px 60px; max-width: 680px; margin: 0 auto; } 복사 css body { font-family: 'SF Pro Text', 'SF Pro Icons', 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif; padding: 20px 20px 60px; max-width: 680px; margin: 0 auto; } 복사 pages/_app.js 파일이 없으면 새로 만듭니다. 그리고 styles.css를 import합니다. jsx import '../styles.css'; // 이 default export는 새 'pages/_app.js' 파일에서 필요합니다. export default function MyApp({ Component, pageProps }) { return &lt;Component {...pageProps} /&gt;; } 복사 jsx import '../styles.css'; // 이 default export는 새 'pages/_app.js' 파일에서 필요합니다. export default function MyApp({ Component, pageProps }) { return &lt;Component {...pageProps} /&gt;; } 복사 이러한 스타일(styles.css)은 앱의 모든 페이지와 컴포넌트에 적용됩니다. 스타일시트의 전역적 특성 때문에, 그리고 충돌 방지를 위해 pages/_app.js 내부에서만 가져오는 것이 가능합니다. 개발 단계에서 스타일시트를 이런 식으로 표현하면 스타일을 편집할 때 즉시 다시 로드할 수 있습니다. 즉, 앱의 상태를 최신으로 유지할 수 있습니다. 프로덕션에서 모든 CSS 파일은 자동으로 하나의 축소된 .css 파일로 연결됩니다. "},{"title":"node_modules에서 스타일 가져오기​","type":1,"pageTitle":"내장 CSS 지원","url":"/docs-repository/docs/next-js/문서/기본-기능/내장-css-지원#node_modules에서-스타일-가져오기","content":"넥스트 9.5.4 버전부터 node_modules에서 CSS 파일을 가져오는 것이 앱의 모든 위치에서 허용됩니다. bootstrap이나 nprogress와 같은 전역 스타일시트은 pages/_app.js 내부에서 파일을 가져와야 합니다. 예시: pages/_app.js jsx import 'bootstrap/dist/css/bootstrap.css'; export default function MyApp({ Component, pageProps }) { return &lt;Component {...pageProps} /&gt;; } 복사 pages/_app.js jsx import 'bootstrap/dist/css/bootstrap.css'; export default function MyApp({ Component, pageProps }) { return &lt;Component {...pageProps} /&gt;; } 복사 타사 컴포넌트에 필요한 CSS를 가져오는 경우에는 컴포넌트에서 가져오기를 수행할 수 있습니다. 예시: components/ExampleDialog.js jsx import { useState } from 'react'; import { Dialog } from '@reach/dialog'; import VisuallyHidden from '@reach/visually-hidden'; import '@reach/dialog/styles.css'; function ExampleDialog(props) { const [showDialog, setShowDialog] = useState(false); const open = () =&gt; setShowDialog(true); const close = () =&gt; setShowDialog(false); return ( &lt;div&gt; &lt;button onClick={open}&gt;Open Dialog&lt;/button&gt; &lt;Dialog isOpen={showDialog} onDismiss={close}&gt; &lt;button className=&quot;close-button&quot; onClick={close}&gt; &lt;VisuallyHidden&gt;Close&lt;/VisuallyHidden&gt; &lt;span aria-hidden&gt;×&lt;/span&gt; &lt;/button&gt; &lt;p&gt;Hello there. I am a dialog&lt;/p&gt; &lt;/Dialog&gt; &lt;/div&gt; ); } 복사 components/ExampleDialog.js jsx import { useState } from 'react'; import { Dialog } from '@reach/dialog'; import VisuallyHidden from '@reach/visually-hidden'; import '@reach/dialog/styles.css'; function ExampleDialog(props) { const [showDialog, setShowDialog] = useState(false); const open = () =&gt; setShowDialog(true); const close = () =&gt; setShowDialog(false); return ( &lt;div&gt; &lt;button onClick={open}&gt;Open Dialog&lt;/button&gt; &lt;Dialog isOpen={showDialog} onDismiss={close}&gt; &lt;button className=&quot;close-button&quot; onClick={close}&gt; &lt;VisuallyHidden&gt;Close&lt;/VisuallyHidden&gt; &lt;span aria-hidden&gt;×&lt;/span&gt; &lt;/button&gt; &lt;p&gt;Hello there. I am a dialog&lt;/p&gt; &lt;/Dialog&gt; &lt;/div&gt; ); } 복사 "},{"title":"컴포넌트 수준 CSS 추가하기​","type":1,"pageTitle":"내장 CSS 지원","url":"/docs-repository/docs/next-js/문서/기본-기능/내장-css-지원#컴포넌트-수준-css-추가하기","content":"넥스트는 [name].module.css 파일명 컨벤션을 사용하는 CSS 모듈을 지원합니다. CSS 모듈은 고유한 클래스 이름을 자동으로 생성하여 로컬에서 CSS 범위를 지정합니다. 이를 통해 충돌에 대한 걱정 없이 다른 파일에서 동일한 CSS 클래스 이름을 사용할 수 있습니다. 이는 CSS 모듈을 컴포넌트 수준 CSS로 만듭니다. CSS 모듈 파일은 앱의 어느 곳에서나 가져올 수 있습니다. 예를 들어 components/ 폴더의 Button에 재사용 가능한 컴포넌트가 있다고 가정해 보겠습니다. 먼저 components/Button.module.css을 다음과 같이 작성합니다. css /* '.error {}'가 다른 '.css' 또는 '.module.css' 파일과 충돌하는 것을 걱정할 필요가 없습니다. */ .error { color: white; background-color: red; } 복사 css /* '.error {}'가 다른 '.css' 또는 '.module.css' 파일과 충돌하는 것을 걱정할 필요가 없습니다. */ .error { color: white; background-color: red; } 복사 이제 components/Button.js을 만들고, 위의 CSS 파일을 가져와서 사용합니다. jsx import styles from './Button.module.css'; export function Button() { return ( &lt;button type=&quot;button&quot; // 가져온 `styles` 객체의 프로퍼티로 &quot;error&quot; 클래스에 접근한다. className={styles.error} &gt; Destroy &lt;/button&gt; ); } 복사 jsx import styles from './Button.module.css'; export function Button() { return ( &lt;button type=&quot;button&quot; // 가져온 `styles` 객체의 프로퍼티로 &quot;error&quot; 클래스에 접근한다. className={styles.error} &gt; Destroy &lt;/button&gt; ); } 복사 CSS 모듈은 선택적 기능으로 .module.css 확장자가 있는 파일에만 적용됩니다. 일반적인 &lt;link&gt; 스타일시트와 전역 CSS 파일은 계속 지원됩니다. 프로덕션에서 모든 CSS 모듈 파일은 자동으로 축소 및 코드 분할된 .css 파일로 연결됩니다. 이러한 .css 파일은 앱의 핫 실행 경로를 나타내며 앱이 그려질 수 있는 최소한의 CSS가 로드되게 합니다. "},{"title":"Sass 지원​","type":1,"pageTitle":"내장 CSS 지원","url":"/docs-repository/docs/next-js/문서/기본-기능/내장-css-지원#sass-지원","content":"넥스트를 사용하면 .scss과 .sass 확장자로 Sass를 가져올 수 있습니다. CSS 모듈과 .module.scss 또는 .module.sass 확장자를 통해 컴포넌트 수준 Sass를 사용할 수 있습니다. 넥스트의 내장 Sass 지원을 사용하기 전에 sass를 설치해야 합니다. bash npm install --save-dev sass 복사 bash npm install --save-dev sass 복사 Sass 지원에는 앞에서 설명한 내장 CSS 지원과 동일한 이점과 제한이 적용됩니다. 참고 Sass는 각각 고유한 확장자를 가진 두 가지 다른 문법을 지원합니다. .scss 확장자를 사용하려면 SCSS 문법을 사용해야 하는 반면 .sass 확장자를 사용하려면 들여쓰기 문법(Sass)을 사용해야 합니다. 어떤 것을 선택해야 할지 잘 모르겠다면 들여쓰기 문법(Sass)이 필요 없고 CSS의 상위 집합인 .scss 확장으로 시작하면 됩니다. "},{"title":"Sass 옵션 사용자 정의하기​","type":1,"pageTitle":"내장 CSS 지원","url":"/docs-repository/docs/next-js/문서/기본-기능/내장-css-지원#sass-옵션-사용자-정의하기","content":"Sass 컴파일러를 설정하려면 next.config.js의 sassOptions을 사용하면 됩니다. 예를 들어 includePaths를 추가하려면 다음과 같이 작성합니다. js const path = require('path'); module.exports = { sassOptions: { includePaths: [path.join(__dirname, 'styles')], }, }; 복사 js const path = require('path'); module.exports = { sassOptions: { includePaths: [path.join(__dirname, 'styles')], }, }; 복사 "},{"title":"Sass 변수​","type":1,"pageTitle":"내장 CSS 지원","url":"/docs-repository/docs/next-js/문서/기본-기능/내장-css-지원#sass-변수","content":"넥스트는 CSS 모듈 파일에서 내보낸 Sass 변수를 지원합니다. 다음은 내보낸 primaryColor Sass 변수를 사용하는 예시입니다. variables.module.scss scss $primary-color: #64ff00; :export { primaryColor: $primary-color; } 복사 variables.module.scss scss $primary-color: #64ff00; :export { primaryColor: $primary-color; } 복사 pages/_app.js tsx import variables from '../styles/variables.module.scss'; export default function MyApp({ Component, pageProps }) { return ( &lt;Layout color={variables.primaryColor}&gt; &lt;Component {...pageProps} /&gt; &lt;/Layout&gt; ); } 복사 pages/_app.js tsx import variables from '../styles/variables.module.scss'; export default function MyApp({ Component, pageProps }) { return ( &lt;Layout color={variables.primaryColor}&gt; &lt;Component {...pageProps} /&gt; &lt;/Layout&gt; ); } 복사 "},{"title":"자주 묻는 질문​","type":1,"pageTitle":"내장 CSS 지원","url":"/docs-repository/docs/next-js/문서/기본-기능/내장-css-지원#자주-묻는-질문","content":""},{"title":"자바스크립트를 비활성화해도 CSS가 작동하나요​","type":1,"pageTitle":"내장 CSS 지원","url":"/docs-repository/docs/next-js/문서/기본-기능/내장-css-지원#자바스크립트를-비활성화해도-css가-작동하나요","content":"작동합니다. 자바스크립트를 비활성화해도 CSS가 프로덕션 빌드( next start)에서 여전히 로드됩니다. 하지만 개발 중에 빠른 새로고침 기능을 사용하려면 자바스크립트 활성화가 필요합니다. "},{"title":"getStaticPaths","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-static-paths","content":"","keywords":""},{"title":"사용 시기​","type":1,"pageTitle":"getStaticPaths","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-static-paths#사용-시기","content":"getStaticPaths는 동적 경로와 다음을 사용하는 페이지를 정적으로 사전 렌더링하는 경우에 사용해야 합니다. 데이터를 헤드리스 CMS에서 가져옴데이터를 데이터베이스에서 가져옴데이터를 파일 시스템에서 가져옴데이터를 공개적으로 캐시할 수 있음(사용자 데이터가 아님)페이지는 SEO를 위해 사전 렌더링되어야 하며 매우 빨라야 함. getStaticProps는 HTML과 JSON파일을 생성하며, 둘 다 성능을 위해 CDN에 캐시될 수 있음 "},{"title":"실행 시기​","type":1,"pageTitle":"getStaticPaths","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-static-paths#실행-시기","content":"getStaticPaths는 프로덕션에서 빌드하는 동안에만 실행되며 런타임에는 호출되지 않습니다. 이 도구를 사용하여 getStaticPaths 내부에 작성된 코드가 클라이언트 측 번들에서 제거되었는지 확인할 수 있습니다. "},{"title":"getStaticProps와의 관계​","type":1,"pageTitle":"getStaticPaths","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-static-paths#getstaticprops와의-관계","content":"빌드 중에 반환된 모든 paths에 대해 next build 동안 getStaticProps가 실행됨fallback: true일 때 getStaticProps는 백그라운드에서 실행됨fallback: blocking일 때 getStaticProps는 초기 렌더링 전에 호출됨 "},{"title":"사용 위치​","type":1,"pageTitle":"getStaticPaths","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-static-paths#사용-위치","content":"getStaticPaths는 반드시 getStaticProps와 함께 사용해야 함getStaticPaths는 getServerSideProps와 함께 사용할 수 없음getStaticProps도 사용하는 동적 경로에서 getStaticPaths를 내보낼 수 있음페이지가 아닌 파일(예: components 폴더)에서 getStaticPaths를 내보낼 수 없음getStaticPaths를 페이지 컴포넌트의 프로퍼티가 아닌 독립된 함수로 내보내야 함 "},{"title":"개발 중의 실행 방식​","type":1,"pageTitle":"getStaticPaths","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-static-paths#개발-중의-실행-방식","content":"개발 중(next dev)에는 getStaticPaths가 모든 요청마다 호출됩니다. "},{"title":"주문형 경로 생성하기​","type":1,"pageTitle":"getStaticPaths","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-static-paths#주문형-경로-생성하기","content":"getStaticProps를 사용하면 fallback을 사용하는 주문형 대신 빌드 중에 어떤 페이지를 생성할지 제어할 수 있습니다. 빌드 중에 많은 페이지를 생성하면 빌드가 느려집니다. 빈 배열로 된 paths를 반환하여 주문형으로 모든 페이지 생성을 연기할 수 있습니다. 이는 넥스트 앱을 여러 환경에 배포할 때 특히 유용할 수 있습니다. 예를 들어 미리 보기(프로덕션 빌드는 제외)를 위해 주문형으로 모든 페이지를 생성하여 빌드 속도를 높일 수 있습니다. 이것은 수백에서 수천 개의 정적 페이지가 있는 사이트에 유용합니다. pages/posts/[id].js jsx export async function getStaticPaths() { // 이것이 true이면(미리보기 환경에서는 true임) // 정적 페이지를 사전 렌더링하지 않습니다. // 빌드가 빨라지고 첫 페이지 로딩이 느려집니다. if (process.env.SKIP_BUILD_STATIC_GENERATION) { return { paths: [], fallback: 'blocking', }; } // posts를 얻기 위해 외부 API 엔드포인트를 호출합니다. const res = await fetch('https://.../posts'); const posts = await res.json(); // posts에 기반해 사전 렌더링하고 싶은 paths을 얻습니다. // 프로덕션 환경에서는 모든 페이지를 사전 렌더링합니다. // 빌드는 느려지고 첫 페이지 로딩이 빨라집니다. const paths = posts.map((post) =&gt; ({ params: { id: post.id }, })); // { fallback: false }는 paths 이외의 경로가 404가 된다는 것을 의미합니다. return { paths, fallback: false }; } 복사 pages/posts/[id].js jsx export async function getStaticPaths() { // 이것이 true이면(미리보기 환경에서는 true임) // 정적 페이지를 사전 렌더링하지 않습니다. // 빌드가 빨라지고 첫 페이지 로딩이 느려집니다. if (process.env.SKIP_BUILD_STATIC_GENERATION) { return { paths: [], fallback: 'blocking', }; } // posts를 얻기 위해 외부 API 엔드포인트를 호출합니다. const res = await fetch('https://.../posts'); const posts = await res.json(); // posts에 기반해 사전 렌더링하고 싶은 paths을 얻습니다. // 프로덕션 환경에서는 모든 페이지를 사전 렌더링합니다. // 빌드는 느려지고 첫 페이지 로딩이 빨라집니다. const paths = posts.map((post) =&gt; ({ params: { id: post.id }, })); // { fallback: false }는 paths 이외의 경로가 404가 된다는 것을 의미합니다. return { paths, fallback: false }; } 복사 "},{"title":"getStaticProps","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-static-props","content":"","keywords":""},{"title":"사용 시기​","type":1,"pageTitle":"getStaticProps","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-static-props#사용-시기","content":"다음의 경우에 getStaticProps을 사용해야 합니다. 페이지를 렌더링하는 데 필요한 데이터가 사용자의 요청에 앞서 빌드 타임에 얻을 수 있음데이터를 헤드리스 CMS에서 가져옴페이지는 SEO를 위해 사전 렌더링되어야 하며 매우 빨라야 함. getStaticProps는 HTML과 JSON 파일을 생성하며, 둘 다 성능을 위해 CDN에 캐시될 수 있음데이터가 공개적으로 캐시될 수 있음(사용자 테이터가 아님). 이 조건은 미들웨어를 사용하여 경로를 다시 작성하는 특정 상황에서 우회가 가능함 "},{"title":"실행 시기​","type":1,"pageTitle":"getStaticProps","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-static-props#실행-시기","content":"getStaticProps는 항상 서버에서 실행되고 클라이언트에서는 실행되지 않습니다. 이 도구를 사용하여 getStaticProps 내부에 작성된 코드가 클라이언트 측 번들에서 제거되었는지 확인할 수 있습니다. getStaticProps는 next build 과정에서 항상 실행됨getStaticProps는 fallback: true를 사용할 때 백그라운드에서 실행됨getStaticProps는 fallback: blocking를 사용할 때 첫 렌더링 전에 호출됨getStaticProps는 revalidate를 사용할 때 백그라운드에서 실행됨getStaticProps는 revalidate()을 사용할 때 백그라운드에서 주문형으로 실행됨 증분형 정적 재생성과 함께 사용하면, getStaticProps는 오래된 페이지의 유효성을 다시 검사하고 새 페이지가 브라우저에 제공되는 동안 백그라운드에서 실행됩니다. getStaticProps는 정적 HTML을 생성하므로 들어오는 요청(쿼리 매개변수나 HTTP 헤더)에 접근할 수 없습니다. 페이지 요청에 접근해야 하는 경우에는 getStaticProps에 추가로 미들웨어를 사용하는 것을 고려해야 합니다. "},{"title":"CMS에서 데이터 가져오기​","type":1,"pageTitle":"getStaticProps","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-static-props#cms에서-데이터-가져오기","content":"다음 예시는 CMS에서 블로그 게시물 목록을 가져오는 방법을 보여줍니다. jsx // posts는 빌드 타임에 getStaticProps()에 의해 채워질 것입니다. function Blog({ posts }) { return ( &lt;ul&gt; {posts.map((post) =&gt; ( &lt;li&gt;{post.title}&lt;/li&gt; ))} &lt;/ul&gt; ); } // 이 함수는 서버 측에서 빌드 타임에 호출됩니다. // 클라이언트 측에서 호출되지 않으므로 데이터베이스 쿼리를 여기서 직접 해도 됩니다. export async function getStaticProps() { // posts를 얻기 위해 외부 API 엔드포인트를 호출합니다. // 모든 데이터 가져오기 라이브러리를 사용할 수 있습니다. const res = await fetch('https://.../posts'); const posts = await res.json(); // { props: { posts } }을 반환함으로써, Blog 컴포넌트는 // posts를 빌드 타임에 프롭으로 받을 것입니다. return { props: { posts, }, }; } export default Blog; 복사 jsx // posts는 빌드 타임에 getStaticProps()에 의해 채워질 것입니다. function Blog({ posts }) { return ( &lt;ul&gt; {posts.map((post) =&gt; ( &lt;li&gt;{post.title}&lt;/li&gt; ))} &lt;/ul&gt; ); } // 이 함수는 서버 측에서 빌드 타임에 호출됩니다. // 클라이언트 측에서 호출되지 않으므로 데이터베이스 쿼리를 여기서 직접 해도 됩니다. export async function getStaticProps() { // posts를 얻기 위해 외부 API 엔드포인트를 호출합니다. // 모든 데이터 가져오기 라이브러리를 사용할 수 있습니다. const res = await fetch('https://.../posts'); const posts = await res.json(); // { props: { posts } }을 반환함으로써, Blog 컴포넌트는 // posts를 빌드 타임에 프롭으로 받을 것입니다. return { props: { posts, }, }; } export default Blog; 복사 getStaticProps API 레퍼런스는 getStaticProps에서 사용할 수 있는 모든 매개변수와 프롭을 다룹니다. "},{"title":"서버 측 코드 직접 작성하기​","type":1,"pageTitle":"getStaticProps","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-static-props#서버-측-코드-직접-작성하기","content":"getStaticProps는 서버 측에서만 실행되므로 클라이언트 측에서는 실행되지 않습니다. 브라우저용 JS 번들에도 포함되지 않으므로 브라우저로 보내지 않고 직접 데이터베이스 쿼리를 작성할 수 있습니다. 즉, getStaticProps에서 외부 소스에서 데이터를 가져오는 API 경로를 사용하는 대신 getStaticProps에 직접 서버 측 코드를 작성할 수 있습니다. 다음 예시에서 API 경로는 CMS에서 일부 데이터를 가져오는 데 사용됩니다. 그러면 해당 API 경로가 getStaticProps에서 직접 호출됩니다. 이 방식은 추가적인 호출이 발생하여 성능이 저하됩니다. 대신 CMS에서 데이터를 가져오는 논리를 lib/ 디렉터리에서 getStaticProps에 공유할 수 있습니다. lib/load-posts.js jsx // 다음 함수는 'lib/' 디렉터리에서 // getStaticProps와 API 경로에 공유됩니다. export async function loadPosts() { // posts를 얻기 위해 외부 API 엔드포인트를 호출합니다. const res = await fetch('https://.../posts/'); const data = await res.json(); return data; } 복사 lib/load-posts.js jsx // 다음 함수는 'lib/' 디렉터리에서 // getStaticProps와 API 경로에 공유됩니다. export async function loadPosts() { // posts를 얻기 위해 외부 API 엔드포인트를 호출합니다. const res = await fetch('https://.../posts/'); const data = await res.json(); return data; } 복사 pages/blog.js jsx import { loadPosts } from '../lib/load-posts'; // 이 함수는 서버 측에서만 실행됩니다. export async function getStaticProps() { // '/api' 경로를 가져오는 대신 getStaticProps에서 직접 // 동일한 함수를 호출할 수 있습니다. const posts = await loadPosts(); // 반환되는 프롭은 페이지 컴포넌트에 전달됩니다. return { props: { posts } }; } 복사 pages/blog.js jsx import { loadPosts } from '../lib/load-posts'; // 이 함수는 서버 측에서만 실행됩니다. export async function getStaticProps() { // '/api' 경로를 가져오는 대신 getStaticProps에서 직접 // 동일한 함수를 호출할 수 있습니다. const posts = await loadPosts(); // 반환되는 프롭은 페이지 컴포넌트에 전달됩니다. return { props: { posts } }; } 복사 또는 데이터를 가져오기를 위해 API 경로를 사용하는 대신, fetch() API를 getStaticProps에서 직접 사용하는 것도 가능합니다. 넥스트가 클라이언트 측 번들에서 제거하는 것을 확인하려면 next-code-elimination 도구를 사용할 수 있습니다. "},{"title":"HTML과 JSON을 정적으로 생성하기​","type":1,"pageTitle":"getStaticProps","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-static-props#html과-json을-정적으로-생성하기","content":"getStaticProps가 포함된 페이지가 빌드 타임에 미리 렌더링되면, 넥스트가 페이지 HTML 파일 외에 getStaticProps의 실행 결과를 담은 JSON 파일을 생성합니다. JSON 파일은 next/link이나 next/router를 통한 클라이언트 측 라우팅에 사용됩니다. getStaticProps를 사용하여 미리 렌더링된 페이지로 이동하면 넥스트가 이 JSON 파일(빌드 타임에 미리 계산됨)을 가져와 페이지 컴포넌트의 프롭으로 사용합니다. 즉, 클라이언트 측 페이지 전환은 내보내진 JSON만 사용하고 getStaticProps 자체를 호출하지는 않습니다. "},{"title":"사용 위치​","type":1,"pageTitle":"getStaticProps","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-static-props#사용-위치","content":"getStaticProps는 페이지에서만 내보낼 수 있습니다. 페이지가 아닌 파일, _app, _document, _error에서는 내보낼 수 없습니다. 이런 제한이 있는 이유 중 하나는 페이지가 렌더링되기 전에 리액트에 필요한 모든 데이터가 있어야 하기 때문입니다. 또한 getStaticProps는 독립된 함수로 내보내야 합니다. getStaticProps를 페이지 컴포넌트의 프로퍼티로 추가하면 작동하지 않습니다. 참고 사용자 정의 앱을 만든 경우에는 pageProps를 링크 문서에 설명된 대로 페이지 컴포넌트에 전달하고 있는지 확인해야 합니다. 그러지 않으면 프롭이 비어 있을 것입니다. "},{"title":"개발 중의 실행 방식​","type":1,"pageTitle":"getStaticProps","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-static-props#개발-중의-실행-방식","content":"개발 중(next dev)에는 getStaticProps가 모든 요청마다 호출됩니다. "},{"title":"미리보기 모드​","type":1,"pageTitle":"getStaticProps","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/get-static-props#미리보기-모드","content":"미리보기 모드를 사용하여 빌드 타임 대신 요청 타임에 정적 생성을 우회하고 페이지를 렌더링할 수 있습니다. 예를 들어 헤드리스 CMS를 사용 중이며 초안이 게시되기 전에 미리보기를 원할 수 있습니다. "},{"title":"개요","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/intro","content":"개요 넥스트에서 데이터 가져오기를 사용하면 앱의 유스 케이스에 따라 다양한 방식으로 콘텐츠를 렌더링할 수 있습니다. 여기에는 SSR이나 정적 생성을 사용한 사전 렌더링, 증분형 정적 재생성으로 런타임에 콘텐츠를 갱신하거나 생성하기가 포함됩니다. 각 문서에 해당하는 데이터 가져오기는 다음과 같습니다. getServerSideProps - SSR (서버 측 렌더링)getStaticPaths - 동적 라우팅getStaticProps - SSG (정적 사이트 생성)증분형 정적 재생성 - ISR클라이언트 측 - CSR (클라이언트 측 렌더링) 📄️ getServerSideProps 페이지에서 getServerSideProps(SSR)이라는 함수를 내보내면, 넥스트는 getServerSideProps에서 반환된 데이터를 사용하여 각 요청에서 이 페이지를 미리 렌더링합니다. 📄️ getStaticPaths 페이지에 동적 경로가 있고 getStaticProps를 사용하는 경우 정적으로 생성할 경로 목록을 정의해야 합니다. 📄️ getStaticProps 페이지에서 getStaticProps(정적 사이트 생성)이라는 함수를 내보내면, 넥스트는 getStaticProps에서 반환된 props를 사용하여 빌드 타임에 이 페이지를 미리 렌더링합니다. 📄️ 증분형 정적 재생성 넥스트를 사용하면 사이트를 구축한 후 정적 페이지를 만들거나 갱신할 수 있습니다. ISR(Incremental Static Regeneration)을 사용하면 전체 사이트를 다시 빌드할 필요 없이 페이지별로 정적 생성을 사용할 수 있습니다. ISR을 사용하면 수많은 페이지로 확장하면서 정적 생성의 이점을 유지할 수 있습니다. 📄️ 클라이언트 측 클라이언트 측 데이터 가져오기는 페이지에 SEO 인덱싱이 필요하지 않거나, 데이터를 미리 렌더링할 필요가 없거나, 페이지 콘텐츠를 자주 갱신해야 할 때 유용합니다. 서버 측 렌더링 API와 달리 컴포넌트 수준에서 클라이언트 측 데이터 가져오기를 사용할 수 있습니다.","keywords":""},{"title":"클라이언트 측 데이터 가져오기","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/클라이언트-측","content":"","keywords":""},{"title":"증분형 정적 재생성","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/증분형-정적-재생성","content":"","keywords":""},{"title":"주문형 재검증​","type":1,"pageTitle":"증분형 정적 재생성","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/증분형-정적-재생성#주문형-재검증","content":"revalidate 시간을 60으로 설정하면 모든 방문자는 1분 동안 동일한 버전의 사이트를 보게 됩니다. 캐시를 무효화하는 유일한 방법은 1분이 지난 후에 누군가가 해당 페이지를 방문하는 것입니다. v12.2.0부터 넥스트는 주문형 ISR을 지원하여 특정 페이지에 대한 넥스트 캐시를 수동으로 제거할 수 있습니다. 이렇게 하면 다음의 경우에 사이트를 더 쉽게 갱신할 수 있습니다. 헤드리스 CMS의 콘텐츠가 생성되거나 갱신됨전자상거래 메타데이터가 변경됨 (가격, 설명, 카테고리, 리뷰 등) getStaticProps 내부에서는, 주문형 재검증을 사용하기 위해 revalidate를 명시할 필요는 없습니다. revalidate를 생략하면 넥스트는 기본값인 false(재검증 없음)를 사용하고 revalidate()가 호출될 때만 요청형으로 페이지를 재검증합니다. 참고 주문형 ISR 요청에 대해서는 미들웨어가 실행되지 않습니다. 대신 재검증을 원하는 특정 경로에 대해 revalidate()을 호출합니다. 예를 들어 pages/blog/[slug].js가 있고 /post-1을 /blog/post-1로 재작성했다면 res.revalidate('/blog/post-1')을 호출해야 합니다. "},{"title":"주문형 재검증 사용하기​","type":1,"pageTitle":"증분형 정적 재생성","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/증분형-정적-재생성#주문형-재검증-사용하기","content":"먼저 넥스트 앱에서만 알려진 암호 토큰을 만듭니다. 이 암호는 재검증 API 경로에 대한 무단 액세스를 방지하는 데 사용됩니다. 다음과 같은 URL 구조를 사용하여(수동으로 또는 웹훅을 사용하여) 경로에 접근할 수 있습니다. https://&lt;your-site.com&gt;/api/revalidate?secret=&lt;token&gt; 복사 https://&lt;your-site.com&gt;/api/revalidate?secret=&lt;token&gt; 복사 그런 다음 암호를 앱에 환경 변수로 추가합니다. 마지막으로 다음과 같이 재검증 API 경로를 생성합니다. pages/api/revalidate.js jsx export default async function handler(req, res) { // 암호를 확인해서 요청이 유효한지 확인합니다. if (req.query.secret !== process.env.MY_SECRET_TOKEN) { return res.status(401).json({ message: 'Invalid token' }); } try { // 재작성된 경로가 아닌 실제 경로여야 합니다. // 예를 들어 '/blog/[slug]'는 '/blog/post-1'여야 합니다. await res.revalidate('/path-to-revalidate'); return res.json({ revalidated: true }); } catch (err) { // 오류가 있으면 넥스트는 마지막으로 생성된 페이지를 계속 표시합니다. return res.status(500).send('Error revalidating'); } } 복사 pages/api/revalidate.js jsx export default async function handler(req, res) { // 암호를 확인해서 요청이 유효한지 확인합니다. if (req.query.secret !== process.env.MY_SECRET_TOKEN) { return res.status(401).json({ message: 'Invalid token' }); } try { // 재작성된 경로가 아닌 실제 경로여야 합니다. // 예를 들어 '/blog/[slug]'는 '/blog/post-1'여야 합니다. await res.revalidate('/path-to-revalidate'); return res.json({ revalidated: true }); } catch (err) { // 오류가 있으면 넥스트는 마지막으로 생성된 페이지를 계속 표시합니다. return res.status(500).send('Error revalidating'); } } 복사 참고로 주문형 재검증을 아직 생성되지 않은 경로에 실행하면 404 오류가 발생합니다. "},{"title":"개발 중에 주문형 ISR 테스트하기​","type":1,"pageTitle":"증분형 정적 재생성","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/증분형-정적-재생성#개발-중에-주문형-isr-테스트하기","content":"next dev를 사용하여 로컬에서 실행할 때, getStaticProps는 모든 요청마다 호출됩니다. 주문형 ISR 설정이 올바른지 확인하려면 프로덕션 빌드를 만들고 프로덕션 서버를 시작해야 합니다. bash $ next build $ next start 복사 bash $ next build $ next start 복사 그런 다음 정적 페이지가 성공적으로 재검증되었음을 확인할 수 있습니다. "},{"title":"오류 처리와 재검증​","type":1,"pageTitle":"증분형 정적 재생성","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/증분형-정적-재생성#오류-처리와-재검증","content":"백그라운드 재생성을 처리할 때 getStaticProps 내부에 오류가 있거나 수동으로 오류가 발생하면, 가장 최근에 성공적으로 생성된 페이지가 계속 표시됩니다. 다음 후속 요청에서 넥스트는 getStaticProps 호출을 재시도합니다. jsx export async function getStaticProps() { // 이 요청이 오류를 던지면 넥스트는 현재 표시된 페이지를 // 무효화하고 다음 요청에서 getStaticProps을 재시도합니다. const res = await fetch('https://.../posts'); const posts = await res.json(); if (!res.ok) { // 서버 오류가 있으면 반환 대신 오류를 발생시켜 // 다음 요청이 성공할 때까지 캐시가 갱신되지 않게 합니다. throw new Error(`Failed to fetch posts, received status ${res.status}`); } // 요청이 성공하면 posts를 반환하고 10초마다 재검증을 합니다. return { props: { posts, }, revalidate: 10, }; } 복사 jsx export async function getStaticProps() { // 이 요청이 오류를 던지면 넥스트는 현재 표시된 페이지를 // 무효화하고 다음 요청에서 getStaticProps을 재시도합니다. const res = await fetch('https://.../posts'); const posts = await res.json(); if (!res.ok) { // 서버 오류가 있으면 반환 대신 오류를 발생시켜 // 다음 요청이 성공할 때까지 캐시가 갱신되지 않게 합니다. throw new Error(`Failed to fetch posts, received status ${res.status}`); } // 요청이 성공하면 posts를 반환하고 10초마다 재검증을 합니다. return { props: { posts, }, revalidate: 10, }; } 복사 "},{"title":"useEffect로 클라이언트 측 데이터 가져오기​","type":1,"pageTitle":"클라이언트 측 데이터 가져오기","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/클라이언트-측#useeffect로-클라이언트-측-데이터-가져오기","content":"다음 예시는 useEffect 훅을 사용하여 클라이언트 측에서 데이터를 가져오는 방법을 보여줍니다. jsx function Profile() { const [data, setData] = useState(null); const [isLoading, setLoading] = useState(false); useEffect(() =&gt; { setLoading(true); fetch('/api/profile-data') .then((res) =&gt; res.json()) .then((data) =&gt; { setData(data); setLoading(false); }); }, []); if (isLoading) return &lt;p&gt;Loading...&lt;/p&gt;; if (!data) return &lt;p&gt;No profile data&lt;/p&gt;; return ( &lt;div&gt; &lt;h1&gt;{data.name}&lt;/h1&gt; &lt;p&gt;{data.bio}&lt;/p&gt; &lt;/div&gt; ); } 복사 jsx function Profile() { const [data, setData] = useState(null); const [isLoading, setLoading] = useState(false); useEffect(() =&gt; { setLoading(true); fetch('/api/profile-data') .then((res) =&gt; res.json()) .then((data) =&gt; { setData(data); setLoading(false); }); }, []); if (isLoading) return &lt;p&gt;Loading...&lt;/p&gt;; if (!data) return &lt;p&gt;No profile data&lt;/p&gt;; return ( &lt;div&gt; &lt;h1&gt;{data.name}&lt;/h1&gt; &lt;p&gt;{data.bio}&lt;/p&gt; &lt;/div&gt; ); } 복사 "},{"title":"SWR로 클라이언트 측 데이터 가져오기​","type":1,"pageTitle":"클라이언트 측 데이터 가져오기","url":"/docs-repository/docs/next-js/문서/기본-기능/데이터-가져오기/클라이언트-측#swr로-클라이언트-측-데이터-가져오기","content":"넥스트 뒤에 있는 팀은 SWR이라는 데이터 가져오기를 위한 리액트 훅 라이브러리를 만들었습니다. 클라이언트 측에서 데이터를 가져오는 경우에 적극 권장합니다. 캐싱, 재검증, 포커스 추적, 주기적으로 다시 가져오기 등을 처리합니다. 위와 예시에 SWR을 적용해 보겠습니다. SWR은 자동으로 데이터를 캐시하고 데이터가 오래되면 유효성을 다시 검사합니다. SWR 사용에 대한 자세한 내용은 SWR 문서를 확인하세요. jsx import useSWR from 'swr'; const fetcher = (...args) =&gt; fetch(...args).then((res) =&gt; res.json()); function Profile() { const { data, error } = useSWR('/api/profile-data', fetcher); if (error) return &lt;div&gt;Failed to load&lt;/div&gt;; if (!data) return &lt;div&gt;Loading...&lt;/div&gt;; return ( &lt;div&gt; &lt;h1&gt;{data.name}&lt;/h1&gt; &lt;p&gt;{data.bio}&lt;/p&gt; &lt;/div&gt; ); } 복사 jsx import useSWR from 'swr'; const fetcher = (...args) =&gt; fetch(...args).then((res) =&gt; res.json()); function Profile() { const { data, error } = useSWR('/api/profile-data', fetcher); if (error) return &lt;div&gt;Failed to load&lt;/div&gt;; if (!data) return &lt;div&gt;Loading...&lt;/div&gt;; return ( &lt;div&gt; &lt;h1&gt;{data.name}&lt;/h1&gt; &lt;p&gt;{data.bio}&lt;/p&gt; &lt;/div&gt; ); } 복사 "},{"title":"이미지 컴포넌트와 이미지 최적화","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/기본-기능/이미지-최적화","content":"","keywords":""},{"title":"이미지 컴포넌트 사용하기​","type":1,"pageTitle":"이미지 컴포넌트와 이미지 최적화","url":"/docs-repository/docs/next-js/문서/기본-기능/이미지-최적화#이미지-컴포넌트-사용하기","content":"앱에 이미지를 추가하려면 next/image 컴포넌트를 가져옵니다. jsx import Image from 'next/image'; 복사 jsx import Image from 'next/image'; 복사 또는 기본 &lt;img&gt; 요소와 더 비슷한 컴포넌트가 필요한 경우 next/future/image를 가져올 수 있습니다. jsx import Image from 'next/future/image'; 복사 jsx import Image from 'next/future/image'; 복사 이제 이미지(로컬 또는 원격)의 src을 지정할 수 있습니다. "},{"title":"로컬 이미지​","type":1,"pageTitle":"이미지 컴포넌트와 이미지 최적화","url":"/docs-repository/docs/next-js/문서/기본-기능/이미지-최적화#로컬-이미지","content":"로컬 이미지를 사용하려면 .jpg, .png, .webp 파일을 import합니다. jsx import profilePic from '../public/me.png'; 복사 jsx import profilePic from '../public/me.png'; 복사 동적 await import()나 require()는 지원되지 않습니다. import는 빌드 타임에 분석이 가능하도록 정적이어야 합니다. 넥스트는 가져온 파일을 기반으로 이미지의 width와 height를 자동으로 결정합니다. 이 값은 이미지가 로드되는 동안 누적 레이아웃 이동을 방지하는 데 사용됩니다. jsx import Image from 'next/image'; import profilePic from '../public/me.png'; function Home() { return ( &lt;&gt; &lt;h1&gt;My Homepage&lt;/h1&gt; &lt;Image src={profilePic} alt=&quot;Picture of the author&quot; // width={500}가 자동으로 제공됨 // height={500}가 자동으로 제공됨 // blurDataURL=&quot;data:...&quot;가 자동으로 제공됨 // placeholder=&quot;blur&quot; // 로딩중에 선택적인 흐릿함 /&gt; &lt;p&gt;Welcome to my homepage!&lt;/p&gt; &lt;/&gt; ); } 복사 jsx import Image from 'next/image'; import profilePic from '../public/me.png'; function Home() { return ( &lt;&gt; &lt;h1&gt;My Homepage&lt;/h1&gt; &lt;Image src={profilePic} alt=&quot;Picture of the author&quot; // width={500}가 자동으로 제공됨 // height={500}가 자동으로 제공됨 // blurDataURL=&quot;data:...&quot;가 자동으로 제공됨 // placeholder=&quot;blur&quot; // 로딩중에 선택적인 흐릿함 /&gt; &lt;p&gt;Welcome to my homepage!&lt;/p&gt; &lt;/&gt; ); } 복사 "},{"title":"원격 이미지​","type":1,"pageTitle":"이미지 컴포넌트와 이미지 최적화","url":"/docs-repository/docs/next-js/문서/기본-기능/이미지-최적화#원격-이미지","content":"원격 이미지를 사용하려면 src 프로퍼티가 상대 경로 또는 절대 경로 URL 문자열이어야 합니다. 넥스트는 빌드 과정 중에 원격 파일에 접근할 수 없으므로 width와 height, 그리고 선택적 blurDataURL 프롭을 수동으로 제공해야 합니다. jsx import Image from 'next/image'; export default function Home() { return ( &lt;&gt; &lt;h1&gt;My Homepage&lt;/h1&gt; &lt;Image src=&quot;/me.png&quot; alt=&quot;Picture of the author&quot; width={500} height={500} /&gt; &lt;p&gt;Welcome to my homepage!&lt;/p&gt; &lt;/&gt; ); } 복사 jsx import Image from 'next/image'; export default function Home() { return ( &lt;&gt; &lt;h1&gt;My Homepage&lt;/h1&gt; &lt;Image src=&quot;/me.png&quot; alt=&quot;Picture of the author&quot; width={500} height={500} /&gt; &lt;p&gt;Welcome to my homepage!&lt;/p&gt; &lt;/&gt; ); } 복사 "},{"title":"도메인​","type":1,"pageTitle":"이미지 컴포넌트와 이미지 최적화","url":"/docs-repository/docs/next-js/문서/기본-기능/이미지-최적화#도메인","content":"때로는 원격 이미지에 접근하면서 내장 넥스트 이미지 최적화 API를 계속 사용하고 싶을 수 있습니다. 이렇게 하려면 loader의 기본 설정을 그대로 두고 이미지의 src에 절대 경로 URL을 입력합니다. 악의적인 사용자로부터 앱을 보호하려면 원격 액세스를 허용할 원격 호스트 이름 목록을 정의해야 합니다. 참고 domains 설정을 확인하세요. "},{"title":"로더​","type":1,"pageTitle":"이미지 컴포넌트와 이미지 최적화","url":"/docs-repository/docs/next-js/문서/기본-기능/이미지-최적화#로더","content":"앞의 예시에서 원격 이미지의 부분적인 URL(&quot;/me.png&quot;)이 제공된 것을 주목할 필요가 있습니다. 이는 next/image 로더 아키텍처 덕분에 가능합니다. 로더는 이미지의 URL을 생성하는 기능입니다. 제공된 src에 루트 도메인을 추가하고 다양한 크기의 이미지를 요청할 복수의 URL을 생성합니다. 이 복수의 URL은 자동 srcset 생성에 사용되므로 각자의 뷰포트에 적합한 크기의 이미지가 사이트 방문자에게 제공됩니다. 넥스트 앱의 기본 로더는 내장된 이미지 최적화 API를 사용합니다. 이 API는 웹의 어느 곳에서나 이미지를 최적화한 다음 넥스트 웹 서버에서 직접 이미지를 제공합니다. CDN 또는 이미지 서버에서 직접 이미지를 제공하려는 경우 내장 로더 중 하나를 사용 하거나 자바스크립트 몇 줄로 직접 작성할 수 있습니다. 로더는 이미지별로 또는 앱 수준에서 정의할 수 있습니다. "},{"title":"우선 사항​","type":1,"pageTitle":"이미지 컴포넌트와 이미지 최적화","url":"/docs-repository/docs/next-js/문서/기본-기능/이미지-최적화#우선-사항","content":"각 페이지의 LCP(Large Contentful Paint) 요소가 될 이미지에 priority(우선 사항) 속성을 추가해야 합니다. 이렇게 하면 넥스트가 로드할 이미지의 우선 순위를 특별히 지정할 수 있으므로(사전 로드 태그나 우선 사항 힌트를 통해) LCP에서 의미 있는 향상으로 이어집니다. LCP 요소는 일반적으로 페이지의 뷰포트 내에서 볼 수 있는 가장 큰 이미지나 텍스트 블록입니다. next dev를 실행할 때 LCP 요소가 priority 프로퍼티가 없는 &lt;Image&gt;인 경우 콘솔에 경고가 표시됩니다. LCP 이미지를 식별한 뒤에 다음과 같이 프로퍼티를 추가할 수 있습니다. jsx import Image from 'next/image'; export default function Home() { return ( &lt;&gt; &lt;h1&gt;My Homepage&lt;/h1&gt; &lt;Image src=&quot;/me.png&quot; alt=&quot;Picture of the author&quot; width={500} height={500} priority /&gt; &lt;p&gt;Welcome to my homepage!&lt;/p&gt; &lt;/&gt; ); } 복사 jsx import Image from 'next/image'; export default function Home() { return ( &lt;&gt; &lt;h1&gt;My Homepage&lt;/h1&gt; &lt;Image src=&quot;/me.png&quot; alt=&quot;Picture of the author&quot; width={500} height={500} priority /&gt; &lt;p&gt;Welcome to my homepage!&lt;/p&gt; &lt;/&gt; ); } 복사 next/image 컴포넌트 문서에서 우선 사항의 자세한 내용을 볼 수 있습니다. "},{"title":"이미지 크기 조정하기​","type":1,"pageTitle":"이미지 컴포넌트와 이미지 최적화","url":"/docs-repository/docs/next-js/문서/기본-기능/이미지-최적화#이미지-크기-조정하기","content":"이미지가 성능을 저하시키는 가장 일반적인 방법 중 하나는 이미지가 로드될 때 페이지의 다른 요소를 밀어내는 레이아웃 변화입니다. 이 성능 문제는 사용자에게 매우 성가신 것이여서 누적 레이아웃 이동이라는 코어 웹 바이탈이 있을 정도입니다. 이미지 기반 레이아웃 이동을 피하는 방법은 항상 이미지의 크기를 조정하는 것입니다. 이를 통해 브라우저는 이미지가 로드되기 전에 이미지를 위한 공간을 정확하게 예약할 수 있습니다. next/image는 좋은 성능 결과를 보장하도록 설계되었습니다. 따라서 레이아웃 이동을 유발하는 방식으로 사용할 수 없으며 다음 세 가지 방법 중 하나로 크기를 조정해야 합니다. 정적 가져오기를 사용하여 자동으로 조정width와 height 프로퍼티를 포함하여 명시적으로 조정layout=&quot;fill&quot;을 사용하여 암시적으로 조정. 이미지가 부모 요소를 채우도록 확장됨 참고 이미지의 크기를 모르는 경우에는 어떻게 해야 하나요? 이미지 크기를 모르는 상태로 소스에서 이미지에 접근하는 경우에 수행할 수 있는 몇 가지 작업이 있습니다. layout='fill' 사용하기 fill 레이아웃 모드를 사용하면 상위 요소에 따라 이미지 크기를 조정할 수 있습니다. CSS를 사용하여 페이지에서 이미지의 상위 요소 공간을 만든 다음, fill, contain, cover가 있는 objectFit 프로퍼티와 objectPosition 프로퍼티를 사용해 이미지가 해당 공간을 차지하는 방식을 정의합니다. 이미지 정규화하기 제어하는 소스에서 이미지를 제공하는 경우에는 이미지 파이프라인을 수정하여 이미지를 특정 크기로 정규화하는 것이 좋습니다. API 호출 수정하기 앱이 API 호출(예: CMS)을 사용하여 이미지 URL을 검색하는 경우에는 URL과 함께 이미지 크기를 반환하도록 API 호출을 수정할 수 있습니다. 제안된 방법 중 어느 것으로도 이미지 크기 조정을 할 수 없는 경우, next/image 컴포넌트는 표준 &lt;img&gt; 요소와 함께 페이지에서 잘 작동하도록 설계되었습니다. "},{"title":"스타일링​","type":1,"pageTitle":"이미지 컴포넌트와 이미지 최적화","url":"/docs-repository/docs/next-js/문서/기본-기능/이미지-최적화#스타일링","content":"참고 아래 나열된 스타일링 문제의 대부분은 next/future/image을 사용하여 해결할 수 있습니다. 이미지 컴포넌트의 스타일링은 일반 &lt;img&gt; 요소의 스타일링과 크게 다르지 않지만 명심해야 할 몇 가지 지침이 있습니다. 올바른 레이아웃 모드 선택하기 이미지 컴포넌트에는 페이지에서 크기가 조정되는 방식을 정의하는 여러 가지 레이아웃 모드가 있다. 이미지 스타일이 원하는 대로 되지 않으면 다른 레이아웃 모드를 실험해 보는 것이 좋습니다. DOM 구조가 아닌 className으로 지정하기 대부분의 레이아웃 모드에서 이미지 컴포넌트는 정확히 하나의 &lt;span&gt;로 래핑된 하나의 &lt;img&gt; 태그로 이루어진 DOM 구조를 갖습니다. 일부 모드에는 간격을 위한 &lt;span&gt; 형제가 있을 수 있습니다 . 이러한 추가 &lt;span&gt; 요소는 컴포넌트가 레이아웃 이동을 방지하는 데 중요한 역할을 합니다. &lt;img&gt;의 내부 스타일을 지정할 때 권장되는 방법은 이미지 컴포넌트의 className prop을 가져온 CSS 모듈의 값으로 설정하는 것입니다. className 값은 밑에 있는 &lt;img&gt; 요소에 자동으로 적용됩니다. 또는 전역 스타일시트를 가져와서, className props을 전역 스타일시트에서 사용된 이름으로 설정할 수 있습니다. styled-jsx는 현재 컴포넌트로 스코프가 제한되므로 사용할 수 없습니다. layout='fill'을 사용할 때 상위 요소에는 position: relative가 있어야 합니다. 이는 해당 레이아웃 모드에서 이미지 요소를 적절하게 렌더링하는 데 필요합니다. layout='responsive'를 사용할 때 상위 요소에는 display: block가 있어야 합니다. 이는 &lt;div&gt; 요소의 기본값이지만 다른 요소의 경우에는 지정해야 할 수 있습니다. "},{"title":"설정​","type":1,"pageTitle":"이미지 컴포넌트와 이미지 최적화","url":"/docs-repository/docs/next-js/문서/기본-기능/이미지-최적화#설정","content":"next/image 컴포넌트와 넥스트 이미지 최적화 API는 next.config.js 파일에서 설정할 수 있습니다. 이러한 설정을 통해 원격 이미지 활성화, 사용자 정의 이미지 중단점 정의, 캐싱 작동 변경 등의 작업을 수행할 수 있습니다. 자세한 내용은 이미지 설정 문서를 확인하세요. "},{"title":"레이아웃","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/기본-기능/레이아웃","content":"","keywords":""},{"title":"예시​","type":1,"pageTitle":"레이아웃","url":"/docs-repository/docs/next-js/문서/기본-기능/레이아웃#예시","content":""},{"title":"사용자 정의 앱에서의 단일 공유 레이아웃​","type":1,"pageTitle":"레이아웃","url":"/docs-repository/docs/next-js/문서/기본-기능/레이아웃#사용자-정의-앱에서의-단일-공유-레이아웃","content":"전체 앱에 하나의 레이아웃만 있는 경우 사용자 정의 앱을 만들고 앱을 레이아웃으로 래핑할 수 있습니다. &lt;Layout /&gt; 컴포넌트는 페이지를 변경할 때 재사용되기 때문에 입력 값과 같은 컴포넌트의 상태가 유지됩니다. pages/_app.js jsx import Layout from '../components/layout'; export default function MyApp({ Component, pageProps }) { return ( &lt;Layout&gt; &lt;Component {...pageProps} /&gt; &lt;/Layout&gt; ); } 복사 pages/_app.js jsx import Layout from '../components/layout'; export default function MyApp({ Component, pageProps }) { return ( &lt;Layout&gt; &lt;Component {...pageProps} /&gt; &lt;/Layout&gt; ); } 복사 "},{"title":"페이지별 레이아웃​","type":1,"pageTitle":"레이아웃","url":"/docs-repository/docs/next-js/문서/기본-기능/레이아웃#페이지별-레이아웃","content":"복수의 레이아웃이 필요한 경우, 페이지에 getLayout 프로퍼티를 추가하여 레이아웃에 대한 리액트 컴포넌트를 반환할 수 있습니다. 이를 통해 페이지별로 레이아웃을 정의할 수 있습니다. 함수를 반환하기 때문에 원하는 경우 복잡한 중첩 레이아웃을 가질 수 있습니다. pages/index.js jsx import Layout from '../components/layout'; import NestedLayout from '../components/nested-layout'; export default function Page() { return { /** 콘텐츠 */ }; } Page.getLayout = function getLayout(page) { return ( &lt;Layout&gt; &lt;NestedLayout&gt;{page}&lt;/NestedLayout&gt; &lt;/Layout&gt; ); }; 복사 pages/index.js jsx import Layout from '../components/layout'; import NestedLayout from '../components/nested-layout'; export default function Page() { return { /** 콘텐츠 */ }; } Page.getLayout = function getLayout(page) { return ( &lt;Layout&gt; &lt;NestedLayout&gt;{page}&lt;/NestedLayout&gt; &lt;/Layout&gt; ); }; 복사 pages/_app.js jsx export default function MyApp({ Component, pageProps }) { // 페이지 수준의 레이아웃이 존재한다면 사용합니다. const getLayout = Component.getLayout || ((page) =&gt; page); return getLayout(&lt;Component {...pageProps} /&gt;); } 복사 pages/_app.js jsx export default function MyApp({ Component, pageProps }) { // 페이지 수준의 레이아웃이 존재한다면 사용합니다. const getLayout = Component.getLayout || ((page) =&gt; page); return getLayout(&lt;Component {...pageProps} /&gt;); } 복사 페이지 사이를 탐색할 때 단일 페이지 앱(SPA) 경험에 대한 페이지 상태(입력 값, 스크롤 위치 등)를 유지하려고 합니다. 이 레이아웃 패턴은 페이지 전환 사이에 리액트 컴포넌트 트리가 유지되기 때문에 상태가 지속되게 합니다. 컴포넌트 트리를 사용하여 리액트는 상태를 유지하기 위해 변경된 요소를 알 수 있습니다. 참고 이 프로세스를 재조정이라고 부르며, 이는 리액트가 변경된 요소를 이해하는 방법입니다. "},{"title":"타입스크립트 사용하기​","type":1,"pageTitle":"레이아웃","url":"/docs-repository/docs/next-js/문서/기본-기능/레이아웃#타입스크립트-사용하기","content":"타입스크립트를 사용할 때는 먼저 getLayout 함수가 포함된 페이지에 대한 새 타입을 만들어야 합니다. 그런 다음 이전에 만든 타입을 사용하도록 Component 프로퍼티를 재정의하는 새 AppProps 타입을 생성해야 합니다. pages/index.tsx tsx import type { ReactElement } from 'react'; import Layout from '../components/layout'; import NestedLayout from '../components/nested-layout'; import type { NextPageWithLayout } from './_app'; const Page: NextPageWithLayout = () =&gt; { return &lt;p&gt;hello world&lt;/p&gt;; }; Page.getLayout = function getLayout(page: ReactElement) { return ( &lt;Layout&gt; &lt;NestedLayout&gt;{page}&lt;/NestedLayout&gt; &lt;/Layout&gt; ); }; export default Page; 복사 pages/index.tsx tsx import type { ReactElement } from 'react'; import Layout from '../components/layout'; import NestedLayout from '../components/nested-layout'; import type { NextPageWithLayout } from './_app'; const Page: NextPageWithLayout = () =&gt; { return &lt;p&gt;hello world&lt;/p&gt;; }; Page.getLayout = function getLayout(page: ReactElement) { return ( &lt;Layout&gt; &lt;NestedLayout&gt;{page}&lt;/NestedLayout&gt; &lt;/Layout&gt; ); }; export default Page; 복사 pages/_app.tsx tsx import type { ReactElement, ReactNode } from 'react'; import type { NextPage } from 'next'; import type { AppProps } from 'next/app'; export type NextPageWithLayout = NextPage &amp; { getLayout?: (page: ReactElement) =&gt; ReactNode; }; type AppPropsWithLayout = AppProps &amp; { Component: NextPageWithLayout; }; export default function MyApp({ Component, pageProps }: AppPropsWithLayout) { // 페이지 수준의 레이아웃이 존재한다면 사용합니다. const getLayout = Component.getLayout ?? ((page) =&gt; page); return getLayout(&lt;Component {...pageProps} /&gt;); } 복사 pages/_app.tsx tsx import type { ReactElement, ReactNode } from 'react'; import type { NextPage } from 'next'; import type { AppProps } from 'next/app'; export type NextPageWithLayout = NextPage &amp; { getLayout?: (page: ReactElement) =&gt; ReactNode; }; type AppPropsWithLayout = AppProps &amp; { Component: NextPageWithLayout; }; export default function MyApp({ Component, pageProps }: AppPropsWithLayout) { // 페이지 수준의 레이아웃이 존재한다면 사용합니다. const getLayout = Component.getLayout ?? ((page) =&gt; page); return getLayout(&lt;Component {...pageProps} /&gt;); } 복사 "},{"title":"데이터 가져오기​","type":1,"pageTitle":"레이아웃","url":"/docs-repository/docs/next-js/문서/기본-기능/레이아웃#데이터-가져오기","content":"레이아웃 내부에서는 useEffect나 SWR과 같은 라이브러리를 사용하여 클라이언트 측에서 데이터를 가져올 수 있습니다. 이 파일은 페이지가 아니므로 현재는 getStaticProps나 getServerSideProps를 사용할 수 없습니다. components/layout.js jsx import useSWR from 'swr'; import Navbar from './navbar'; import Footer from './footer'; export default function Layout({ children }) { const { data, error } = useSWR('/api/navigation', fetcher); if (error) return &lt;div&gt;Failed to load&lt;/div&gt;; if (!data) return &lt;div&gt;Loading...&lt;/div&gt;; return ( &lt;&gt; &lt;Navbar links={data.links} /&gt; &lt;main&gt;{children}&lt;/main&gt; &lt;Footer /&gt; &lt;/&gt; ); } 복사 components/layout.js jsx import useSWR from 'swr'; import Navbar from './navbar'; import Footer from './footer'; export default function Layout({ children }) { const { data, error } = useSWR('/api/navigation', fetcher); if (error) return &lt;div&gt;Failed to load&lt;/div&gt;; if (!data) return &lt;div&gt;Loading...&lt;/div&gt;; return ( &lt;&gt; &lt;Navbar links={data.links} /&gt; &lt;main&gt;{children}&lt;/main&gt; &lt;Footer /&gt; &lt;/&gt; ); } 복사 "},{"title":"정적 파일 제공하기","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/기본-기능/정적-파일-제공하기","content":"정적 파일 제공하기 넥스트는 루트 디렉터리의 public 폴더에서 이미지와 같은 정적 파일을 제공할 수 있습니다. 기본 URL(/)에서 시작하는 코드에서 public 내부의 파일을 참조할 수 있습니다. 예를 들어 public/me.png에 이미지를 추가하면 다음 코드가 이미지에 접근할 수 있습니다. jsx import Image from 'next/image'; function Avatar() { return &lt;Image src=&quot;/me.png&quot; alt=&quot;me&quot; width=&quot;64&quot; height=&quot;64&quot; /&gt;; } export default Avatar; 복사 jsx import Image from 'next/image'; function Avatar() { return &lt;Image src=&quot;/me.png&quot; alt=&quot;me&quot; width=&quot;64&quot; height=&quot;64&quot; /&gt;; } export default Avatar; 복사 참고 next/image는 넥스트 10 이상이 필요합니다. 이 폴더에는 robots.txt, favicon.ico, 구글 사이트 확인, 기타 정적 파일(.html 포함)을 넣을 수 있습니다. 참고 public 디렉터리 이름을 다른 이름으로 지정해서는 안 됩니다. 이름은 변경할 수 없으며 정적 자산을 제공하는 데 사용되는 유일한 디렉터리입니다. 참고 pages/ 디렉터리의 파일과 동일한 이름을 갖는 정적 파일이 있으면 오류가 발생합니다. 참고 빌드 타임에 public 디렉터리에 있는 자산만 넥스트에서 제공됩니다. 런타임에 추가된 파일은 사용할 수 없습니다. 영구 파일 저장소는 AWS S3와 같은 타사 서비스를 이용하는 것을 추천합니다.","keywords":""},{"title":"환경 변수","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/기본-기능/환경-변수","content":"","keywords":""},{"title":"환경 변수 로드하기​","type":1,"pageTitle":"환경 변수","url":"/docs-repository/docs/next-js/문서/기본-기능/환경-변수#환경-변수-로드하기","content":"넥스트는 환경 변수를 .env.local에서 process.env로 로드하는 내장 기능을 갖추고 있습니다. 다음은 .env.local 예시입니다. bash DB_HOST=localhost DB_USER=myuser DB_PASS=mypassword 복사 bash DB_HOST=localhost DB_USER=myuser DB_PASS=mypassword 복사 이제 process.env.DB_HOST, process.env.DB_USER, process.env.DB_PASS가 노드 환경에 자동으로 로드되서 넥스트 데이터 가져오기 메서드와 API 경로에서 사용할 수 있게 됩니다. 예를 들어 getStaticProps에서 다음과 같이 사용할 수 있습니다. pages/index.js js export async function getStaticProps() { const db = await myDB.connect({ host: process.env.DB_HOST, username: process.env.DB_USER, password: process.env.DB_PASS, }); // ... } 복사 pages/index.js js export async function getStaticProps() { const db = await myDB.connect({ host: process.env.DB_HOST, username: process.env.DB_USER, password: process.env.DB_PASS, }); // ... } 복사 참고 서버 전용 비밀을 안전하게 보호하기 위해 환경 변수는 빌드 타임에 평가되므로 실제로 사용된 환경 변수만 포함됩니다. process.env는 표준 자바스크립트 객체가 아니므로 객체 분해를 사용할 수 없습니다. 환경 변수는 const { PUBLISHABLE_KEY } = process.env가 아닌 process.env.PUBLISHABLE_KEY로 참조해야 합니다. 참고 넥스트는 .env* 파일 내부의 변수($VAR)를 자동으로 확장합니다. 이렇게 하면 다음과 같이 다른 비밀을 참조할 수 있게 됩니다. bash # .env HOSTNAME=localhost PORT=8080 HOST=http://$HOSTNAME:$PORT 복사 bash # .env HOSTNAME=localhost PORT=8080 HOST=http://$HOSTNAME:$PORT 복사 변수 값에서 $를 사용하고 싶다면 \\$와 같이 이스케이프해야 합니다. 예시: bash # .env A=abc # preabc가 됩니다. WRONG=pre$A # pre$A가 됩니다. CORRECT=pre\\$A 복사 bash # .env A=abc # preabc가 됩니다. WRONG=pre$A # pre$A가 됩니다. CORRECT=pre\\$A 복사 참고 /src 폴더를 사용하는 경우, 넥스트는 /src 폴더가 아닌 상위 폴더에서만 .env 파일을 로드한다는 점을 주의해야 합니다. "},{"title":"브라우저에 환경 변수 노출시키기​","type":1,"pageTitle":"환경 변수","url":"/docs-repository/docs/next-js/문서/기본-기능/환경-변수#브라우저에-환경-변수-노출시키기","content":"기본적으로 환경 변수는 노드 환경에서만 사용할 수 있습니다. 즉, 브라우저에 노출되지 않습니다. 브라우저에 변수를 노출하려면 변수에 NEXT_PUBLIC_ 접두사를 붙여야 합니다. 예시: bash NEXT_PUBLIC_ANALYTICS_ID=abcdefghijk 복사 bash NEXT_PUBLIC_ANALYTICS_ID=abcdefghijk 복사 이제 process.env.NEXT_PUBLIC_ANALYTICS_ID는 노드 환경에 자동으로 로드되어 코드의 어디에서나 사용할 수 있게 되었습니다. 값은 NEXT_PUBLIC_ 접두사로 인해 브라우저로 전송되는 자바스크립트에 인라인됩니다 . 이 인라인은 빌드 타임에 발생하므로 프로젝트를 빌드할 때 다양한 NEXT_PUBLIC_ 환경을 설정해야 합니다. pages/index.js jsx import setupAnalyticsService from '../lib/my-analytics-service'; // NEXT_PUBLIC_ANALYTICS_ID에는 NEXT_PUBLIC_ 접두사가 있으므로 여기서 사용이 가능합니다. // 이 코드는 빌드 타임에 setupAnalyticsService('abcdefghijk')로 변환됩니다. setupAnalyticsService(process.env.NEXT_PUBLIC_ANALYTICS_ID); function HomePage() { return &lt;h1&gt;Hello World&lt;/h1&gt;; } export default HomePage; 복사 pages/index.js jsx import setupAnalyticsService from '../lib/my-analytics-service'; // NEXT_PUBLIC_ANALYTICS_ID에는 NEXT_PUBLIC_ 접두사가 있으므로 여기서 사용이 가능합니다. // 이 코드는 빌드 타임에 setupAnalyticsService('abcdefghijk')로 변환됩니다. setupAnalyticsService(process.env.NEXT_PUBLIC_ANALYTICS_ID); function HomePage() { return &lt;h1&gt;Hello World&lt;/h1&gt;; } export default HomePage; 복사 다음과 같은 동적 조회는 인라인되지 않습니다. js // 변수를 사용하므로 인라인되지 않습니다. const varName = 'NEXT_PUBLIC_ANALYTICS_ID'; setupAnalyticsService(process.env[varName]); // 변수를 사용하므로 인라인되지 않습니다. const env = process.env; setupAnalyticsService(env.NEXT_PUBLIC_ANALYTICS_ID); 복사 js // 변수를 사용하므로 인라인되지 않습니다. const varName = 'NEXT_PUBLIC_ANALYTICS_ID'; setupAnalyticsService(process.env[varName]); // 변수를 사용하므로 인라인되지 않습니다. const env = process.env; setupAnalyticsService(env.NEXT_PUBLIC_ANALYTICS_ID); 복사 "},{"title":"기본 환경 변수​","type":1,"pageTitle":"환경 변수","url":"/docs-repository/docs/next-js/문서/기본-기능/환경-변수#기본-환경-변수","content":"일반적으로 .env.local 파일은 하나만 필요합니다. 그러나 때로는 development(next dev)나 production(next start) 환경에 대한 기본값을 추가해야 할 수도 있습니다. 넥스트를 사용하면 .env(모든 환경), .env.development(개발 환경), .env.production(프로덕션 환경)에서 기본값을 설정할 수 있습니다. .env.local은 항상 기본 설정을 재정의합니다. 참고 .env, .env.development, .env.production 파일은 기본값을 정의하므로 저장소에 포함되어야 합니다. .env*.local 파일은 무시되어야 하므로 .gitignore에 추가해야 합니다. .env.local은 비밀을 저장할 수 있는 곳입니다. "},{"title":"베르셀의 환경 변수​","type":1,"pageTitle":"환경 변수","url":"/docs-repository/docs/next-js/문서/기본-기능/환경-변수#베르셀의-환경-변수","content":"넥스트 앱을 베르셀(Vercel)에 배포할 때 환경 변수는 프로젝트 설정에서 설정할 수 있습니다. 모든 유형의 환경 변수가 여기에 설정되어야 합니다. 개발에 사용되는 환경 변수도 나중에 로컬 장치에 다운로드 할 수 있습니다. 개발 환경 변수를 설정한 경우, 다음 명령을 사용하면 해당 환경 변수를 로컬 시스템에서 사용하기 위해 .env.local로 가져올 수 있습니다. bash vercel env pull .env.local 복사 bash vercel env pull .env.local 복사 베르셀 CLI를 사용하여 배포할 때는 업로드해서는 안 되는 파일이 포함된 .vercelignore 파일을 추가해야 합니다. 이는 일반적으로 .gitignore에 포함된 것과 동일합니다. "},{"title":"테스트 환경 변수​","type":1,"pageTitle":"환경 변수","url":"/docs-repository/docs/next-js/문서/기본-기능/환경-변수#테스트-환경-변수","content":"development와 production 환경 외에도 세 번째 옵션을 사용할 수 있습니다. 바로 test 환경입니다. 개발이나 프로덕션 환경에 대한 기본값을 설정하는 것과 동일한 방식으로, testing 환경에 대한 .env.test 파일을 만들 수 있습니다(이 파일은 이전 두 개만큼 일반적이지는 않습니다). 넥스트는 testing 환경에서 .env.development나 .env.production의 환경 변수를 로드하지 않습니다. 이것은 테스트 목적으로만 특정 환경 변수를 설정해야 하는 jest나 cypress 같은 도구로 테스트를 실행할 때 유용합니다. NODE_ENV가 test로 설정되어 있으면 테스트 기본값이 로드되지만, 보통은 테스트 도구에서 이를 처리하므로 별도로 설정하지 않아도 됩니다. test와 development, production 환경 간에는 약간의 차이가 존재합니다. 테스트가 모든 사람에게 동일한 결과를 줘야 하기 때문에 .env.local이 로드되지 않습니다. 이는 모든 테스트 실행이 기본 세트를 재정의하는 .env.local을 무시하여 동일한 환경 기본값을 사용하게 만듭니다. 참고 기본 환경 변수와 유사하게 .env.test 파일은 저장소에 포함되어야 하며 .env.test.local는 포함되지 말아야 합니다. .env*.local가 .gitignore를 통해 무시되어야 하기 때문입니다. 단위 테스트를 실행하는 동안 @next/env 패키지의 loadEnvConfig 함수를 활용하여 넥스트와 동일한 방식으로 환경 변수를 로드할 수 있습니다. jsx // 테스트 설정을 위해 Jest 글로벌 설정 파일이나 이와 유사한 파일에 // 다음과 같은 코드를 작성할 수 있습니다. import { loadEnvConfig } from '@next/env'; export default async () =&gt; { const projectDir = process.cwd(); loadEnvConfig(projectDir); }; 복사 jsx // 테스트 설정을 위해 Jest 글로벌 설정 파일이나 이와 유사한 파일에 // 다음과 같은 코드를 작성할 수 있습니다. import { loadEnvConfig } from '@next/env'; export default async () =&gt; { const projectDir = process.cwd(); loadEnvConfig(projectDir); }; 복사 "},{"title":"환경 변수 로드 순서​","type":1,"pageTitle":"환경 변수","url":"/docs-repository/docs/next-js/문서/기본-기능/환경-변수#환경-변수-로드-순서","content":"환경 변수는 다음 순서대로 조회되며 변수가 발견되면 조회가 중지됩니다. process.env.env.$(NODE_ENV).local.env.local (NODE_ENV가 test일 때는 확인하지 않음).env.$(NODE_ENV).env 예를 들어 NODE_ENV가 development이고 환경 변수를 .env.development.local과 .env 모두에 정의하면 .env.development.local의 값이 사용됩니다. 참고 NODE_ENV에 허용되는 값은 production, development, test입니다. "},{"title":"페이지","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/기본-기능/페이지","content":"","keywords":""},{"title":"동적 경로가 있는 페이지​","type":1,"pageTitle":"페이지","url":"/docs-repository/docs/next-js/문서/기본-기능/페이지#동적-경로가-있는-페이지","content":"넥스트는 동적 경로가 있는 페이지를 지원합니다. 예를 들어 pages/posts/[id].js라는 파일을 생성하면 posts/1, posts/2에서 접근이 가능해집니다. 참고 동적 라우팅에 대해 자세히 알아보려면 동적 라우팅 문서를 확인하세요. "},{"title":"사전 렌더링​","type":1,"pageTitle":"페이지","url":"/docs-repository/docs/next-js/문서/기본-기능/페이지#사전-렌더링","content":"기본적으로 넥스트는 모든 페이지를 미리 렌더링합니다. 넥스트는 클라이언트 측 자바스크립트에서 모든 작업을 수행하는 대신 각 페이지에 대해 미리 HTML을 생성합니다. 사전 렌더링은 더 나은 성능과 SEO를 가집니다. 생성된 각 HTML은 해당 페이지에 필요한 최소한의 자바스크립트 코드와 연결됩니다. 브라우저에서 페이지를 로드하면 해당 자바스크립트 코드가 실행되어 페이지를 완전한 대화형으로 만듭니다. 이 과정을 수화(hydration)라고 부릅니다. "},{"title":"두 가지 방식의 사전 렌더링​","type":1,"pageTitle":"페이지","url":"/docs-repository/docs/next-js/문서/기본-기능/페이지#두-가지-방식의-사전-렌더링","content":"넥스트에는 정적 생성과 SSR이라는 두 가지 방식의 사전 렌더링이 있습니다. 둘의 차이점은 페이지에 대한 HTML을 생성하는 시기입니다. 정적 생성(권장) - 빌드 타임에서 HTML이 생성되며 각 요청에서 재사용됨SSR - 각 요청마다 HTML이 생성됨 넥스트를 사용하면 각 페이지에 사용할 사전 렌더링 방식을 선택할 수 있습니다. 대부분의 페이지에는 정적 생성을 사용하고 일부 페이지에는 SSR을 사용하여 하이브리드 넥스트 앱을 만들 수 있습니다. 성능상의 이유로 SSR보다 정적 생성을 사용하는 것이 좋습니다. 정적으로 생성된 페이지는 성능 향상을 위한 추가 설정 없이 CDN에서 캐시가 가능합니다. 그러나 경우에 따라 SSR이 유일한 옵션일 수 있습니다. CSR을 정적 생성, SSR과 함께 사용하는 것도 가능합니다. 페이지의 일부는 클라이언트 측 자바스크립트로 완전히 렌더링될 수 있습니다. 자세한 내용은 데이터 가져오기 문서를 참조하세요. "},{"title":"정적 생성​","type":1,"pageTitle":"페이지","url":"/docs-repository/docs/next-js/문서/기본-기능/페이지#정적-생성","content":"페이지가 정적 생성을 사용하는 경우에는 페이지의 HTML이 빌드 타임에 생성됩니다. 즉, 프로덕션에서 next build를 실행할 때 페이지 HTML이 생성됩니다. 이 HTML은 각 요청에서 재사용되며 CDN에 의해 캐시될 수 있습니다. 넥스트에서는 데이터가 있거나 없는 페이지를 정적으로 생성할 수 있습니다. 각각의 경우를 살펴보겠습니다. "},{"title":"데이터가 없는 정적 생성​","type":1,"pageTitle":"페이지","url":"/docs-repository/docs/next-js/문서/기본-기능/페이지#데이터가-없는-정적-생성","content":"기본적으로 넥스트는 데이터를 가져오지 않는 정적 생성을 사용하여 페이지를 미리 렌더링합니다. 예시: jsx function About() { return &lt;div&gt;About&lt;/div&gt;; } export default About; 복사 jsx function About() { return &lt;div&gt;About&lt;/div&gt;; } export default About; 복사 이 페이지는 미리 렌더링할 외부 데이터를 가져올 필요가 없습니다. 이와 같은 경우, 넥스트는 빌드 타임에 페이지당 하나의 HTML 파일을 생성합니다. "},{"title":"데이터가 있는 정적 생성​","type":1,"pageTitle":"페이지","url":"/docs-repository/docs/next-js/문서/기본-기능/페이지#데이터가-있는-정적-생성","content":"일부 페이지는 사전 렌더링을 위해 외부 데이터를 가져와야 합니다. 두 가지 시나리오가 있으며 하나만 적용하거나 둘 다 적용할 수 있습니다. 각각의 경우에 넥스트가 제공하는 다음 기능을 사용할 수 있습니다. 페이지 콘텐츠가 외부 데이터에 의존 - getStaticProps을 사용페이지 경로가 외부 데이터에 의존 - getStaticPaths을 사용(보통 getStaticProps에 추가로 사용) 시나리오 1: 페이지 콘텐츠가 외부 데이터에 의존​ 예시로 블로그 페이지는 CMS(콘텐츠 관리 시스템)에서 블로그 게시물 목록을 가져와야 할 수 있습니다. jsx // TODO: 이 페이지를 사전 렌더링하려면 먼저 어떤 API 엔드포인트를 호출해서 // posts을 가져와야 합니다. function Blog({ posts }) { return ( &lt;ul&gt; {posts.map((post) =&gt; ( &lt;li&gt;{post.title}&lt;/li&gt; ))} &lt;/ul&gt; ); } export default Blog; 복사 jsx // TODO: 이 페이지를 사전 렌더링하려면 먼저 어떤 API 엔드포인트를 호출해서 // posts을 가져와야 합니다. function Blog({ posts }) { return ( &lt;ul&gt; {posts.map((post) =&gt; ( &lt;li&gt;{post.title}&lt;/li&gt; ))} &lt;/ul&gt; ); } export default Blog; 복사 사전 렌더링에서 해당 데이터를 가져오기 위해, 넥스트는 동일한 파일에서 getStaticProps라는 async 함수를 export하는 것을 허용합니다. 이 함수는 빌드 타임에 호출되며 가져온 데이터를 사전 렌더링 시 페이지의 props에 전달합니다. jsx function Blog({ posts }) { // posts를 렌더링합니다... } // 이 함수는 빌드 타임에 호출됩니다. export async function getStaticProps() { // posts를 가져오기 위해 외부 API 엔드포인트를 호출합니다. const res = await fetch('https://.../posts'); const posts = await res.json(); // { props: { posts } }를 반환하면 // Blog 컴포넌트는 빌드 타임에 posts를 프롭으로 받습니다. return { props: { posts, }, }; } export default Blog; 복사 jsx function Blog({ posts }) { // posts를 렌더링합니다... } // 이 함수는 빌드 타임에 호출됩니다. export async function getStaticProps() { // posts를 가져오기 위해 외부 API 엔드포인트를 호출합니다. const res = await fetch('https://.../posts'); const posts = await res.json(); // { props: { posts } }를 반환하면 // Blog 컴포넌트는 빌드 타임에 posts를 프롭으로 받습니다. return { props: { posts, }, }; } export default Blog; 복사 getStaticProps의 작동 방식에 대해 자세히 알아보려면 데이터 가져오기 문서를 확인하세요. 시나리오 2: 페이지 경로가 외부 데이터에 의존​ 넥스트를 사용하면 동적 경로를 가진 페이지를 만들 수 있습니다. 예를 들어 id에 기반한 단일 블로그 게시물을 표시하기 위해 pages/posts/[id].js라는 파일을 생성할 수 있습니다. 이렇게 하면 posts/1에 접근할 때 블로그 포스트를 id: 1로 표시할 수 있습니다. 그러나 빌드 타임에 어떤 id를 사전 렌더링할지가 외부 데이터에 의존하는 경우가 있을 수 있습니다. 예시​ 데이터베이스에 하나의 블로그 게시물(id: 1)만 추가했다고 가정해 보겠습니다. 이 경우에는 빌드 타임에 posts/1만 사전 렌더링하기를 원할 것입니다. 나중에 두 번째 게시물을 id: 2로 추가할 수 있습니다. 그러면 posts/2도 사전 렌더링하기를 원할 것입니다. 따라서 사전 렌더링되는 페이지 경로는 외부 데이터에 따라 달라집니다. 넥스트에서는 이를 처리하기 위해, 동적 페이지(pages/posts/[id].js)에서 getStaticPaths라는 async 함수를 export할 수 있습니다. 이 함수는 빌드 타임에 호출되며 사전 렌더링할 경로를 지정할 수 있습니다. jsx // 이 함수는 빌드 타임에 호출됩니다. export async function getStaticPaths() { // posts를 가져오기 위해 외부 API 엔드포인트를 호출합니다. const res = await fetch('https://.../posts'); const posts = await res.json(); // 게시물에 기반해 사전 렌더링하고 싶은 경로를 구합니다. const paths = posts.map((post) =&gt; ({ params: { id: post.id }, })); // 빌드 타임에 이 경로를 사전 렌더링합니다. // { fallback: false }는 paths 이외의 경로가 404가 된다는 것을 의미합니다. return { paths, fallback: false }; } 복사 jsx // 이 함수는 빌드 타임에 호출됩니다. export async function getStaticPaths() { // posts를 가져오기 위해 외부 API 엔드포인트를 호출합니다. const res = await fetch('https://.../posts'); const posts = await res.json(); // 게시물에 기반해 사전 렌더링하고 싶은 경로를 구합니다. const paths = posts.map((post) =&gt; ({ params: { id: post.id }, })); // 빌드 타임에 이 경로를 사전 렌더링합니다. // { fallback: false }는 paths 이외의 경로가 404가 된다는 것을 의미합니다. return { paths, fallback: false }; } 복사 또한 pages/posts/[id].js에서는 해당 id로 포스트의 데이터를 가져와 페이지를 사전 렌더링할 수 있도록 getStaticProps를 내보내야 합니다. jsx function Post({ post }) { // post를 렌더링합니다... } export async function getStaticPaths() { // ... } // 이 함수는 빌드 타임에 호출됩니다. export async function getStaticProps({ params }) { // params에는 포스트의 id가 들어 있습니다. // 경로가 '/posts/1'과 같다면 arams.id는 1입니다. const res = await fetch(`https://.../posts/${params.id}`); const post = await res.json(); // post 데이터를 페이지에 프롭으로 전달합니다. return { props: { post } }; } export default Post; 복사 jsx function Post({ post }) { // post를 렌더링합니다... } export async function getStaticPaths() { // ... } // 이 함수는 빌드 타임에 호출됩니다. export async function getStaticProps({ params }) { // params에는 포스트의 id가 들어 있습니다. // 경로가 '/posts/1'과 같다면 arams.id는 1입니다. const res = await fetch(`https://.../posts/${params.id}`); const post = await res.json(); // post 데이터를 페이지에 프롭으로 전달합니다. return { props: { post } }; } export default Post; 복사 getStaticPaths의 작동 방식에 대해 자세히 알아보려면 데이터 가져오기 문서를 확인하세요. 참고 정적 생성을 언제 사용해야 할지 궁금하다면 사전 렌더링과 데이터 가져오기를 확인하세요. "},{"title":"SSR​","type":1,"pageTitle":"페이지","url":"/docs-repository/docs/next-js/문서/기본-기능/페이지#ssr","content":"동적 렌더링으로도 부릅니다. 페이지가 SSR을 사용하는 경우에는 페이지 HTML이 각 요청마다 생성됩니다. 페이지에 SSR을 사용하려면 getServerSideProps라는 async 함수를 export해야 합니다. 이 함수는 매 요청마다 서버에서 호출됩니다. 예를 들어 페이지에서 자주 갱신되는 데이터(외부 API에서 가져옴)를 미리 렌더링해야 한다고 가정해 보겠습니다. 해당 데이터를 가져와 Page에게 전달하는 getServerSideProps을 다음과 같이 작성할 수 있습니다. jsx function Page({ data }) { // data를 렌더링합니다... } // 이 함수는 매 요청마다 호출됩니다. export async function getServerSideProps() { // 외부 API에서 data를 가져옵니다. const res = await fetch(`https://.../data`); const data = await res.json(); // data를 페이지에 프롭으로 전달합니다. return { props: { data } }; } export default Page; 복사 jsx function Page({ data }) { // data를 렌더링합니다... } // 이 함수는 매 요청마다 호출됩니다. export async function getServerSideProps() { // 외부 API에서 data를 가져옵니다. const res = await fetch(`https://.../data`); const data = await res.json(); // data를 페이지에 프롭으로 전달합니다. return { props: { data } }; } export default Page; 복사 보시다시피 getServerSideProps는 getStaticProps와 유사합니다. 둘의 차이점은 getServerSideProps가 빌드 타임이 아니라 모든 요청마다 실행된다는 점입니다. getServerSideProps의 작동 방식에 대해 자세히 알아보려면 데이터 가져오기 문서를 확인하세요. "},{"title":"요약​","type":1,"pageTitle":"페이지","url":"/docs-repository/docs/next-js/문서/기본-기능/페이지#요약","content":"넥스트의 두 가지 사전 렌더링에 대해 알아보았습니다. 정적 생성(권장) - HTML은 빌드 타임에 생성되며 각 요청에서 재사용됩니다. 페이지에서 정적 생성을 사용하려면 페이지 컴포넌트를 내보내거나 getStaticProps(필요한 경우 getStaticPaths도)를 내보내면 됩니다. 이 방식은 사용자의 요청에 앞서 미리 렌더링할 수 있는 페이지에 적합합니다. CSR과 함께 사용하여 추가 데이터를 가져오는 것도 가능합니다.SSR - HTML은 각 요청마다 생성됩니다. 페이지에서 SSR을 사용하려면 getServerSideProps을 내보냅니다. SSR은 정적 생성보다 성능이 떨어지므로 반드시 필요한 경우에만 사용합니다. "},{"title":"동적 경로","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/라우팅/동적-경로","content":"","keywords":""},{"title":"모든 경로 잡기​","type":1,"pageTitle":"동적 경로","url":"/docs-repository/docs/next-js/문서/라우팅/동적-경로#모든-경로-잡기","content":"대괄호 안에 점 세 개(...)를 추가해 동적 경로를 확장하여 모든 경로를 잡을 수 있습니다. 예를 들어 pages/post/[...slug].js는 /post/a뿐만 아니라 /post/a/b, /post/a/b/c 등을 일치시킵니다. 참고 slug 대신 [...param]와 같은 다른 이름을 사용할 수 있습니다. 일치하는 매개변수는 페이지에 쿼리 매개변수(예시에서는 slug)로 전송되며, 항상 배열이므로 경로 /post/a의 query 객체는 다음과 같습니다. json { &quot;slug&quot;: [&quot;a&quot;] } 복사 json { &quot;slug&quot;: [&quot;a&quot;] } 복사 그리고 /post/a/b와 같은 경로에는 다음과 같이 새 매개변수가 배열에 추가됩니다. json { &quot;slug&quot;: [&quot;a&quot;, &quot;b&quot;] } 복사 json { &quot;slug&quot;: [&quot;a&quot;, &quot;b&quot;] } 복사 "},{"title":"선택적으로 모든 경로 잡기​","type":1,"pageTitle":"동적 경로","url":"/docs-repository/docs/next-js/문서/라우팅/동적-경로#선택적으로-모든-경로-잡기","content":"'모든 경로 잡기'는 이중 대괄호에 매개변수를 넣어서([[...slug]]) 선택적으로 만들 수 있습니다. 예를 들어 pages/post/[[...slug]].js는 /post, /post/a, /post/a/b를 일치시킵니다. '선택적으로 모든 경로 잡기'의 주요 차이점은 매개변수가 없는 경로도 일치한다는 점입니다. /post가 그 예입니다. query 객체는 다음과 같습니다. json { } // '/post'를 얻습니다. (빈 객체) { &quot;slug&quot;: [&quot;a&quot;] } // '/post/a'를 얻습니다. (단일 요소를 가진 배열) { &quot;slug&quot;: [&quot;a&quot;, &quot;b&quot;] } // '/post/a/b'를 얻습니다. (여러 요소를 가진 배열) 복사 json { } // '/post'를 얻습니다. (빈 객체) { &quot;slug&quot;: [&quot;a&quot;] } // '/post/a'를 얻습니다. (단일 요소를 가진 배열) { &quot;slug&quot;: [&quot;a&quot;, &quot;b&quot;] } // '/post/a/b'를 얻습니다. (여러 요소를 가진 배열) 복사 "},{"title":"주의 사항​","type":1,"pageTitle":"동적 경로","url":"/docs-repository/docs/next-js/문서/라우팅/동적-경로#주의-사항","content":"미리 정의된 경로는 동적 경로보다 우선하며 동적 경로는 모든 경로를 잡습니다. 예시: pages/post/create.js는 /post/create를 일치시킴pages/post/[pid].js는 /post/1, /post/abc를 일치시킴. /post/create는 일치시키지 않음pages/post/[...slug].js는 /post/1/2, /post/a/b/c를 일치시킴. /post/create, /post/abc는 일치시키지 않음 자동 정적 최적화에 의해 정적으로 최적화된 페이지는 경로 매개변수를 제공하지 않고 수화됩니다. 즉 query는 빈 객체({})가 됩니다. 수화 이후에 넥스트는 query 객체의 경로 매개변수를 제공하기 위해 앱에 대한 갱신을 트리거합니다. "},{"title":"라우팅","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/라우팅/소개","content":"","keywords":""},{"title":"페이지 간 연결하기​","type":1,"pageTitle":"라우팅","url":"/docs-repository/docs/next-js/문서/라우팅/소개#페이지-간-연결하기","content":"넥스트 라우터를 사용하면 SPA과 유사하게 페이지 간에 클라이언트 측 경로 전환을 수행할 수 있습니다. 이러한 클라이언트 측 경로 전환을 수행하기 위해 Link라는 리액트 컴포넌트가 제공됩니다. jsx import Link from 'next/link'; function Home() { return ( &lt;ul&gt; &lt;li&gt; &lt;Link href=&quot;/&quot;&gt; &lt;a&gt;Home&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link href=&quot;/about&quot;&gt; &lt;a&gt;About Us&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link href=&quot;/blog/hello-world&quot;&gt; &lt;a&gt;Blog Post&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; ); } export default Home; 복사 jsx import Link from 'next/link'; function Home() { return ( &lt;ul&gt; &lt;li&gt; &lt;Link href=&quot;/&quot;&gt; &lt;a&gt;Home&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link href=&quot;/about&quot;&gt; &lt;a&gt;About Us&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link href=&quot;/blog/hello-world&quot;&gt; &lt;a&gt;Blog Post&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; ); } export default Home; 복사 위의 예시에서는 복수의 링크를 사용합니다. 각 링크에는 다음의 페이지로 향하는 경로(href)가 매핑됩니다. / → pages/index.js/about → pages/about.js/blog/hello-world → pages/blog/[slug].js 뷰포트의 모든 &lt;Link /&gt;(초기 또는 스크롤로 인한)는 기본적으로 정적 생성을 사용하는 페이지와 해당 데이터를 미리 가져옵니다. 반면 서버 렌더링 경로의 데이터는 미리 가져오지 않습니다. "},{"title":"동적 경로에 연결하기​","type":1,"pageTitle":"라우팅","url":"/docs-repository/docs/next-js/문서/라우팅/소개#동적-경로에-연결하기","content":"보간법(interpolation)을 사용하여 경로를 생성할 수 있는데 이는 동적 경로 세그먼트에 유용합니다. 예를 들어 컴포넌트에 프롭으로 전달된 게시물 목록을 표시하려면 다음과 같이 코드를 작성할 수 있습니다. jsx import Link from 'next/link'; function Posts({ posts }) { return ( &lt;ul&gt; {posts.map((post) =&gt; ( &lt;li key={post.id}&gt; &lt;Link href={`/blog/${encodeURIComponent(post.slug)}`}&gt; &lt;a&gt;{post.title}&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; ); } export default Posts; 복사 jsx import Link from 'next/link'; function Posts({ posts }) { return ( &lt;ul&gt; {posts.map((post) =&gt; ( &lt;li key={post.id}&gt; &lt;Link href={`/blog/${encodeURIComponent(post.slug)}`}&gt; &lt;a&gt;{post.title}&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; ); } export default Posts; 복사 참고 경로의 utf-8 호환성을 위해 encodeURIComponent가 사용되었습니다. 또는 URL 객체를 사용하면 다음과 같습니다. jsx import Link from 'next/link'; function Posts({ posts }) { return ( &lt;ul&gt; {posts.map((post) =&gt; ( &lt;li key={post.id}&gt; &lt;Link href={{ pathname: '/blog/[slug]', query: { slug: post.slug }, }} &gt; &lt;a&gt;{post.title}&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; ); } export default Posts; 복사 jsx import Link from 'next/link'; function Posts({ posts }) { return ( &lt;ul&gt; {posts.map((post) =&gt; ( &lt;li key={post.id}&gt; &lt;Link href={{ pathname: '/blog/[slug]', query: { slug: post.slug }, }} &gt; &lt;a&gt;{post.title}&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; ); } export default Posts; 복사 href에서 경로 생성을 위해 보간법을 사용하는 대신 URL 객체를 사용했습니다. pathname은 pages 디렉터리에 있는 페이지의 이름입니다. 이 예시에서는 /blog/[slug]입니다.query는 동적 세그먼트가 있는 객체입니다. 이 예시에서는 slug입니다. "},{"title":"라우터 주입하기​","type":1,"pageTitle":"라우팅","url":"/docs-repository/docs/next-js/문서/라우팅/소개#라우터-주입하기","content":"리액트 컴포넌트에서 router 객체에 접근하려면 useRouter 또는 withRouter를 사용할 수 있습니다. 일반적으로 useRouter를 사용하는 것이 좋습니다. "},{"title":"얕은 라우팅","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/라우팅/얕은-라우팅","content":"","keywords":""},{"title":"주의 사항​","type":1,"pageTitle":"얕은 라우팅","url":"/docs-repository/docs/next-js/문서/라우팅/얕은-라우팅#주의-사항","content":"얕은 라우팅은 현재 페이지의 URL 변경에서만 작동합니다. 예를 들어 pages/about.js라는 다른 페이지가 있으며 다음을 실행한다고 가정해 보겠습니다. jsx router.push('/?counter=10', '/about?counter=10', { shallow: true }); 복사 jsx router.push('/?counter=10', '/about?counter=10', { shallow: true }); 복사 pages/about.js는 새 페이지이므로 현재 페이지를 언로드하고 새 페이지를 로드하며, 얕은 라우팅을 요청했음에도 데이터 가져오기를 기다립니다. 미들웨어와 함께 얕은 라우팅을 사용하면 새 페이지가 현재 페이지와 일치하는지 확인할 수 없습니다. 이는 미들웨어가 페이지를 동적으로 재작성할 수 있으며, 얕은 라우팅을 건너뛰는 데이터 가져오기인지 클라이언트 측에서 확인할 수 없기 때문입니다. 따라서 얕은 경로 변경은 항상 얕게 처리되어야 합니다. "},{"title":"직접 명령하기","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/라우팅/직접-명령하기","content":"직접 명령하기 next/link는 대부분의 라우팅을 처리할 수 있지만 원한다면 다른 방법을 사용해 클라이언트 측 내비게이션을 수행할 수 있습니다. next/router 문서에서 관련 내용을 확인하세요. 다음 예시는 useRouter를 사용하여 기본적인 페이지 내비게이션을 수행하는 방법을 보여줍니다. jsx import { useRouter } from 'next/router'; export default function ReadMore() { const router = useRouter(); return ( &lt;button onClick={() =&gt; router.push('/about')}&gt; Click here to read more &lt;/button&gt; ); } 복사 jsx import { useRouter } from 'next/router'; export default function ReadMore() { const router = useRouter(); return ( &lt;button onClick={() =&gt; router.push('/about')}&gt; Click here to read more &lt;/button&gt; ); } 복사","keywords":""},{"title":"인증","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/인증","content":"","keywords":""},{"title":"인증 패턴​","type":1,"pageTitle":"인증","url":"/docs-repository/docs/next-js/문서/인증#인증-패턴","content":"필요한 인증 패턴을 식별하는 첫 번째 단계는 원하는 데이터 가져오기 전략을 파악하는 것입니다. 그런 다음 이 전략을 지원하는 인증 공급자를 결정할 수 있습니다. 두 가지 주요 패턴이 있습니다. 정적 생성을 사용하여 로딩 상태를 서버에서 렌더링한 다음 클라이언트 측에서 사용자 데이터를 가져옵니다.인증되지 않은 콘텐츠의 깜빡임를 제거하기 위해 서버 측에서 사용자 데이터를 가져옵니다. "},{"title":"정적으로 생성된 페이지에서 인증하기​","type":1,"pageTitle":"인증","url":"/docs-repository/docs/next-js/문서/인증#정적으로-생성된-페이지에서-인증하기","content":"넥스트는 차단 데이터 요구 사항이 없는 경우 페이지가 정적인지 자동으로 결정합니다. 이것은 페이지에 getServerSideProps와 getInitialProps가 없음을 의미합니다. 대신 페이지가 서버에서 로드 상태를 렌더링한 다음 클라이언트 측에서 사용자 데이터를 가져올 수 있습니다. 이 패턴의 장점 중 하나는 전역 CDN에서 페이지를 제공하고 next/link를 사용하여 미리 로드할 수 있다는 것입니다. 실제로 이 방식은 더 빠른 TTI(Time to Interactive)를 가집니다. 프로필 페이지 예시를 살펴보겠습니다. 이 페이지는 처음에 로딩 스켈레톤을 렌더링합니다. 사용자 요청이 완료되면 사용자 이름이 표시됩니다. pages/profile.js jsx import useUser from '../lib/useUser'; import Layout from '../components/Layout'; const Profile = () =&gt; { // 클라이언트 측에서 사용자를 가져옵니다. const { user } = useUser({ redirectTo: '/login' }); // 서버 측에서 로딩 상태를 렌더링합니다. if (!user || user.isLoggedIn === false) { return &lt;Layout&gt;Loading...&lt;/Layout&gt;; } // 사용자 요청이 완료되면 사용자를 표시합니다. return ( &lt;Layout&gt; &lt;h1&gt;Your Profile&lt;/h1&gt; &lt;pre&gt;{JSON.stringify(user, null, 2)}&lt;/pre&gt; &lt;/Layout&gt; ); }; export default Profile; 복사 pages/profile.js jsx import useUser from '../lib/useUser'; import Layout from '../components/Layout'; const Profile = () =&gt; { // 클라이언트 측에서 사용자를 가져옵니다. const { user } = useUser({ redirectTo: '/login' }); // 서버 측에서 로딩 상태를 렌더링합니다. if (!user || user.isLoggedIn === false) { return &lt;Layout&gt;Loading...&lt;/Layout&gt;; } // 사용자 요청이 완료되면 사용자를 표시합니다. return ( &lt;Layout&gt; &lt;h1&gt;Your Profile&lt;/h1&gt; &lt;pre&gt;{JSON.stringify(user, null, 2)}&lt;/pre&gt; &lt;/Layout&gt; ); }; export default Profile; 복사 실제 작동하는 예시를 확인하세요. "},{"title":"서버 렌더링 페이지에서 인증하기​","type":1,"pageTitle":"인증","url":"/docs-repository/docs/next-js/문서/인증#서버-렌더링-페이지에서-인증하기","content":"페이지에서 getServerSideProps async 함수를 내보내는 경우, 넥스트는 getServerSideProps에서 반환된 데이터를 사용하여 각 요청에서 해당 페이지를 미리 렌더링합니다. jsx export async function getServerSideProps(context) { return { props: {}, // 페이지 컴포넌트에 프롭으로 전달될 것입니다. }; } 복사 jsx export async function getServerSideProps(context) { return { props: {}, // 페이지 컴포넌트에 프롭으로 전달될 것입니다. }; } 복사 서버 측 렌더링을 사용하도록 프로필 예시를 바꿔 보겠습니다. 세션이 있는 경우, 페이지의 Profile 컴포넌트에 user를 props로 반환합니다. 이 예시에는 로딩 스켈레톤이 없습니다. pages/profile.js jsx import withSession from '../lib/session'; import Layout from '../components/Layout'; export const getServerSideProps = withSession(async function ({ req, res }) { const { user } = req.session; if (!user) { return { redirect: { destination: '/login', permanent: false, }, }; } return { props: { user }, }; }); const Profile = ({ user }) =&gt; { // 사용자를 표시합니다. 로딩 상태는 필요하지 않습니다. return ( &lt;Layout&gt; &lt;h1&gt;Your Profile&lt;/h1&gt; &lt;pre&gt;{JSON.stringify(user, null, 2)}&lt;/pre&gt; &lt;/Layout&gt; ); }; export default Profile; 복사 pages/profile.js jsx import withSession from '../lib/session'; import Layout from '../components/Layout'; export const getServerSideProps = withSession(async function ({ req, res }) { const { user } = req.session; if (!user) { return { redirect: { destination: '/login', permanent: false, }, }; } return { props: { user }, }; }); const Profile = ({ user }) =&gt; { // 사용자를 표시합니다. 로딩 상태는 필요하지 않습니다. return ( &lt;Layout&gt; &lt;h1&gt;Your Profile&lt;/h1&gt; &lt;pre&gt;{JSON.stringify(user, null, 2)}&lt;/pre&gt; &lt;/Layout&gt; ); }; export default Profile; 복사 이 패턴의 장점은 리디렉션하기 전에 인증되지 않은 콘텐츠의 깜빡임를 방지한다는 것입니다. getServerSideProps의 사용자 데이터 가져오기가 인증 공급자에 대한 요청이 이행될 때까지 렌더링을 막는다는 것을 주목해야 합니다. 병목 현상을 방지하고 TTFB(Time to First Byte)를 늘리려면 인증 조회가 빠른지 확인해야 합니다. 그러지 않으면 앞의 정적 생성을 고려해야 합니다. "},{"title":"인증 제공자​","type":1,"pageTitle":"인증","url":"/docs-repository/docs/next-js/문서/인증#인증-제공자","content":"이제 제공자에 따라 넥스트와 함께 사용하는 방식을 살펴보겠습니다. "},{"title":"나만의 데이터베이스 사용하기​","type":1,"pageTitle":"인증","url":"/docs-repository/docs/next-js/문서/인증#나만의-데이터베이스-사용하기","content":"사용자 데이터가 있는 기존 데이터베이스가 있는 경우 제공자에 구애받지 않는 오픈 소스 솔루션을 활용하고 싶을 것입니다. 낮은 수준의 암호화된 상태 비저장 세션 유틸리티를 원하는 경우 iron-session을 사용내장 제공자(구글, 페이스북, 깃허브...), JWT, JWE, 이메일/비밀번호, 매직 링크 등을 포함하는 완전한 기능의 인증 시스템을 원하면 next-auth을 사용 이 두 라이브러리 모두 인증 패턴을 지원합니다. 패스포트에 관심이 있다면 안전하고 암호화된 쿠키를 사용하는 예시도 있습니다. with-passportwith-passport-and-next-connect "},{"title":"다른 제공자​","type":1,"pageTitle":"인증","url":"/docs-repository/docs/next-js/문서/인증#다른-제공자","content":"다른 인증 제공자 예시는 다음과 같습니다. Auth0ClerkFirebaseMagicNhostOrySupabaseSupertokensUserbase "},{"title":"절대 가져오기와 모듈 경로 별칭","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/절대-가져오기와-모듈-경로-별칭","content":"절대 가져오기와 모듈 경로 별칭 넥스트는 넥스트 9.4부터 tsconfig.json, jsconfig.json, &quot;paths&quot;, &quot;baseUrl&quot; 옵션을 자동으로 지원합니다. 참고 jsconfig.json는 타입스크립트를 사용하지 않을 때 사용할 수 있습니다. 참고 tsconfig.json나 jsconfig.json의 수정 사항을 반영하려면 개발 서버를 다시 시작해야 합니다. 이 옵션을 사용하면 모듈 별칭을 설정할 수 있습니다. 일반적인 패턴은 절대 경로를 사용하도록 특정 디렉터리에 별칭을 지정하는 것입니다. 이 옵션의 유용한 기능 중 하나는 vscode와 같은 특정 편집기에 자동으로 통합된다는 것입니다. baseUrl 설정 옵션을 사용하면 프로젝트의 루트에서 직접 가져올 수 있습니다. 예시: tsconfig.json 또는 jsconfig.json json { &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;.&quot; } } 복사 tsconfig.json 또는 jsconfig.json json { &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;.&quot; } } 복사 components/button.js jsx export default function Button() { return &lt;button&gt;Click me&lt;/button&gt;; } 복사 components/button.js jsx export default function Button() { return &lt;button&gt;Click me&lt;/button&gt;; } 복사 pages/index.js jsx import Button from 'components/button'; export default function HomePage() { return ( &lt;&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;Button /&gt; &lt;/&gt; ); } 복사 pages/index.js jsx import Button from 'components/button'; export default function HomePage() { return ( &lt;&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;Button /&gt; &lt;/&gt; ); } 복사 1:1로 일치하지 않는 다른 별칭을 추가하는 것도 가능합니다. 타입스크립트에 이를 위한 &quot;paths&quot; 옵션이 있습니다. &quot;paths&quot;를 사용하면 모듈 별칭을 설정할 수 있습니다. 예를 들어 @/components/*는 components/*을 가리킵니다. 예시: tsconfig.json 또는 jsconfig.json json { &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: { &quot;@/components/*&quot;: [&quot;components/*&quot;] } } } 복사 tsconfig.json 또는 jsconfig.json json { &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: { &quot;@/components/*&quot;: [&quot;components/*&quot;] } } } 복사 components/button.js jsx export default function Button() { return &lt;button&gt;Click me&lt;/button&gt;; } 복사 components/button.js jsx export default function Button() { return &lt;button&gt;Click me&lt;/button&gt;; } 복사 pages/index.js jsx import Button from '@/components/button'; export default function HomePage() { return ( &lt;&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;Button /&gt; &lt;/&gt; ); } 복사 pages/index.js jsx import Button from '@/components/button'; export default function HomePage() { return ( &lt;&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;Button /&gt; &lt;/&gt; ); } 복사","keywords":""},{"title":"테스트","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/테스트","content":"","keywords":""},{"title":"사이프러스​","type":1,"pageTitle":"테스트","url":"/docs-repository/docs/next-js/문서/테스트#사이프러스","content":"사이프러스는 E2E(End-to-End) 및 통합 테스트에 사용되는 테스트 러너입니다. "},{"title":"빠른 시작​","type":1,"pageTitle":"테스트","url":"/docs-repository/docs/next-js/문서/테스트#빠른-시작","content":"with-cypress 예시와 create-next-app을 사용하여 빠르게 시작할 수 있습니다. bash npx create-next-app@latest --example with-cypress with-cypress-app 복사 bash npx create-next-app@latest --example with-cypress with-cypress-app 복사 "},{"title":"수동 설정​","type":1,"pageTitle":"테스트","url":"/docs-repository/docs/next-js/문서/테스트#수동-설정","content":"사이프러스를 시작하려면 다음과 같이 cypress 패키지를 설치합니다. bash npm install --save-dev cypress 복사 bash npm install --save-dev cypress 복사 package.json 스크립트 필드에 사이프러스를 추가합니다. json &quot;scripts&quot;: { &quot;dev&quot;: &quot;next dev&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start&quot;, &quot;cypress&quot;: &quot;cypress open&quot;, } 복사 json &quot;scripts&quot;: { &quot;dev&quot;: &quot;next dev&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start&quot;, &quot;cypress&quot;: &quot;cypress open&quot;, } 복사 사이프러스를 처음 실행하여 권장 폴더 구조를 사용하는 예시를 생성합니다. bash npm run cypress 복사 bash npm run cypress 복사 생성된 예시와 사이프러스 문서의 첫 번째 테스트 작성하기 섹션을 살펴보며 사이프러스에 익숙해질 수 있습니다. 테스트 파일의 끝에 export {}를 추가해 모듈로 만들어 오류를 막습니다. "},{"title":"첫 번째 사이프러스 통합 테스트 만들기​","type":1,"pageTitle":"테스트","url":"/docs-repository/docs/next-js/문서/테스트#첫-번째-사이프러스-통합-테스트-만들기","content":"다음과 같은 두 개의 넥스트 페이지가 있다고 가정해 보겠습니다. pages/index.js jsx import Link from 'next/link'; export default function Home() { return ( &lt;nav&gt; &lt;Link href=&quot;/about&quot;&gt; &lt;a&gt;About&lt;/a&gt; &lt;/Link&gt; &lt;/nav&gt; ); } 복사 pages/index.js jsx import Link from 'next/link'; export default function Home() { return ( &lt;nav&gt; &lt;Link href=&quot;/about&quot;&gt; &lt;a&gt;About&lt;/a&gt; &lt;/Link&gt; &lt;/nav&gt; ); } 복사 pages/about.js jsx export default function About() { return ( &lt;div&gt; &lt;h1&gt;About Page&lt;/h1&gt; &lt;/div&gt; ); } 복사 pages/about.js jsx export default function About() { return ( &lt;div&gt; &lt;h1&gt;About Page&lt;/h1&gt; &lt;/div&gt; ); } 복사 탐색이 올바르게 작동하는지 확인하는 테스트를 추가합니다. cypress/integration/app.spec.js jsx describe('Navigation', () =&gt; { it('should navigate to the about page', () =&gt; { // 색인 페이지에서 시작합니다. cy.visit('http://localhost:3000/'); // &quot;about&quot;을 포함하는 href 속성을 가진 링크를 찾고 클릭합니다. cy.get('a[href*=&quot;about&quot;]').click(); // 새 url은 &quot;/about&quot;을 포함해야 합니다. cy.url().should('include', '/about'); // 새 페이지는 &quot;About Page&quot;가 있는 h1을 포함해야 합니다. cy.get('h1').contains('About Page'); }); }); 복사 cypress/integration/app.spec.js jsx describe('Navigation', () =&gt; { it('should navigate to the about page', () =&gt; { // 색인 페이지에서 시작합니다. cy.visit('http://localhost:3000/'); // &quot;about&quot;을 포함하는 href 속성을 가진 링크를 찾고 클릭합니다. cy.get('a[href*=&quot;about&quot;]').click(); // 새 url은 &quot;/about&quot;을 포함해야 합니다. cy.url().should('include', '/about'); // 새 페이지는 &quot;About Page&quot;가 있는 h1을 포함해야 합니다. cy.get('h1').contains('About Page'); }); }); 복사 cypress.json 설정 파일에 &quot;baseUrl&quot;: &quot;http://localhost:3000&quot;을 추가하면 cy.visit(&quot;http://localhost:3000/&quot;) 대신 cy.visit(&quot;/&quot;)을 사용할 수 있습니다. "},{"title":"사이프러스 테스트 실행하기​","type":1,"pageTitle":"테스트","url":"/docs-repository/docs/next-js/문서/테스트#사이프러스-테스트-실행하기","content":"사이프러스는 실제 넥스트 앱을 테스트하므로 사이프러스를 시작하기 전에 넥스트 서버가 실행 중이어야 합니다. 앱이 작동하는 방식과 더 유사하도록 프로덕션 코드에 대해 테스트를 실행하는 것이 좋습니다. npm run build와 npm run start를 실행한 다음 다른 터미널 창에서 npm run cypress을 실행하여 사이프러스를 시작합니다. 참고 또는 start-server-and-test 패키지를 설치하고 package.json 스크립트 필드에 &quot;test&quot;: &quot;start-server-and-test start http://localhost:3000 cypress&quot;를 추가하여 사이프러스와 함께 넥스트 프로덕션 서버를 시작할 수 있습니다. 새로운 변경 사항 후에는 앱을 다시 빌드해야 합니다. "},{"title":"지속적 통합(CI) 준비하기​","type":1,"pageTitle":"테스트","url":"/docs-repository/docs/next-js/문서/테스트#지속적-통합ci-준비하기","content":"지금까지 사이프러스를 실행하면 CI 환경에 적합하지 않은 대화형 브라우저가 열렸습니다. cypress run 명령을 사용하여 헤드리스로 사이프러스를 실행할 수도 있습니다. package.json json &quot;scripts&quot;: { //... &quot;cypress&quot;: &quot;cypress open&quot;, &quot;cypress:headless&quot;: &quot;cypress run&quot;, &quot;e2e&quot;: &quot;start-server-and-test start http://localhost:3000 cypress&quot;, &quot;e2e:headless&quot;: &quot;start-server-and-test start http://localhost:3000 cypress:headless&quot; } 복사 package.json json &quot;scripts&quot;: { //... &quot;cypress&quot;: &quot;cypress open&quot;, &quot;cypress:headless&quot;: &quot;cypress run&quot;, &quot;e2e&quot;: &quot;start-server-and-test start http://localhost:3000 cypress&quot;, &quot;e2e:headless&quot;: &quot;start-server-and-test start http://localhost:3000 cypress:headless&quot; } 복사 사이프러스 지속적 통합 문서에서 사이프러스와 지속적 통합에 대해 자세히 알아보세요. "},{"title":"문제 해결","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문제-해결","content":"문제 해결 CSR과 동적 경로를 사용할 때 경로의 쿼리를 사용하는 논리가 있다고 가정합니다. 이때 새로고침을 하면 쿼리가 비어 있어 오류가 발생할 수 있습니다. 해결 방법은 링크를 참고하세요.","keywords":""},{"title":"시작하기","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/시작하기","content":"","keywords":""},{"title":"자동 설정​","type":1,"pageTitle":"시작하기","url":"/docs-repository/docs/next-js/시작하기#자동-설정","content":"모든 것을 자동으로 설정하는 create-next-app을 사용하여 새로운 넥스트 앱을 만드는 것을 권장합니다. 프로젝트를 생성하려면 다음을 실행합니다. npmYarn bash npx create-next-app@latest 복사 bash npx create-next-app@latest 복사 타입스크립트 프로젝트로 시작하려면 --typescript 플래그를 사용합니다. npmYarn bash npx create-next-app@latest --typescript 복사 bash npx create-next-app@latest --typescript 복사 설치가 완료된 후에 다음을 수행합니다. npm run dev을 실행해 http://localhost:3000에서 개발 서버를 시작합니다.http://localhost:3000을 방문해 앱을 확인합니다.pages/index.js를 수정하고 브라우저에서 갱신된 결과를 확인합니다. "},{"title":"넥스트로 폼 작성하기","type":0,"sectionRef":"#","url":"/docs-repository/docs/next-js/문서/폼-작성하기","content":"","keywords":""},{"title":"1. HTML 양식​","type":1,"pageTitle":"넥스트로 폼 작성하기","url":"/docs-repository/docs/next-js/문서/폼-작성하기#1-html-양식","content":"HTML 폼은 &lt;form&gt; 태그를 사용하여 작성됩니다. &lt;form&gt; 태그에는 텍스트 필드, 체크박스, 드롭다운 메뉴, 버튼, 라디오 버튼 등과 같은 폼을 구성하기 위해 속성과 필드 세트가 필요합니다. HTML 폼의 문법은 다음과 같습니다. html &lt;!-- 기본 HTML 폼 --&gt; &lt;form action=&quot;/send-data-here&quot; method=&quot;post&quot;&gt; &lt;label for=&quot;first&quot;&gt;First name:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;first&quot; name=&quot;first&quot; /&gt; &lt;label for=&quot;last&quot;&gt;Last name:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;last&quot; name=&quot;last&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; 복사 html &lt;!-- 기본 HTML 폼 --&gt; &lt;form action=&quot;/send-data-here&quot; method=&quot;post&quot;&gt; &lt;label for=&quot;first&quot;&gt;First name:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;first&quot; name=&quot;first&quot; /&gt; &lt;label for=&quot;last&quot;&gt;Last name:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;last&quot; name=&quot;last&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; 복사 HTML &lt;form&gt; 태그는 text 필드와 같은 여러 &lt;input&gt; 요소와 submit button의 컨테이너 역할을 합니다. 해당 요소를 각각 살펴보겠습니다. action - 폼이 제출될 때 폼 데이터가 전송되는 위치를 지정하는 속성입니다. 일반적으로 URL(절대 URL 또는 상대 URL)입니다.method - HTTP 메서드를 지정합니다. 폼을 제출할 때 데이터를 보내는 방식을 지정하며 GET이나 POST를 많이 사용합니다.&lt;label&gt; - 다른 폼 요소의 레이블을 정의하는 요소입니다. 레이블은 화면 낭독기의 접근성을 향상시킵니다.&lt;input&gt; - 폼 필드를 구성하는 데 널리 사용되는 폼 요소입니다. type 속성 값에 따라 크게 달라집니다. 타입은 text, checkbox, email, radio 등이 될 수 있습니다.&lt;button&gt; - 폼 데이터를 제출하는 데 사용되는 클릭 가능한 버튼을 나타냅니다. "},{"title":"폼 유효성 검사​","type":1,"pageTitle":"넥스트로 폼 작성하기","url":"/docs-repository/docs/next-js/문서/폼-작성하기#폼-유효성-검사","content":"사용자가 제공한 정보가 올바른지 확인하는 프로세스입니다. 또한 폼 유효성 검사는 제공된 정보가 올바른 형식인지 확인합니다. 예를 들어 이메일 필드에 @가 있는지 확인할 수 있습니다. 유효성 검사에는 두 가지 유형이 있습니다. 클라이언트 측 - 유효성 검사를 브라우저에서 수행서버 측 - 유효성 검사를 서버에서 수행 두 가지 유형 모두 중요하지만 이 안내서에서는 클라이언트 측 유효성 검사만 다룰 것입니다. 클라이언트 측 유효성 검사는 다음과 같이 분류할 수 있습니다. 내장 - required, type, minLength, maxLength, pattern 등과 같은 HTML 기반 속성을 사용함자바스크립트 기반 - 자바스크립트로 작성한 유효성 검사 "},{"title":"내장 폼 유효성 검사​","type":1,"pageTitle":"넥스트로 폼 작성하기","url":"/docs-repository/docs/next-js/문서/폼-작성하기#내장-폼-유효성-검사","content":"required - 양식을 제출하기 전에 작성해야 하는 필드를 지정type - 데이터 유형(예: 숫자, 이메일 주소, 문자열 등)을 지정minLength - 텍스트 데이터 문자열의 최소 길이를 지정maxLength - 텍스트 데이터 문자열의 최대 길이를 지정 다음은 이 속성들을 사용하는 폼 예시입니다. html &lt;!-- 내장 유효성 검사를 사용하는 HTML 폼 --&gt; &lt;form action=&quot;/send-data-here&quot; method=&quot;post&quot;&gt; &lt;label for=&quot;roll&quot;&gt;Roll Number&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;roll&quot; name=&quot;roll&quot; required minlength=&quot;10&quot; maxlength=&quot;20&quot; /&gt; &lt;label for=&quot;name&quot;&gt;Name:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; required /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; 복사 html &lt;!-- 내장 유효성 검사를 사용하는 HTML 폼 --&gt; &lt;form action=&quot;/send-data-here&quot; method=&quot;post&quot;&gt; &lt;label for=&quot;roll&quot;&gt;Roll Number&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;roll&quot; name=&quot;roll&quot; required minlength=&quot;10&quot; maxlength=&quot;20&quot; /&gt; &lt;label for=&quot;name&quot;&gt;Name:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; required /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; 복사 사용자가 name 필드를 작성하지 않은 상태로 제출하려고 하면 폼 필드에 바로 표시되는 오류가 발생합니다. 마찬가지로 roll 번호는 길이가 10-20자인 경우에만 입력할 수 있습니다. "},{"title":"자바스크립트 기반 폼 유효성 검사​","type":1,"pageTitle":"넥스트로 폼 작성하기","url":"/docs-repository/docs/next-js/문서/폼-작성하기#자바스크립트-기반-폼-유효성-검사","content":"폼 유효성 검사는 사용자가 올바른 형식으로 올바른 데이터를 제출했는지 확인할 수 있으므로 중요합니다. 자바스크립트는 클라이언트 측에서 HTML 기본 폼 속성과 함께 추가적인 유효성 검사를 제공합니다. 개발자는 일반적으로 서버 측 유효성 검사에 비해 데이터 처리가 빠른 자바스크립트 기반 폼 데이터 유효성 검사를 선호합니다. 하지만 악의적인 사용자가 항상 잘못된 형식의 데이터를 서버에 보낼 수 있으므로 일부 시나리오에서는 프론트 엔드 유효성 검사가 안전하지 않을 수 있습니다. 다음 예시에서는 자바스크립트를 사용하여 폼을 검증하는 방법을 보여줍니다. html &lt;form onsubmit=&quot;validateFormWithJS()&quot;&gt; &lt;label for=&quot;rollNumber&quot;&gt;Roll Number:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;rollNumber&quot; id=&quot;rollNumber&quot; /&gt; &lt;label for=&quot;name&quot;&gt;Name:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;script&gt; function validateFormWithJS() { const name = document.querySelector('#name').value; const rollNumber = document.querySelector('#rollNumber').value; if (!name) { alert('Please enter your name.'); return false; } if (rollNumber.length &lt; 3) { alert('Roll Number should be at least 3 digits long.'); return false; } } &lt;/script&gt; 복사 html &lt;form onsubmit=&quot;validateFormWithJS()&quot;&gt; &lt;label for=&quot;rollNumber&quot;&gt;Roll Number:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;rollNumber&quot; id=&quot;rollNumber&quot; /&gt; &lt;label for=&quot;name&quot;&gt;Name:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;script&gt; function validateFormWithJS() { const name = document.querySelector('#name').value; const rollNumber = document.querySelector('#rollNumber').value; if (!name) { alert('Please enter your name.'); return false; } if (rollNumber.length &lt; 3) { alert('Roll Number should be at least 3 digits long.'); return false; } } &lt;/script&gt; 복사 HTML 스크립트 태그는 클라이언트 측 자바스크립트를 넣는 데 사용됩니다. 위의 예시와 같이 인라인 스크립팅 명령문을 넣거나 src 속성으로 외부 스크립트 파일을 지정할 수 있습니다. 이 예시에서는 사용자의 이름과 롤 번호를 확인합니다. validateFormWithJS() 함수는 이름 필드가 비어 있는 것을 허용하지 않으며 롤 번호는 최소 3자리 이상이어야 합니다. 제출 버튼을 누르면 유효성 검사가 수행됩니다. 주어진 값이 올바르지 않으면 다음 페이지로 리디렉션되지 않습니다. 정규식을 사용한 폼 유효성 검사​ 정규식(일반적으로 RegEx라고 함)은 문자 패턴을 설명하는 객체입니다. 정규 표현식을 사용한 자바스크립트 유효성 검사는 pattern HTML 속성을 사용합니다. pattern 속성은 &lt;input&gt; 요소에만 적용할 수 있습니다. 이렇게 하면 고유한 규칙을 정의한 정규식(RegEx)을 사용하여 입력 값의 유효성을 검사할 수 있습니다. 값이 정의된 패턴과 일치하지 않으면 input 요소에서 오류가 발생합니다. 다음 예시는 input 요소에 pattern 속성을 사용하는 방법을 보여줍니다. html &lt;form action=&quot;/action_page.php&quot;&gt; &lt;label for=&quot;pswrd&quot;&gt;Password:&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;pswrd&quot; name=&quot;pswrd&quot; pattern=&quot;[a-z0-9]{1,15}&quot; title=&quot;Password should be digits (0 to 9) or alphabets (a to z).&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; 복사 html &lt;form action=&quot;/action_page.php&quot;&gt; &lt;label for=&quot;pswrd&quot;&gt;Password:&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;pswrd&quot; name=&quot;pswrd&quot; pattern=&quot;[a-z0-9]{1,15}&quot; title=&quot;Password should be digits (0 to 9) or alphabets (a to z).&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; 복사 비밀번호 폼 필드는 숫자(0~9)와 소문자 알파벳(a~z)만 포함해야 하며 길이는 15자 이하여야 합니다. 다른 문자(#,$,&amp; 등)는 허용되지 않습니다. RegEx의 규칙은 [a-z0-9]{1,15}로 작성되었습니다. 참고 HTML 폼에 대한 자세한 내용은 MDN 웹 문서를 확인하세요. "},{"title":"2. 프로젝트 설정​","type":1,"pageTitle":"넥스트로 폼 작성하기","url":"/docs-repository/docs/next-js/문서/폼-작성하기#2-프로젝트-설정","content":"다음 섹션에서는 넥스트를 사용하여 리액트에서 폼을 생성할 것입니다. 먼저 새로운 넥스트 앱을 생성합니다. 빠른 시작을 위해 create-next-app을 사용할 수 있습니다. 커맨드 라인 터미널에서 다음을 실행합니다. bash npx create-next-app 복사 bash npx create-next-app 복사 질문에 답하여 프로젝트를 만들고 이름을 지정합니다. 이 예시에서는 next-forms입니다. "},{"title":"3. 넥스트 폼 API 경로 설정하기​","type":1,"pageTitle":"넥스트로 폼 작성하기","url":"/docs-repository/docs/next-js/문서/폼-작성하기#3-넥스트-폼-api-경로-설정하기","content":"클라이언트와 서버 모두 넥스트를 사용하여 빌드될 것입니다. 서버 파트를 위해 폼 데이터를 보낼 API 엔드포인트를 만듭니다. 넥스트는 페이지를 기반으로 구축된, 라우팅을 위한 파일 기반 시스템을 제공합니다. pages/api 폴더 내의 모든 파일은 /api/*에 매핑되며 페이지 대신 API 엔드포인트로 취급됩니다. 이 API 엔드포인트는 서버 측 전용이 될 것입니다. pages/api에 form.js라는 파일을 만들고 노드로 작성된 다음 코드를 붙여 넣습니다. js export default function handler(req, res) { // 제출된 요청의 본문에 있는 데이터를 얻습니다. const body = req.body; // 넥스트 앱이 실행 중인 커맨드 라인에서 // 응답을 보기 위한 선택적 로깅입니다. console.log('body: ', body); // 성과 이름을 확인하고 존재하지 않으면 // 조기에 반환합니다. if (!body.first || !body.last) { // 잘못된 요청에 대한 HTTP 오류 코드를 전송합니다. return res.status(400).json({ data: 'First or last name not found' }); } // 이름이 존재합니다. // HTTP 성공 코드를 전송합니다. res.status(200).json({ data: `${body.first} ${body.last}` }); } 복사 js export default function handler(req, res) { // 제출된 요청의 본문에 있는 데이터를 얻습니다. const body = req.body; // 넥스트 앱이 실행 중인 커맨드 라인에서 // 응답을 보기 위한 선택적 로깅입니다. console.log('body: ', body); // 성과 이름을 확인하고 존재하지 않으면 // 조기에 반환합니다. if (!body.first || !body.last) { // 잘못된 요청에 대한 HTTP 오류 코드를 전송합니다. return res.status(400).json({ data: 'First or last name not found' }); } // 이름이 존재합니다. // HTTP 성공 코드를 전송합니다. res.status(200).json({ data: `${body.first} ${body.last}` }); } 복사 이 폼 handler 함수는 클라이언트로부터 req 요청(제출된 폼 데이터)을 받습니다. 그리고 이름과 성이 모두 들어있는 JSON으로 res 응답을 전송합니다. 이 API 엔드포인트는 http://localhost:3000/api/form로 접근할 수 있습니다. 또는 배포 시 로컬호스트 URL을 실제 베르셀 배포 주소로 바꿀 수 있습니다. 참고 또는 이 API를 몽고DB나 구글 스프레드시트와 같은 데이터베이스에 연결할 수도 있습니다. 이렇게 하면 제출한 폼 데이터가 나중에 사용할 수 있도록 안전하게 저장됩니다. 이 안내서에서는 데이터베이스를 사용하지 않습니다. 대신 데이터가 그대로 사용자에게 반환됩니다. "},{"title":"자바스크립트 없이 폼 제출하기​","type":1,"pageTitle":"넥스트로 폼 작성하기","url":"/docs-repository/docs/next-js/문서/폼-작성하기#자바스크립트-없이-폼-제출하기","content":"이제 폼의 action 속성에서 /api/form 상대 경로 엔드포인트를 사용할 수 있습니다. 폼이 POST HTTP 메서드(데이터를 보내는 데 사용됨)로 제출될 때 폼 데이터가 서버로 전송됩니다. html &lt;form action=&quot;/api/form&quot; method=&quot;post&quot;&gt; &lt;label for=&quot;first&quot;&gt;First name:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;first&quot; name=&quot;first&quot; /&gt; &lt;label for=&quot;last&quot;&gt;Last name:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;last&quot; name=&quot;last&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; 복사 html &lt;form action=&quot;/api/form&quot; method=&quot;post&quot;&gt; &lt;label for=&quot;first&quot;&gt;First name:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;first&quot; name=&quot;first&quot; /&gt; &lt;label for=&quot;last&quot;&gt;Last name:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;last&quot; name=&quot;last&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; 복사 이 폼을 제출하면 폼 API 엔드포인트 /api/form에 데이터가 제출됩니다. 그러면 서버가 응답합니다. 서버는 보통 데이터를 처리하고 action 속성에 정의된 URL을 로드하여 새 페이지를 로드합니다. 이 예시에서는 서버에서 다음 응답과 함께 http://localhost:3000/api/form으로 리디렉션합니다. json { &quot;data&quot;: &quot;Maedah Batool&quot; } 복사 json { &quot;data&quot;: &quot;Maedah Batool&quot; } 복사 "},{"title":"4. 넥스트에서 폼 작성하기​","type":1,"pageTitle":"넥스트로 폼 작성하기","url":"/docs-repository/docs/next-js/문서/폼-작성하기#4-넥스트에서-폼-작성하기","content":"폼 제출을 위한 넥스트 API 경로를 생성했습니다. 이제 리액트를 사용하여 넥스트 내부에 클라이언트(폼)를 작성할 차례입니다. 첫 번째 단계는 HTML 폼에 대한 지식을 확장하고 이를 JSX를 사용해 리액트로 변환하는 것입니다. 다음은 동일한 폼을 JSX를 사용하여 작성한 리액트 함수 컴포넌트입니다. jsx export default function Form() { return ( &lt;form action=&quot;/api/form&quot; method=&quot;post&quot;&gt; &lt;label htmlFor=&quot;first&quot;&gt;First Name&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;first&quot; name=&quot;first&quot; required /&gt; &lt;label htmlFor=&quot;last&quot;&gt;Last Name&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;last&quot; name=&quot;last&quot; required /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; ); } 복사 jsx export default function Form() { return ( &lt;form action=&quot;/api/form&quot; method=&quot;post&quot;&gt; &lt;label htmlFor=&quot;first&quot;&gt;First Name&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;first&quot; name=&quot;first&quot; required /&gt; &lt;label htmlFor=&quot;last&quot;&gt;Last Name&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;last&quot; name=&quot;last&quot; required /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; ); } 복사 변경된 사항은 다음과 같습니다. for 속성이 htmlFor로 변경됩니다. for가 자바스크립트의 for 반복문과 연결된 키워드이므로 리액트 요소는 대신 htmlFor을 사용합니다.action 속성에는 폼 API 엔드포인트인 상대 URL을 넣었습니다. 이제 넥스트 기반 폼의 기본 구조를 완성했습니다. "},{"title":"5. 자바스크립트 없이 폼 제출하기​","type":1,"pageTitle":"넥스트로 폼 작성하기","url":"/docs-repository/docs/next-js/문서/폼-작성하기#5-자바스크립트-없이-폼-제출하기","content":"자바스크립트는 웹 앱에 상호 작용을 제공합니다. 하지만 때로는 자바스크립트 번들이 너무 커지지 않도록 제어해야 하거나 사이트 방문자가 자바스크립트를 비활성화할 수 있습니다. 사용자가 자바스크립트를 비활성화하는 데는 몇 가지 이유가 있습니다. 대역폭 제약 때문에기기(휴대폰 또는 노트북)의 배터리 시간을 늘리기 위해분석 스크립트로 추적되지 않기를 원해서 어떤 이유로든 자바스크립트를 비활성화하면 사이트 기능이 완전히는 아니더라도 부분적으로 영향을 받게 됩니다. /pages 디렉터리에 다음과 같이 no-js-form.js 파일을 작성합니다. jsx export default function PageWithoutJSbasedForm() { return ( &lt;form action=&quot;/api/form&quot; method=&quot;post&quot;&gt; &lt;label htmlFor=&quot;first&quot;&gt;First Name&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;first&quot; name=&quot;first&quot; required /&gt; &lt;label htmlFor=&quot;last&quot;&gt;Last Name&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;last&quot; name=&quot;last&quot; required /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; ); } 복사 jsx export default function PageWithoutJSbasedForm() { return ( &lt;form action=&quot;/api/form&quot; method=&quot;post&quot;&gt; &lt;label htmlFor=&quot;first&quot;&gt;First Name&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;first&quot; name=&quot;first&quot; required /&gt; &lt;label htmlFor=&quot;last&quot;&gt;Last Name&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;last&quot; name=&quot;last&quot; required /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; ); } 복사 자바스크립트가 비활성화된 상태에서 제출 버튼을 누르면 이벤트가 트리거되어 폼 데이터를 수집하고 POST HTTP method를 사용하여 action 속성에 정의된 폼 API 엔드포인트로 데이터를 전송합니다. 폼의 action에 의해 /api/form 엔드포인트로 리디렉션됩니다. 폼 데이터는 앞에서 작성한 폼 핸들러 함수에 req 요청으로 서버에 제출됩니다. 핸들러 함수는 데이터를 처리하고 res 응답을 반환하는데, 이는 제출한 이름이 포함된 JSON 문자열입니다. 참고 사용자 경험을 개선하기 위해 응답으로 사용자를 페이지로 리디렉션하고 폼 제출에 대해 감사를 표할 수 있습니다. "},{"title":"6. 자바스크립트가 활성화된 폼 제출하기​","type":1,"pageTitle":"넥스트로 폼 작성하기","url":"/docs-repository/docs/next-js/문서/폼-작성하기#6-자바스크립트가-활성화된-폼-제출하기","content":"/pages에 js-form.js라는 다른 파일을 생성합니다. 그러면 넥스트 앱에 /js-form 페이지가 생성됩니다. 이제 폼이 제출되는 즉시 페이지를 다시 로드하는 폼의 기본 작동을 막습니다. 폼 데이터를 가져와 JSON 문자열로 변환한 다음 API 엔드포인트인 서버로 보냅니다. 그러면 서버는 제출된 이름으로 응답합니다. 이 모든 것이 기본 자바스크립트인 handleSubmit() 함수에 의해 수행됩니다. 함수는 다음과 같습니다. jsx export default function PageWithJSbasedForm() { // 폼 제출을 처리합니다. const handleSubmit = async (event) =&gt; { // 폼 제출과 페이지 새로고침을 막습니다. event.preventDefault(); // 폼에서 데이터를 얻습니다. const data = { first: event.target.first.value, last: event.target.last.value, }; // 데이터를 JSON 형식으로 서버에 전송합니다. const JSONdata = JSON.stringify(data); // 폼 데이터를 전송하는 API 엔드포인트입니다. const endpoint = '/api/form'; // 서버로 전송하는 데이터 요청을 설정합니다. const options = { // 데이터를 전송하므로 메서드는 POST입니다. method: 'POST', // JSON을 전송한다고 서버에 알려줍니다. headers: { 'Content-Type': 'application/json', }, // 요청의 본문은 위에서 생성한 JSON 데이터입니다. body: JSONdata, }; // 폼 데이터를 베르셀의 폼 API로 전송하고 응답을 받습니다. const response = await fetch(endpoint, options); // 서버의 응답 데이터를 JSON으로 얻습니다. // 서버가 제출한 이름을 반환한다면 폼이 제대로 작동하는 것입니다. const result = await response.json(); alert(`Is this your full name: ${result.data}`); }; return ( // 제출 시에 이벤트를 handleSubmit() 함수에 전달합니다. &lt;form onSubmit={handleSubmit}&gt; &lt;label htmlFor=&quot;first&quot;&gt;First Name&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;first&quot; name=&quot;first&quot; required /&gt; &lt;label htmlFor=&quot;last&quot;&gt;Last Name&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;last&quot; name=&quot;last&quot; required /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; ); } 복사 jsx export default function PageWithJSbasedForm() { // 폼 제출을 처리합니다. const handleSubmit = async (event) =&gt; { // 폼 제출과 페이지 새로고침을 막습니다. event.preventDefault(); // 폼에서 데이터를 얻습니다. const data = { first: event.target.first.value, last: event.target.last.value, }; // 데이터를 JSON 형식으로 서버에 전송합니다. const JSONdata = JSON.stringify(data); // 폼 데이터를 전송하는 API 엔드포인트입니다. const endpoint = '/api/form'; // 서버로 전송하는 데이터 요청을 설정합니다. const options = { // 데이터를 전송하므로 메서드는 POST입니다. method: 'POST', // JSON을 전송한다고 서버에 알려줍니다. headers: { 'Content-Type': 'application/json', }, // 요청의 본문은 위에서 생성한 JSON 데이터입니다. body: JSONdata, }; // 폼 데이터를 베르셀의 폼 API로 전송하고 응답을 받습니다. const response = await fetch(endpoint, options); // 서버의 응답 데이터를 JSON으로 얻습니다. // 서버가 제출한 이름을 반환한다면 폼이 제대로 작동하는 것입니다. const result = await response.json(); alert(`Is this your full name: ${result.data}`); }; return ( // 제출 시에 이벤트를 handleSubmit() 함수에 전달합니다. &lt;form onSubmit={handleSubmit}&gt; &lt;label htmlFor=&quot;first&quot;&gt;First Name&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;first&quot; name=&quot;first&quot; required /&gt; &lt;label htmlFor=&quot;last&quot;&gt;Last Name&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;last&quot; name=&quot;last&quot; required /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; ); } 복사 JSX로 작성된 &lt;form&gt; 요소가 포함된 리액트 함수 컴포넌트 PageWithJSbasedForm가 있는 넥스트 페이지입니다. &lt;form&gt; 요소에는 action 속성이 없습니다. 대신 onSubmit 이벤트 핸들러를 사용하여 {handleSubmit} 함수에 데이터를 전송합니다. handleSubmit() 함수는 일련의 단계를 통해 폼 데이터를 처리합니다. event.preventDefault()는 &lt;form&gt; 요소가 페이지 전체를 새로고침하는 것을 막습니다.폼의 first와 last 값을 사용하여 자바스크립트 객체 data를 만들었습니다.JSON은 프로그래밍 언어에 구애받지 않는 데이터 전송 형식입니다. 그래서 JSON.stringify(data)를 사용해 데이터를 JSON으로 변환합니다.그런 다음 JSON과 HTTP POST 메서드 방식으로 fetch()를 사용해 /api/form 엔드포인트에 데이터를 전송합니다.서버는 제출된 이름이 포함된 응답을 다시 전송합니다. "},{"title":"결론​","type":1,"pageTitle":"넥스트로 폼 작성하기","url":"/docs-repository/docs/next-js/문서/폼-작성하기#결론","content":"이 안내서에서 다룬 내용은 다음과 같습니다. 기본 HTML form 요소React.js로 폼 이해하기자바스크립트를 사용하거나 사용하지 않고 폼 데이터의 유효성 검사하기넥스트 API 경로를 사용 하여 클라이언트와 서버에서 req와 res 처리하기 "}]